

# === Go Source ===


--| frontend/package.json

```json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier . --check",
    "format:fix": "prettier . --write"
  },
  "devDependencies": {
    "@eslint/js": "^9.20.0",
    "eslint": "^9.20.0",
    "eslint-config-prettier": "^10.0.1",
    "prettier": "^3.5.2",
    "typescript": "^5.4.5",
    "typescript-eslint": "^8.24.1",
    "vite": "^3.0.7",
    "vitest": "^1.6.0"
  },
  "dependencies": {
    "@lit-labs/preact-signals": "^1.0.3",
    "@preact/signals-core": "^1.12.2",
    "lit": "^3.3.2"
  }
}

```


--| frontend/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": false,
    "module": "ESNext",
    "moduleResolution": "Node",
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  },
  "include": [
    "src",
    "wailsjs"
  ]
}
```


--| frontend/wailsjs/runtime/package.json

```json
{
  "name": "@wailsapp/runtime",
  "version": "2.0.0",
  "description": "Wails Javascript runtime library",
  "main": "runtime.js",
  "types": "runtime.d.ts",
  "scripts": {
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wailsapp/wails.git"
  },
  "keywords": [
    "Wails",
    "Javascript",
    "Go"
  ],
  "author": "Lea Anthony <lea.anthony@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wailsapp/wails/issues"
  },
  "homepage": "https://github.com/wailsapp/wails#readme"
}

```


--| go.mod

```mod
module github.com/MadeByDoug/wls-chatbot

go 1.24.0

require (
	github.com/anthropics/anthropic-sdk-go v1.21.0
	github.com/cloudflare/cloudflare-go v0.116.0
	github.com/google/uuid v1.6.0
	github.com/openai/openai-go v1.12.0
	github.com/rs/zerolog v1.34.0
	github.com/spf13/cobra v1.10.2
	github.com/stretchr/testify v1.10.0
	github.com/zalando/go-keyring v0.2.6
	google.golang.org/genai v1.45.0
	modernc.org/sqlite v1.44.3
)

require (
	cloud.google.com/go v0.116.0 // indirect
	cloud.google.com/go/auth v0.9.3 // indirect
	cloud.google.com/go/compute/metadata v0.5.0 // indirect
	github.com/bep/debounce v1.2.1 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/go-ole/go-ole v1.3.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/google/go-querystring v1.1.0 // indirect
	github.com/google/s2a-go v0.1.8 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e // indirect
	github.com/labstack/echo/v4 v4.13.3 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/leaanthony/go-ansi-parser v1.6.1 // indirect
	github.com/leaanthony/gosod v1.0.4 // indirect
	github.com/leaanthony/slicer v1.6.0 // indirect
	github.com/leaanthony/u v1.1.1 // indirect
	github.com/ncruces/go-strftime v1.0.0 // indirect
	github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/samber/lo v1.49.1 // indirect
	github.com/spf13/pflag v1.0.9 // indirect
	github.com/tkrajina/go-reflector v0.5.8 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/wailsapp/go-webview2 v1.0.22 // indirect
	github.com/wailsapp/mimetype v1.4.1 // indirect
	go.opencensus.io v0.24.0 // indirect
	golang.org/x/crypto v0.40.0 // indirect
	golang.org/x/exp v0.0.0-20251023183803-a4bb9ffd2546 // indirect
	golang.org/x/net v0.41.0 // indirect
	golang.org/x/text v0.27.0 // indirect
	golang.org/x/time v0.9.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240903143218-8af14fe29dc1 // indirect
	google.golang.org/grpc v1.66.2 // indirect
	google.golang.org/protobuf v1.34.2 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	modernc.org/libc v1.67.6 // indirect
	modernc.org/mathutil v1.7.1 // indirect
	modernc.org/memory v1.11.0 // indirect
)

require (
	al.essio.dev/pkg/shellescape v1.5.1 // indirect
	github.com/danieljoos/wincred v1.2.2 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/tidwall/gjson v1.18.0 // indirect
	github.com/tidwall/match v1.2.0 // indirect
	github.com/tidwall/pretty v1.2.1 // indirect
	github.com/tidwall/sjson v1.2.5 // indirect
	github.com/wailsapp/wails/v2 v2.11.0
	golang.org/x/sys v0.38.0 // indirect
)

// replace github.com/wailsapp/wails/v2 v2.11.0 => /home/doug/go/pkg/mod

```


--| internal/core/adapters/datastore/schema.sql

```sql
-- schema.sql aggregates all application tables.

-- Config Store
CREATE TABLE IF NOT EXISTS app_config (
	id INTEGER PRIMARY KEY CHECK (id = 1),
	config_json TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL
);

-- Catalog Repo
CREATE TABLE IF NOT EXISTS catalog_providers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    adapter_type TEXT NOT NULL,
    trust_mode TEXT NOT NULL,
    base_url TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    last_test_at INTEGER,
    last_test_ok INTEGER CHECK (last_test_ok IN (0, 1)),
    last_error TEXT,
    last_discovery_at INTEGER
);

CREATE TABLE IF NOT EXISTS provider_inputs (
    provider_id TEXT NOT NULL,
    input_key TEXT NOT NULL,
    input_value TEXT NOT NULL,
    PRIMARY KEY (provider_id, input_key),
    FOREIGN KEY (provider_id) REFERENCES catalog_providers(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS catalog_endpoints (
    id TEXT PRIMARY KEY,
    provider_id TEXT NOT NULL,
    display_name TEXT NOT NULL,
    adapter_type TEXT NOT NULL,
    base_url TEXT NOT NULL,
    route_kind TEXT NOT NULL,
    origin_provider TEXT NOT NULL,
    origin_route_label TEXT NOT NULL,
    auth_json TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    last_test_at INTEGER,
    last_test_ok INTEGER CHECK (last_test_ok IN (0, 1)),
    last_error TEXT,
    FOREIGN KEY (provider_id) REFERENCES catalog_providers(id) ON DELETE CASCADE,
    UNIQUE (provider_id, route_kind, origin_provider, origin_route_label, base_url)
);

CREATE TABLE IF NOT EXISTS model_catalog_entries (
    id TEXT PRIMARY KEY,
    endpoint_id TEXT NOT NULL,
    model_id TEXT NOT NULL,
    display_name TEXT,
    first_seen_at INTEGER NOT NULL,
    last_seen_at INTEGER NOT NULL,
    availability_state TEXT NOT NULL,
    approved INTEGER NOT NULL CHECK (approved IN (0, 1)),
    missed_refreshes INTEGER NOT NULL,
    source TEXT NOT NULL DEFAULT 'discovered',
    metadata_json TEXT,
    FOREIGN KEY (endpoint_id) REFERENCES catalog_endpoints(id) ON DELETE CASCADE,
    UNIQUE (endpoint_id, model_id)
);

CREATE TABLE IF NOT EXISTS model_capabilities (
    model_catalog_entry_id TEXT PRIMARY KEY,
    supports_streaming INTEGER NOT NULL CHECK (supports_streaming IN (0, 1)),
    supports_tool_calling INTEGER NOT NULL CHECK (supports_tool_calling IN (0, 1)),
    supports_structured_output INTEGER NOT NULL CHECK (supports_structured_output IN (0, 1)),
    supports_vision INTEGER NOT NULL CHECK (supports_vision IN (0, 1)),
    capabilities_source TEXT NOT NULL,
    capabilities_as_of INTEGER NOT NULL,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_capabilities_input_modalities (
    model_catalog_entry_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, modality),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_capabilities_output_modalities (
    model_catalog_entry_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, modality),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_system_profile (
    model_catalog_entry_id TEXT PRIMARY KEY,
    latency_tier TEXT NOT NULL,
    cost_tier TEXT NOT NULL,
    reliability_tier TEXT NOT NULL,
    system_profile_source TEXT NOT NULL,
    system_profile_as_of INTEGER NOT NULL,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_system_tags (
    model_catalog_entry_id TEXT NOT NULL,
    tag TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, tag),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_user_addenda (
    model_catalog_entry_id TEXT PRIMARY KEY,
    notes TEXT,
    user_addenda_source TEXT NOT NULL,
    user_addenda_as_of INTEGER NOT NULL,
    latency_tier_override TEXT,
    cost_tier_override TEXT,
    reliability_tier_override TEXT,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_user_tags (
    model_catalog_entry_id TEXT NOT NULL,
    tag TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, tag),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS roles (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    requires_streaming INTEGER NOT NULL CHECK (requires_streaming IN (0, 1)),
    requires_tool_calling INTEGER NOT NULL CHECK (requires_tool_calling IN (0, 1)),
    requires_structured_output INTEGER NOT NULL CHECK (requires_structured_output IN (0, 1)),
    requires_vision INTEGER NOT NULL CHECK (requires_vision IN (0, 1)),
    max_cost_tier TEXT,
    max_latency_tier TEXT,
    min_reliability_tier TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS role_required_input_modalities (
    role_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (role_id, modality),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS role_required_output_modalities (
    role_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (role_id, modality),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS role_assignments (
    role_id TEXT NOT NULL,
    model_catalog_entry_id TEXT NOT NULL,
    assigned_by TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    enabled INTEGER NOT NULL CHECK (enabled IN (0, 1)),
    PRIMARY KEY (role_id, model_catalog_entry_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

-- Chat Repo
CREATE TABLE IF NOT EXISTS chat_conversations (
	id TEXT PRIMARY KEY,
	title TEXT NOT NULL,
	provider TEXT NOT NULL,
	model TEXT NOT NULL,
	temperature REAL NOT NULL,
	max_tokens INTEGER NOT NULL,
	system_prompt TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL,
	is_archived INTEGER NOT NULL CHECK (is_archived IN (0, 1))
);

CREATE TABLE IF NOT EXISTS chat_messages (
	id TEXT PRIMARY KEY,
	conversation_id TEXT NOT NULL,
	role TEXT NOT NULL,
	timestamp INTEGER NOT NULL,
	is_streaming INTEGER NOT NULL CHECK (is_streaming IN (0, 1)),
	provider TEXT,
	model TEXT,
	tokens_in INTEGER,
	tokens_out INTEGER,
	tokens_total INTEGER,
	latency_ms INTEGER,
	finish_reason TEXT,
	status_code INTEGER,
	error_message TEXT,
	FOREIGN KEY (conversation_id) REFERENCES chat_conversations(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_chat_messages_conversation_ts
ON chat_messages (conversation_id, timestamp DESC);

CREATE TABLE IF NOT EXISTS chat_message_blocks (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	message_id TEXT NOT NULL,
	block_index INTEGER NOT NULL,
	block_type TEXT NOT NULL,
	content TEXT NOT NULL,
	language TEXT,
	is_collapsed INTEGER NOT NULL CHECK (is_collapsed IN (0, 1)),
	artifact_id TEXT,
	artifact_name TEXT,
	artifact_type TEXT,
	artifact_content TEXT,
	artifact_language TEXT,
	artifact_version INTEGER,
	artifact_created_at INTEGER,
	artifact_updated_at INTEGER,
	action_id TEXT,
	action_tool_name TEXT,
	action_description TEXT,
	action_status TEXT,
	action_result TEXT,
	action_started_at INTEGER,
	action_completed_at INTEGER,
	FOREIGN KEY (message_id) REFERENCES chat_messages(id) ON DELETE CASCADE
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_chat_message_blocks_order
ON chat_message_blocks (message_id, block_index);

-- Notifications
CREATE TABLE IF NOT EXISTS notifications (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	type TEXT NOT NULL,
	title TEXT NOT NULL,
	message TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	read_at INTEGER
);

CREATE INDEX IF NOT EXISTS idx_notifications_created_at
ON notifications (created_at DESC);

```


--| internal/core/adapters/datastore/seed.sql

```sql
-- seed.sql initializes the database with default data.

-- Initial App Config
INSERT OR IGNORE INTO app_config (id, config_json, created_at, updated_at)
VALUES (
    1,
    '{
        "theme": "dark",
        "providers": [
            {
                "name": "openai",
                "displayName": "OpenAI",
                "type": "openai",
                "enabled": true,
                "baseUrl": "https://api.openai.com/v1",
                "defaultModel": "gpt-4o",
                "inputs": {}
            },
            {
                "name": "anthropic",
                "displayName": "Anthropic",
                "type": "anthropic",
                "enabled": true,
                "baseUrl": "https://api.anthropic.com/v1",
                "defaultModel": "claude-3-5-sonnet-20240620",
                "inputs": {}
            },
            {
                "name": "gemini",
                "displayName": "Google Gemini",
                "type": "gemini",
                "enabled": true,
                "baseUrl": "https://generativelanguage.googleapis.com/v1beta",
                "defaultModel": "gemini-1.5-pro",
                "inputs": {}
            },
            {
                "name": "grok",
                "displayName": "Grok (xAI)",
                "type": "grok",
                "enabled": true,
                "baseUrl": "https://api.x.ai/v1",
                "defaultModel": "grok-beta",
                "inputs": {}
            },
             {
                "name": "openrouter",
                "displayName": "OpenRouter",
                "type": "openrouter",
                "enabled": true,
                "baseUrl": "https://openrouter.ai/api/v1",
                "defaultModel": "openai/gpt-4o-mini",
                "inputs": {}
            }
        ]
    }',
    strftime('%s', 'now') * 1000,
    strftime('%s', 'now') * 1000
);

-- Populate Catalog Providers matches App Config for consistency
INSERT OR IGNORE INTO catalog_providers (id, name, display_name, adapter_type, trust_mode, base_url, created_at, updated_at)
VALUES 
('prov_openai', 'openai', 'OpenAI', 'openai', 'user_managed', 'https://api.openai.com/v1', strftime('%s', 'now') * 1000, strftime('%s', 'now') * 1000),
('prov_anthropic', 'anthropic', 'Anthropic', 'anthropic', 'user_managed', 'https://api.anthropic.com/v1', strftime('%s', 'now') * 1000, strftime('%s', 'now') * 1000),
('prov_gemini', 'gemini', 'Google Gemini', 'gemini', 'user_managed', 'https://generativelanguage.googleapis.com/v1beta', strftime('%s', 'now') * 1000, strftime('%s', 'now') * 1000),
('prov_grok', 'grok', 'Grok (xAI)', 'openai', 'user_managed', 'https://api.x.ai/v1', strftime('%s', 'now') * 1000, strftime('%s', 'now') * 1000),
('prov_openrouter', 'openrouter', 'OpenRouter', 'openai', 'user_managed', 'https://openrouter.ai/api/v1', strftime('%s', 'now') * 1000, strftime('%s', 'now') * 1000);

```


--| internal/core/adapters/datastore/seeder.go

```go
// seeder.go imports model catalog seed data into the datastore.
// internal/core/adapters/datastore/seeder.go
package datastore

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// ModelData represents the root structure of models.yaml
type ModelData struct {
	Families []Family `yaml:"families"`
	Models   []Model  `yaml:"models"`
}

// Family represents a model family with shared capabilities
type Family struct {
	ID         string                 `yaml:"id"`
	Provider   string                 `yaml:"provider"`
	Modalities Modalities             `yaml:"modalities"`
	Capabilities  Capabilities           `yaml:"capabilities"`
	SystemTags []string               `yaml:"system_tags"`
}

// Model represents a specific model snapshot or alias
type Model struct {
	ID         string `yaml:"id"`
	Family     string `yaml:"family"`
	IsSnapshot bool   `yaml:"is_snapshot"`
	LinkAlias  string `yaml:"link_alias,omitempty"`
}

// Modalities defines input and output modalities
type Modalities struct {
	Input  []string `yaml:"input"`
	Output []string `yaml:"output"`
}

// Capabilities defines model capabilities
type Capabilities struct {
	Streaming        bool `yaml:"streaming"`
	ToolCalling      bool `yaml:"tool_calling"`
	StructuredOutput bool `yaml:"structured_output"`
	Vision           bool `yaml:"vision"`
}

// seededProvider describes a provider row used by model seeding.
type seededProvider struct {
	ID          string
	Name        string
	DisplayName string
	AdapterType string
	BaseURL     string
}

// SeedModels populates the database with model data from YAML
func SeedModels(db *sql.DB, data []byte) error {
	var catalog ModelData
	if err := yaml.Unmarshal(data, &catalog); err != nil {
		return fmt.Errorf("unmarshal models.yaml: %w", err)
	}

	families := make(map[string]Family)
	for _, f := range catalog.Families {
		families[f.ID] = f
	}

	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}
	defer func() {
		_ = tx.Rollback() // Rollback is a no-op if tx.Commit() was called
	}()

	now := time.Now().UnixMilli()

	// Prepare statements
	stmtEndpoint, err := tx.Prepare(`
		INSERT INTO catalog_endpoints (
			id, provider_id, display_name, adapter_type, base_url, route_kind, 
			origin_provider, origin_route_label, created_at, updated_at
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		ON CONFLICT(id) DO UPDATE SET updated_at = ?
	`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtEndpoint.Close() }()

	stmtEntry, err := tx.Prepare(`
		INSERT INTO model_catalog_entries (
			id, endpoint_id, model_id, display_name, first_seen_at, last_seen_at, 
			availability_state, approved, missed_refreshes, source, metadata_json
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		ON CONFLICT(endpoint_id, model_id) DO UPDATE SET last_seen_at = ?
	`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtEntry.Close() }()

	stmtCapabilities, err := tx.Prepare(`
		INSERT OR REPLACE INTO model_capabilities (
			model_catalog_entry_id, supports_streaming, supports_tool_calling, 
			supports_structured_output, supports_vision, capabilities_source, capabilities_as_of
		) VALUES (?, ?, ?, ?, ?, ?, ?)
	`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtCapabilities.Close() }()

	stmtSysTags, err := tx.Prepare(`INSERT OR IGNORE INTO model_system_tags (model_catalog_entry_id, tag) VALUES (?, ?)`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtSysTags.Close() }()
	
	stmtInputMod, err := tx.Prepare(`INSERT OR IGNORE INTO model_capabilities_input_modalities (model_catalog_entry_id, modality) VALUES (?, ?)`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtInputMod.Close() }()

	stmtOutputMod, err := tx.Prepare(`INSERT OR IGNORE INTO model_capabilities_output_modalities (model_catalog_entry_id, modality) VALUES (?, ?)`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtOutputMod.Close() }()


	for _, model := range catalog.Models {
		fam, ok := families[model.Family]
		if !ok {
			return fmt.Errorf("unknown family %q for model %q", model.Family, model.ID)
		}
		provider, err := resolveSeededProvider(tx, fam.Provider)
		if err != nil {
			return fmt.Errorf("resolve provider for family %q: %w", model.Family, err)
		}

		// 1. Ensure Endpoint Exists (provider_id is constructed from provider name)
		endpointID := "ep_" + provider.Name + "_default"

		if _, err := stmtEndpoint.Exec(
			endpointID, provider.ID, provider.DisplayName+" Default", provider.AdapterType, provider.BaseURL, "llm",
			provider.Name, "default", now, now, now,
		); err != nil {
			return fmt.Errorf("insert endpoint: %w", err)
		}

		// 2. Insert Model Entry
		entryID := "entry_" + provider.Name + "_" + model.ID
		metadata := map[string]interface{}{
			"family":      model.Family,
			"is_snapshot": model.IsSnapshot,
		}
		if model.LinkAlias != "" {
			metadata["link_alias"] = model.LinkAlias
		}
		metaBytes, _ := json.Marshal(metadata)

		if _, err := stmtEntry.Exec(
			entryID, endpointID, model.ID, model.ID, now, now, 
			"available", 1, 0, "seed", string(metaBytes), now,
		); err != nil {
			return fmt.Errorf("insert entry %s: %w", model.ID, err)
		}

		// 3. Insert Capabilities
		if _, err := stmtCapabilities.Exec(
			entryID, fam.Capabilities.Streaming, fam.Capabilities.ToolCalling, 
			fam.Capabilities.StructuredOutput, fam.Capabilities.Vision, "seed_v1", now,
		); err != nil {
			return fmt.Errorf("insert capabilities %s: %w", model.ID, err)
		}

		// 4. Insert Tags & Modalities
		for _, tag := range fam.SystemTags {
			if _, err := stmtSysTags.Exec(entryID, tag); err != nil { return err }
		}
		for _, mod := range fam.Modalities.Input {
			if _, err := stmtInputMod.Exec(entryID, mod); err != nil { return err }
		}
		for _, mod := range fam.Modalities.Output {
			if _, err := stmtOutputMod.Exec(entryID, mod); err != nil { return err }
		}
	}

	return tx.Commit()
}

// resolveSeededProvider maps YAML provider identifiers to catalog providers.
func resolveSeededProvider(tx *sql.Tx, providerName string) (seededProvider, error) {

	name := strings.TrimSpace(strings.ToLower(providerName))
	switch name {
	case "google":
		name = "gemini"
	case "xai":
		name = "grok"
	}

	var provider seededProvider
	if err := tx.QueryRow(
		`SELECT id, name, display_name, adapter_type, base_url
		 FROM catalog_providers
		 WHERE name = ?`,
		name,
	).Scan(
		&provider.ID,
		&provider.Name,
		&provider.DisplayName,
		&provider.AdapterType,
		&provider.BaseURL,
	); err != nil {
		if err == sql.ErrNoRows {
			return seededProvider{}, fmt.Errorf("provider %q not found in catalog_providers", name)
		}
		return seededProvider{}, err
	}

	if provider.BaseURL == "" {
		return seededProvider{}, fmt.Errorf("provider %q has empty base_url", provider.Name)
	}

	return provider, nil
}

```


--| internal/core/adapters/datastore/seeds/models.yaml

```yaml
families:

  # OpenAI Model Families
  - id: gpt-4o
    provider: openai
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - multimodal_in
  
  - id: gpt-4o-mini
    provider: openai
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - fast
      - cost_efficient
      - multimodal_in
  
  - id: o1
    provider: openai
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - reasoning
      - multimodal_in
  
  - id: o1-mini
    provider: openai
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: false
    system_tags:
      - reasoning
      - fast
      - cost_efficient
  
  - id: dall-e-3
    provider: openai
    modalities:
      input:
        - text
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: false
    system_tags:
      - image_gen
  
  # Google Model Families
  - id: gemini-2.0-flash
    provider: google
    modalities:
      input:
        - text
        - image
        - video
        - audio
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - fast
      - multimodal_in
  
  - id: gemini-1.5-pro
    provider: google
    modalities:
      input:
        - text
        - image
        - video
        - audio
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - multimodal_in
  
  - id: imagen-4.0
    provider: google
    modalities:
      input:
        - text
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: false
    system_tags:
      - image_gen

  # Grok Model Families
  - id: grok-4-1-fast-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - reasoning
      - fast
      - multimodal_in
  
  - id: grok-4-1-fast-non-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: true
    system_tags:
      - non_reasoning
      - fast
      - multimodal_in
  
  - id: grok-code-fast-1
    provider: grok
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: false
    system_tags:
      - coding
      - fast
  
  - id: grok-4-fast-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - reasoning
      - fast
      - multimodal_in
  
  - id: grok-4-fast-non-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: true
    system_tags:
      - non_reasoning
      - fast
      - multimodal_in
  
  - id: grok-4-0709
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - multimodal_in
  
  - id: grok-3-mini
    provider: grok
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: false
    system_tags:
      - general
      - fast
      - cost_efficient
  
  - id: grok-3
    provider: grok
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: false
    system_tags:
      - general
  
  - id: grok-2-vision-1212
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: true
    system_tags:
      - general
      - multimodal_in
      - legacy
  
  - id: grok-imagine-image-pro
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: true
    system_tags:
      - image_gen
      - multimodal_in
  
  - id: grok-imagine-image
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: true
    system_tags:
      - image_gen
      - multimodal_in
      - cost_efficient
  
  - id: grok-2-image-1212
    provider: grok
    modalities:
      input:
        - text
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: false
    system_tags:
      - image_gen
      - legacy
  
  - id: grok-imagine-video
    provider: grok
    modalities:
      input:
        - text
        - image
        - video
      output:
        - video
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: true
    system_tags:
      - video_gen
      - multimodal_in


models:

  # OpenAI Models
  - id: gpt-4o
    family: gpt-4o
    is_snapshot: false
  
  - id: gpt-4o-2024-11-20
    family: gpt-4o
    is_snapshot: true
  
  - id: gpt-4o-mini
    family: gpt-4o-mini
    is_snapshot: false
  
  - id: gpt-4o-mini-2024-07-18
    family: gpt-4o-mini
    is_snapshot: true
  
  - id: o1
    family: o1
    is_snapshot: false
  
  - id: o1-2024-12-17
    family: o1
    is_snapshot: true
  
  - id: o1-mini
    family: o1-mini
    is_snapshot: false
  
  - id: o1-mini-2024-09-12
    family: o1-mini
    is_snapshot: true
  
  - id: dall-e-3
    family: dall-e-3
    is_snapshot: false
  
  # Google Models
  - id: gemini-2.0-flash-exp
    family: gemini-2.0-flash
    is_snapshot: false
  
  - id: gemini-1.5-pro-latest
    family: gemini-1.5-pro
    is_snapshot: false
  
  - id: imagen-4.0-generate-001
    family: imagen-4.0
    is_snapshot: true
  
  - id: imagen-4.0-fast-generate-001
    family: imagen-4.0
    is_snapshot: true
  
  - id: imagen-4.0-ultra-generate-001
    family: imagen-4.0
    is_snapshot: true

  # Grok Models
  - id: grok-4-1-fast-reasoning
    family: grok-4-1-fast-reasoning
    is_snapshot: false
  
  - id: grok-4-1-fast-non-reasoning
    family: grok-4-1-fast-non-reasoning
    is_snapshot: false
  
  - id: grok-code-fast-1
    family: grok-code-fast-1
    is_snapshot: false
  
  - id: grok-4-fast-reasoning
    family: grok-4-fast-reasoning
    is_snapshot: false
```


--| internal/core/adapters/datastore/sqlite.go

```go
// sqlite.go opens and configures the shared SQLite datastore.
// internal/core/adapters/datastore/sqlite.go
package datastore

import (
	"database/sql"
	"embed"
	"fmt"
	"os"
	"path/filepath"

	"github.com/rs/zerolog/log"
	_ "modernc.org/sqlite" // @TODO is the blank import necessary?
)

//go:embed schema.sql seed.sql seeds/models.yaml
var sqlFiles embed.FS

const minimumDefaultProviderCount = 5

var requiredSchemaTables = []string{
	"app_config",
	"catalog_providers",
	"provider_inputs",
	"catalog_endpoints",
	"model_catalog_entries",
	"model_capabilities",
	"model_capabilities_input_modalities",
	"model_capabilities_output_modalities",
	"model_system_profile",
	"model_system_tags",
	"model_user_addenda",
	"model_user_tags",
	"roles",
	"role_required_input_modalities",
	"role_required_output_modalities",
	"role_assignments",
	"chat_conversations",
	"chat_messages",
	"chat_message_blocks",
	"notifications",
}

// OpenSQLite opens the SQLite database at the provided path.
func OpenSQLite(path string) (*sql.DB, error) {

	if path == "" {
		return nil, fmt.Errorf("open sqlite: path required")
	}

	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return nil, fmt.Errorf("open sqlite: ensure directory: %w", err)
	}

	db, err := sql.Open("sqlite", path)
	if err != nil {
		return nil, fmt.Errorf("open sqlite: %w", err)
	}

	if err := db.Ping(); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}

	db.SetMaxOpenConns(1)
	db.SetMaxIdleConns(1)

	if _, err := db.Exec("PRAGMA foreign_keys = ON"); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}
	if _, err := db.Exec("PRAGMA journal_mode = WAL"); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}
	if _, err := db.Exec("PRAGMA synchronous = NORMAL"); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}

	needsInit, err := shouldInitializeDatabase(db)
	if err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: check initialization state: %w", err)
	}
	if needsInit {
		log.Info().Str("path", path).Msg("Initializing SQLite datastore")
		if err := initDatabase(db); err != nil {
			_ = db.Close()
			return nil, fmt.Errorf("open sqlite: init failed: %w", err)
		}

		needsInit, err = shouldInitializeDatabase(db)
		if err != nil {
			_ = db.Close()
			return nil, fmt.Errorf("open sqlite: verify initialization state: %w", err)
		}
		if needsInit {
			_ = db.Close()
			return nil, fmt.Errorf("open sqlite: init failed: datastore remains incomplete")
		}
	}

	return db, nil
}

// shouldInitializeDatabase determines whether schema and seed data are complete.
func shouldInitializeDatabase(db *sql.DB) (bool, error) {

	for _, tableName := range requiredSchemaTables {
		exists, err := tableExists(db, tableName)
		if err != nil {
			return false, err
		}
		if !exists {
			return true, nil
		}
	}

	appConfigRows, err := countRows(db, "SELECT COUNT(*) FROM app_config WHERE id = 1")
	if err != nil {
		return false, err
	}
	if appConfigRows == 0 {
		return true, nil
	}

	defaultProviders, err := countRows(db, "SELECT COUNT(*) FROM catalog_providers")
	if err != nil {
		return false, err
	}
	if defaultProviders < minimumDefaultProviderCount {
		return true, nil
	}

	seedModels, err := countRows(db, "SELECT COUNT(*) FROM model_catalog_entries WHERE source = 'seed'")
	if err != nil {
		return false, err
	}
	return seedModels == 0, nil
}

// tableExists returns whether a SQLite table exists.
func tableExists(db *sql.DB, tableName string) (bool, error) {

	var count int
	if err := db.QueryRow(
		"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name = ?",
		tableName,
	).Scan(&count); err != nil {
		return false, err
	}
	return count > 0, nil
}

// countRows executes a scalar count query.
func countRows(db *sql.DB, query string, args ...any) (int, error) {

	var count int
	if err := db.QueryRow(query, args...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// initDatabase executes the schema and seed scripts.
func initDatabase(db *sql.DB) error {

	log.Debug().Msg("Applying schema initialization script")
	schema, err := sqlFiles.ReadFile("schema.sql")
	if err != nil {
		return fmt.Errorf("read schema: %w", err)
	}
	if _, err := db.Exec(string(schema)); err != nil {
		return fmt.Errorf("exec schema: %w", err)
	}

	log.Debug().Msg("Applying seed initialization script")
	seed, err := sqlFiles.ReadFile("seed.sql")
	if err != nil {
		return fmt.Errorf("read seed: %w", err)
	}
	if _, err := db.Exec(string(seed)); err != nil {
		return fmt.Errorf("exec seed: %w", err)
	}

	log.Debug().Msg("Applying model seed initialization script")
	models, err := sqlFiles.ReadFile("seeds/models.yaml")
	if err != nil {
		return fmt.Errorf("read models.yaml: %w", err)
	}
	if err := SeedModels(db, models); err != nil {
		return fmt.Errorf("seed models: %w", err)
	}
	log.Debug().Msg("SQLite datastore initialization completed")

	return nil
}

```


--| internal/core/adapters/logger/log_bridge.go

```go
// bridge frontend log entries into zerolog.
// internal/core/adapters/logger/log_bridge.go
package logger

import (
	"github.com/rs/zerolog"
)

// LogEntry is a strictly typed log structure for the frontend bridge.
type LogEntry struct {
	Level   string            `json:"level"`
	Message string            `json:"message"`
	Fields  map[string]string `json:"fields"`
}

// Logger acts as a bridge for frontend logging.
type Logger struct {
	logger zerolog.Logger
}

// NewLogBridge creates a new Logger bridge.
func NewLogBridge(l zerolog.Logger) *Logger {

	return &Logger{
		logger: l,
	}
}

// Log logs an entry from the frontend.
func (b *Logger) Log(entry LogEntry) {

	// Create a sub-logger event based on the level
	var event *zerolog.Event
	switch entry.Level {
	case "trace":
		event = b.logger.Trace()
	case "debug":
		event = b.logger.Debug()
	case "info":
		event = b.logger.Info()
	case "warn":
		event = b.logger.Warn()
	case "error":
		event = b.logger.Error()
	case "fatal":
		event = b.logger.Error()
	case "panic":
		event = b.logger.Error()
	default:
		event = b.logger.Info()
	}

	// Attach fields
	for k, v := range entry.Fields {
		event.Str(k, v)
	}
	if entry.Level == "fatal" || entry.Level == "panic" {
		event.Str("frontend_level", entry.Level)
	}

	// Log with message
	event.Msg(entry.Message)
}

```


--| internal/core/adapters/logger/wails_logger.go

```go
// wails_logger.go adapts zerolog to the Wails logger interface.
// internal/core/adapters/logger/wails_logger.go
package logger

import (
	"strings"

	"github.com/rs/zerolog"
)

// WailsLogger routes Wails internal logs through zerolog.
type WailsLogger struct {
	logger zerolog.Logger
}

// NewWailsLogger creates a logger adapter for Wails internals.
func NewWailsLogger(l zerolog.Logger) *WailsLogger {

	return &WailsLogger{logger: l}
}

// Print logs a plain Wails message.
func (l *WailsLogger) Print(message string) {

	l.log("print", message)
}

// Trace logs a Wails trace message.
func (l *WailsLogger) Trace(message string) {

	l.log("trace", message)
}

// Debug logs a Wails debug message.
func (l *WailsLogger) Debug(message string) {

	l.log("debug", message)
}

// Info logs a Wails info message.
func (l *WailsLogger) Info(message string) {

	l.log("info", message)
}

// Warning logs a Wails warning message.
func (l *WailsLogger) Warning(message string) {

	l.log("warning", message)
}

// Error logs a Wails error message.
func (l *WailsLogger) Error(message string) {

	l.log("error", message)
}

// Fatal logs a Wails fatal message.
func (l *WailsLogger) Fatal(message string) {

	l.log("fatal", message)
}

// log emits the message at the selected level unless filtered.
func (l *WailsLogger) log(level, message string) {

	if l == nil {
		return
	}

	msg := strings.TrimSpace(message)
	if msg == "" || suppressRuntimeReadyNoise(msg) {
		return
	}

	scopedLogger := l.logger.With().
		Str("source", "wails").
		Str("wails_level", level).
		Logger()

	event := scopedLogger.Info()

	switch level {
	case "trace":
		event = scopedLogger.Trace()
	case "debug":
		event = scopedLogger.Debug()
	case "warning":
		event = scopedLogger.Warn()
	case "error", "fatal":
		event = scopedLogger.Error()
	}

	event.Msg(msg)
}

// suppressRuntimeReadyNoise filters a known Wails dev-runtime protocol warning.
func suppressRuntimeReadyNoise(message string) bool {

	if !strings.Contains(message, "runtime:ready") {
		return false
	}
	if strings.Contains(message, "process message error: runtime:ready") {
		return true
	}
	return strings.Contains(message, "Unknown message from front end: runtime:ready")
}

```


--| internal/core/adapters/logger/zerolog.go

```go
// configure and adapt zerolog for core logging.
// internal/core/adapters/logger/zerolog.go
package logger

import (
	"os"
	"time"

	"github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

// New creates a new configured zerolog.Logger.
// It defaults to writing to a ConsoleWriter for human-readable output during development.
// This is compatible with Windows, Linux, and macOS.
func New(level string) zerolog.Logger {

	// Set global log level
	switch level {
	case "trace":
		zerolog.SetGlobalLevel(zerolog.TraceLevel)
	case "debug":
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	case "info":
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	case "warn":
		zerolog.SetGlobalLevel(zerolog.WarnLevel)
	case "error":
		zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	default:
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	}

	// Use ConsoleWriter for nicer development logs.
	// Out defaults to os.Stderr which is standard.
	// TimeFormat conforms to standard convenient reading.
	output := zerolog.ConsoleWriter{
		Out:        os.Stderr,
		TimeFormat: time.TimeOnly,
	}

	// Create a new logger with timestamp and caller information
	l := log.Output(output).With().Timestamp().Caller().Logger()

	return l
}

// Adapter bridges zerolog into the core Logger port.
type Adapter struct {
	logger zerolog.Logger
}

// NewAdapter creates a logger adapter for core use cases.
func NewAdapter(l zerolog.Logger) *Adapter {
	return &Adapter{logger: l}
}

// Trace logs a trace message.
func (a *Adapter) Trace(message string, fields ...ports.LogField) {
	if a == nil {
		return
	}
	event := a.logger.Trace()
	writeFields(event, fields)
	event.Msg(message)
}

// Debug logs a debug message.
func (a *Adapter) Debug(message string, fields ...ports.LogField) {
	if a == nil {
		return
	}
	event := a.logger.Debug()
	writeFields(event, fields)
	event.Msg(message)
}

// Info logs an info message.
func (a *Adapter) Info(message string, fields ...ports.LogField) {
	if a == nil {
		return
	}
	event := a.logger.Info()
	writeFields(event, fields)
	event.Msg(message)
}

// Warn logs a warning message with an optional error.
func (a *Adapter) Warn(message string, err error, fields ...ports.LogField) {
	if a == nil {
		return
	}
	event := a.logger.Warn()
	if err != nil {
		event = event.Err(err)
	}
	writeFields(event, fields)
	event.Msg(message)
}

// Error logs an error message with an optional error.
func (a *Adapter) Error(message string, err error, fields ...ports.LogField) {

	if a == nil {
		return
	}
	event := a.logger.Error()
	if err != nil {
		event = event.Err(err)
	}
	writeFields(event, fields)
	event.Msg(message)
}

func writeFields(event *zerolog.Event, fields []ports.LogField) {

	for _, field := range fields {
		event.Str(field.Key, field.Value)
	}
}

```


--| internal/core/adapters/wails/bridge.go

```go
// provide Wails bindings for frontend-backend communication.
// internal/core/adapters/wails/bridge.go
package wails

import (
	"context"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	"github.com/MadeByDoug/wls-chatbot/internal/features/catalog/usecase"
	"github.com/MadeByDoug/wls-chatbot/internal/features/chat/usecase"
	"github.com/MadeByDoug/wls-chatbot/internal/features/notifications/usecase"
	"github.com/MadeByDoug/wls-chatbot/internal/features/settings/usecase"
)

// Bridge is the main Wails binding struct that exposes backend functionality to the frontend.
type Bridge struct {
	chat          *chat.Orchestrator
	providers     *provider.Orchestrator
	catalog       *catalog.Orchestrator
	notifications *notifications.Orchestrator
	emitter       *Emitter

	ctx context.Context
}

// New creates a new Bridge instance.
func New(chatPolicy *chat.Orchestrator, providerPolicy *provider.Orchestrator, catalogPolicy *catalog.Orchestrator, notificationPolicy *notifications.Orchestrator, emitter *Emitter) *Bridge {

	return &Bridge{
		chat:          chatPolicy,
		providers:     providerPolicy,
		catalog:       catalogPolicy,
		notifications: notificationPolicy,
		emitter:       emitter,
	}
}

// Startup is called by Wails when the application starts.
func (b *Bridge) Startup(ctx context.Context) {

	b.ctx = ctx
	if b.emitter != nil {
		b.emitter.SetContext(ctx)
	}
	if b.catalog != nil {
		go func() {
			if err := b.catalog.RefreshAll(b.ctxOrBackground()); err != nil && b.emitter != nil {
				b.emitter.EmitToast(coreports.ToastPayload{
					Type:    "error",
					Title:   "Catalog refresh failed",
					Message: err.Error(),
				})
			}
		}()
	}
}

// Shutdown is called by Wails when the application shuts down.
func (b *Bridge) Shutdown(context.Context) {

	b.ctx = nil
	if b.emitter != nil {
		b.emitter.ClearContext()
	}
}

// ctxOrBackground returns the app context or a background context if nil.
func (b *Bridge) ctxOrBackground() context.Context {

	if b.ctx != nil {
		return b.ctx
	}
	return context.Background()
}

```


--| internal/core/adapters/wails/catalog_api.go

```go
// expose model catalog and role endpoints to the frontend.
// internal/core/adapters/wails/catalog_api.go
package wails

import (
	"fmt"

	"github.com/MadeByDoug/wls-chatbot/internal/features/catalog/usecase"
)

// GetCatalogOverview returns the model catalog overview.
func (b *Bridge) GetCatalogOverview() (catalog.CatalogOverview, error) {

	if b.catalog == nil {
		return catalog.CatalogOverview{}, fmt.Errorf("catalog orchestrator not configured")
	}
	return b.catalog.GetOverview(b.ctxOrBackground())
}

// RefreshCatalogEndpoint refreshes models for a specific endpoint.
func (b *Bridge) RefreshCatalogEndpoint(endpointID string) error {

	return b.catalog.RefreshEndpoint(b.ctxOrBackground(), endpointID)
}

// TestCatalogEndpoint tests connectivity for an endpoint.
func (b *Bridge) TestCatalogEndpoint(endpointID string) error {

	return b.catalog.TestEndpoint(b.ctxOrBackground(), endpointID)
}

// SaveCatalogRole creates or updates a role.
func (b *Bridge) SaveCatalogRole(role catalog.RoleSummary) (catalog.RoleSummary, error) {

	return b.catalog.SaveRole(b.ctxOrBackground(), role)
}

// DeleteCatalogRole removes a role.
func (b *Bridge) DeleteCatalogRole(roleID string) error {

	return b.catalog.DeleteRole(b.ctxOrBackground(), roleID)
}

// AssignCatalogRole assigns a model to a role.
func (b *Bridge) AssignCatalogRole(roleID, modelEntryID, assignedBy string) (catalog.RoleAssignmentResult, error) {

	return b.catalog.AssignRole(b.ctxOrBackground(), roleID, modelEntryID, assignedBy)
}

// UnassignCatalogRole removes a role assignment.
func (b *Bridge) UnassignCatalogRole(roleID, modelEntryID string) error {

	return b.catalog.UnassignRole(b.ctxOrBackground(), roleID, modelEntryID)
}

```


--| internal/core/adapters/wails/chat_api.go

```go
// expose chat endpoints to the frontend via the bridge.
// internal/core/adapters/wails/chat_api.go
package wails

import (
	"fmt"

	"github.com/MadeByDoug/wls-chatbot/internal/features/chat/usecase"
)

// CreateConversation creates a new conversation with the given settings.
func (b *Bridge) CreateConversation(providerName, model string) (*chat.Conversation, error) {

	if b.chat == nil {
		return nil, fmt.Errorf("chat orchestrator not configured")
	}
	return b.chat.CreateConversation(providerName, model)
}

// SetActiveConversation sets the active conversation by ID.
func (b *Bridge) SetActiveConversation(id string) {

	b.chat.SetActiveConversation(id)
}

// GetActiveConversation returns the currently active conversation.
func (b *Bridge) GetActiveConversation() *chat.Conversation {

	return b.chat.GetActiveConversation()
}

// GetConversation returns a conversation by ID.
func (b *Bridge) GetConversation(id string) *chat.Conversation {

	return b.chat.GetConversation(id)
}

// ListConversations returns summaries of all conversations.
func (b *Bridge) ListConversations() []chat.ConversationSummary {

	return b.chat.ListConversations()
}

// ListDeletedConversations returns summaries of archived conversations.
func (b *Bridge) ListDeletedConversations() []chat.ConversationSummary {

	return b.chat.ListDeletedConversations()
}

// UpdateConversationModel updates the model for a conversation.
func (b *Bridge) UpdateConversationModel(conversationID, model string) bool {

	return b.chat.UpdateConversationModel(conversationID, model)
}

// UpdateConversationProvider updates the provider for a conversation.
func (b *Bridge) UpdateConversationProvider(conversationID, provider string) bool {

	return b.chat.UpdateConversationProvider(conversationID, provider)
}

// DeleteConversation moves a conversation to the recycle bin.
func (b *Bridge) DeleteConversation(id string) bool {

	return b.chat.DeleteConversation(id)
}

// RestoreConversation restores a recycled conversation.
func (b *Bridge) RestoreConversation(id string) bool {

	return b.chat.RestoreConversation(id)
}

// PurgeConversation permanently deletes a conversation.
func (b *Bridge) PurgeConversation(id string) bool {

	return b.chat.PurgeConversation(id)
}

```


--| internal/core/adapters/wails/emitter.go

```go
// emit backend events through the Wails runtime.
// internal/core/adapters/wails/emitter.go
package wails

import (
	"context"
	"sync"

	"github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	"github.com/wailsapp/wails/v2/pkg/runtime"
)

// Emitter sends backend events to the Wails frontend.
type Emitter struct {
	mu  sync.RWMutex
	ctx context.Context
}

var _ ports.Emitter = (*Emitter)(nil)

// SetContext sets the Wails context used for event emission.
func (e *Emitter) SetContext(ctx context.Context) {

	e.mu.Lock()
	e.ctx = ctx
	e.mu.Unlock()
}

// ClearContext clears the Wails context.
func (e *Emitter) ClearContext() {

	e.mu.Lock()
	e.ctx = nil
	e.mu.Unlock()
}

// EmitChatEvent sends a chat event to the frontend.
func (e *Emitter) EmitChatEvent(event ports.ChatEvent) {

	ctx := e.context()
	if ctx == nil {
		return
	}
	runtime.EventsEmit(ctx, "chat:event", event)
}

// EmitProvidersUpdated notifies the frontend that providers have changed.
func (e *Emitter) EmitProvidersUpdated() {

	ctx := e.context()
	if ctx == nil {
		return
	}
	runtime.EventsEmit(ctx, "providers:updated")
}

// EmitCatalogUpdated notifies the frontend that catalog data has changed.
func (e *Emitter) EmitCatalogUpdated() {

	ctx := e.context()
	if ctx == nil {
		return
	}
	runtime.EventsEmit(ctx, "catalog:updated")
}

// EmitToast sends a toast notification to the frontend.
func (e *Emitter) EmitToast(payload ports.ToastPayload) {

	ctx := e.context()
	if ctx == nil {
		return
	}
	runtime.EventsEmit(ctx, "toast", payload)
}

// context returns the stored Wails context.
func (e *Emitter) context() context.Context {

	e.mu.RLock()
	ctx := e.ctx
	e.mu.RUnlock()
	return ctx
}

```


--| internal/core/adapters/wails/notification_api.go

```go
// expose notification endpoints to the frontend via the bridge.
// internal/core/adapters/wails/notification_api.go
package wails

import (
	"fmt"

	"github.com/MadeByDoug/wls-chatbot/internal/features/notifications/usecase"
)

// CreateNotification persists a notification payload.
func (b *Bridge) CreateNotification(payload notifications.NotificationPayload) (*notifications.Notification, error) {

	if b.notifications == nil {
		return nil, fmt.Errorf("notifications orchestrator not configured")
	}
	return b.notifications.CreateNotification(payload)
}

// ListNotifications returns stored notifications for the workspace.
func (b *Bridge) ListNotifications() []notifications.Notification {

	if b.notifications == nil {
		return nil
	}
	return b.notifications.ListNotifications()
}

// DeleteNotification removes a notification by id.
func (b *Bridge) DeleteNotification(id int64) bool {

	if b.notifications == nil {
		return false
	}
	return b.notifications.DeleteNotification(id)
}

// ClearNotifications removes all notifications.
func (b *Bridge) ClearNotifications() bool {

	if b.notifications == nil {
		return false
	}
	return b.notifications.ClearNotifications()
}

```


--| internal/core/adapters/wails/provider_api.go

```go
// expose provider endpoints to the frontend via the bridge.
// internal/core/adapters/wails/provider_api.go
package wails

import "github.com/MadeByDoug/wls-chatbot/internal/features/settings/usecase"

// GetProviders returns all available providers with their status.
func (b *Bridge) GetProviders() []provider.Info {

	return b.providers.GetProviders()
}

// ConnectProvider connects and configures a provider with the given credentials.
func (b *Bridge) ConnectProvider(name string, credentials provider.ProviderCredentials) (provider.Info, error) {

	return b.providers.ConnectProvider(b.ctxOrBackground(), name, credentials)
}

// ConfigureProvider updates a provider's credentials without full connection flow.
func (b *Bridge) ConfigureProvider(name string, credentials provider.ProviderCredentials) error {

	return b.providers.ConfigureProvider(name, credentials)
}

// DisconnectProvider removes a provider's credentials and resets its state.
func (b *Bridge) DisconnectProvider(name string) error {

	return b.providers.DisconnectProvider(name)
}

// SetActiveProvider sets the active provider by name.
func (b *Bridge) SetActiveProvider(name string) bool {

	return b.providers.SetActiveProvider(name)
}

// TestProvider tests the connection to a provider.
func (b *Bridge) TestProvider(name string) error {

	return b.providers.TestProvider(b.ctxOrBackground(), name)
}

// RefreshProviderResources fetches the latest resources from a provider.
func (b *Bridge) RefreshProviderResources(name string) error {

	return b.providers.RefreshProviderResources(b.ctxOrBackground(), name)
}

// GetActiveProvider returns the currently active provider, if any.
func (b *Bridge) GetActiveProvider() *provider.Info {

	return b.providers.GetActiveProvider()
}

```


--| internal/core/adapters/wails/stream.go

```go
// expose chat streaming endpoints to the frontend via the bridge.
// internal/core/adapters/wails/stream.go
package wails

import (
	"github.com/MadeByDoug/wls-chatbot/internal/features/chat/usecase"
)

// SendMessage sends a user message and initiates a streaming response.
func (b *Bridge) SendMessage(conversationID, content string) (*chat.Message, error) {

	return b.chat.SendMessage(b.ctxOrBackground(), conversationID, content)
}

// StopStream cancels the currently running stream.
func (b *Bridge) StopStream() {

	b.chat.StopStream()
}

```


--| internal/core/ports/events.go

```go
// define event payloads and emitter contracts.
// internal/core/ports/events.go
package ports

import "github.com/MadeByDoug/wls-chatbot/internal/features/chat/domain"

// ChatEvent is the wrapper for all events sent to the frontend.
type ChatEvent struct {
	Type           string      `json:"type"`
	ConversationID string      `json:"conversationId"`
	MessageID      string      `json:"messageId,omitempty"`
	Timestamp      int64       `json:"ts"`
	Payload        interface{} `json:"payload,omitempty"`
}

// StreamChunkPayload is the payload for stream chunk events.
type StreamChunkPayload struct {
	BlockIndex int                   `json:"blockIndex"`
	Content    string                `json:"content"`
	IsDone     bool                  `json:"isDone"`
	Metadata   *chat.MessageMetadata `json:"metadata,omitempty"`
	Error      string                `json:"error,omitempty"`
	StatusCode int                   `json:"statusCode,omitempty"`
}

// ConversationTitlePayload carries a conversation title update.
type ConversationTitlePayload struct {
	Title string `json:"title"`
}

// ToastPayload describes a toast notification.
type ToastPayload struct {
	Type    string `json:"type,omitempty"`
	Title   string `json:"title,omitempty"`
	Message string `json:"message,omitempty"`
}

// ChatEmitter publishes chat-related events to the frontend.
type ChatEmitter interface {
	EmitChatEvent(event ChatEvent)
}

// ProviderEmitter publishes provider-related events to the frontend.
type ProviderEmitter interface {
	EmitProvidersUpdated()
}

// CatalogEmitter publishes catalog-related events to the frontend.
type CatalogEmitter interface {
	EmitCatalogUpdated()
}

// ToastEmitter publishes toast notifications to the frontend.
type ToastEmitter interface {
	EmitToast(payload ToastPayload)
}

// Emitter bundles all event emitters used by policies.
type Emitter interface {
	ChatEmitter
	ProviderEmitter
	CatalogEmitter
	ToastEmitter
}

```


--| internal/core/ports/logger.go

```go
// define structured logging contracts for core use cases.
// internal/core/ports/logger.go
package ports

// LogField represents a structured logging field.
type LogField struct {
	Key   string
	Value string
}

// Logger provides structured logging for use cases.
type Logger interface {
	// Trace logs a trace message.
	Trace(message string, fields ...LogField)
	// Debug logs a debug message.
	Debug(message string, fields ...LogField)
	// Info logs an info message.
	Info(message string, fields ...LogField)
	// Warn logs a warning message with an optional error.
	Warn(message string, err error, fields ...LogField)
	// Error logs an error message with an optional error.
	Error(message string, err error, fields ...LogField)
}

```


--| internal/features/catalog/adapters/catalogrepo/sqlite.go

```go
// sqlite.go persists model catalog, endpoints, roles, and provider metadata in SQLite.
// internal/features/catalog/adapters/catalogrepo/sqlite.go
package catalogrepo

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
)

const catalogSchema = `
CREATE TABLE IF NOT EXISTS catalog_providers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    adapter_type TEXT NOT NULL,
    trust_mode TEXT NOT NULL,
    base_url TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    last_test_at INTEGER,
    last_test_ok INTEGER CHECK (last_test_ok IN (0, 1)),
    last_error TEXT,
    last_discovery_at INTEGER
);

CREATE TABLE IF NOT EXISTS provider_inputs (
    provider_id TEXT NOT NULL,
    input_key TEXT NOT NULL,
    input_value TEXT NOT NULL,
    PRIMARY KEY (provider_id, input_key),
    FOREIGN KEY (provider_id) REFERENCES catalog_providers(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS catalog_endpoints (
    id TEXT PRIMARY KEY,
    provider_id TEXT NOT NULL,
    display_name TEXT NOT NULL,
    adapter_type TEXT NOT NULL,
    base_url TEXT NOT NULL,
    route_kind TEXT NOT NULL,
    origin_provider TEXT NOT NULL,
    origin_route_label TEXT NOT NULL,
    auth_json TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    last_test_at INTEGER,
    last_test_ok INTEGER CHECK (last_test_ok IN (0, 1)),
    last_error TEXT,
    FOREIGN KEY (provider_id) REFERENCES catalog_providers(id) ON DELETE CASCADE,
    UNIQUE (provider_id, route_kind, origin_provider, origin_route_label, base_url)
);

CREATE TABLE IF NOT EXISTS model_catalog_entries (
    id TEXT PRIMARY KEY,
    endpoint_id TEXT NOT NULL,
    model_id TEXT NOT NULL,
    display_name TEXT,
    first_seen_at INTEGER NOT NULL,
    last_seen_at INTEGER NOT NULL,
    availability_state TEXT NOT NULL,
    approved INTEGER NOT NULL CHECK (approved IN (0, 1)),
    missed_refreshes INTEGER NOT NULL,
    source TEXT NOT NULL DEFAULT 'discovered',
    metadata_json TEXT,
    FOREIGN KEY (endpoint_id) REFERENCES catalog_endpoints(id) ON DELETE CASCADE,
    UNIQUE (endpoint_id, model_id)
);

CREATE TABLE IF NOT EXISTS model_capabilities (
    model_catalog_entry_id TEXT PRIMARY KEY,
    supports_streaming INTEGER NOT NULL CHECK (supports_streaming IN (0, 1)),
    supports_tool_calling INTEGER NOT NULL CHECK (supports_tool_calling IN (0, 1)),
    supports_structured_output INTEGER NOT NULL CHECK (supports_structured_output IN (0, 1)),
    supports_vision INTEGER NOT NULL CHECK (supports_vision IN (0, 1)),
    capabilities_source TEXT NOT NULL,
    capabilities_as_of INTEGER NOT NULL,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_capabilities_input_modalities (
    model_catalog_entry_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, modality),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_capabilities_output_modalities (
    model_catalog_entry_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, modality),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_system_profile (
    model_catalog_entry_id TEXT PRIMARY KEY,
    latency_tier TEXT NOT NULL,
    cost_tier TEXT NOT NULL,
    reliability_tier TEXT NOT NULL,
    system_profile_source TEXT NOT NULL,
    system_profile_as_of INTEGER NOT NULL,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_system_tags (
    model_catalog_entry_id TEXT NOT NULL,
    tag TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, tag),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_user_addenda (
    model_catalog_entry_id TEXT PRIMARY KEY,
    notes TEXT,
    user_addenda_source TEXT NOT NULL,
    user_addenda_as_of INTEGER NOT NULL,
    latency_tier_override TEXT,
    cost_tier_override TEXT,
    reliability_tier_override TEXT,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS model_user_tags (
    model_catalog_entry_id TEXT NOT NULL,
    tag TEXT NOT NULL,
    PRIMARY KEY (model_catalog_entry_id, tag),
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS roles (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    requires_streaming INTEGER NOT NULL CHECK (requires_streaming IN (0, 1)),
    requires_tool_calling INTEGER NOT NULL CHECK (requires_tool_calling IN (0, 1)),
    requires_structured_output INTEGER NOT NULL CHECK (requires_structured_output IN (0, 1)),
    requires_vision INTEGER NOT NULL CHECK (requires_vision IN (0, 1)),
    max_cost_tier TEXT,
    max_latency_tier TEXT,
    min_reliability_tier TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS role_required_input_modalities (
    role_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (role_id, modality),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS role_required_output_modalities (
    role_id TEXT NOT NULL,
    modality TEXT NOT NULL,
    PRIMARY KEY (role_id, modality),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS role_assignments (
    role_id TEXT NOT NULL,
    model_catalog_entry_id TEXT NOT NULL,
    assigned_by TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    enabled INTEGER NOT NULL CHECK (enabled IN (0, 1)),
    PRIMARY KEY (role_id, model_catalog_entry_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (model_catalog_entry_id) REFERENCES model_catalog_entries(id) ON DELETE CASCADE
);
`

// Repository stores model catalog and role data in SQLite.
type Repository struct {
	db *sql.DB
}

// NewRepository creates a SQLite-backed model catalog repository.
func NewRepository(db *sql.DB) (*Repository, error) {

	if db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	if _, err := db.Exec(catalogSchema); err != nil {
		return nil, fmt.Errorf("catalog repo: ensure schema: %w", err)
	}
	if err := validateSchema(db); err != nil {
		return nil, err
	}

	return &Repository{db: db}, nil
}

// validateSchema ensures required columns exist for strict-schema operation.
func validateSchema(db *sql.DB) error {

	requiredColumns := []struct {
		table  string
		column string
	}{
		{table: "model_capabilities_input_modalities", column: "model_catalog_entry_id"},
		{table: "model_capabilities_input_modalities", column: "modality"},
		{table: "model_capabilities_output_modalities", column: "model_catalog_entry_id"},
		{table: "model_capabilities_output_modalities", column: "modality"},
	}

	for _, required := range requiredColumns {
		exists, err := schemaHasColumn(db, required.table, required.column)
		if err != nil {
			return err
		}
		if !exists {
			return fmt.Errorf(
				"catalog repo: incompatible schema (%s.%s missing); remove workspace database and restart",
				required.table,
				required.column,
			)
		}
	}
	return nil
}

// schemaHasColumn reports whether a table contains a specific column.
func schemaHasColumn(db *sql.DB, table, column string) (bool, error) {

	query := fmt.Sprintf("PRAGMA table_info(%s)", table)
	rows, err := db.Query(query)
	if err != nil {
		return false, fmt.Errorf("catalog repo: table info %s: %w", table, err)
	}
	defer func() { _ = rows.Close() }()

	for rows.Next() {
		var cid, notNull, primaryKey int
		var name, dataType string
		var defaultValue sql.NullString
		if err := rows.Scan(&cid, &name, &dataType, &notNull, &defaultValue, &primaryKey); err != nil {
			return false, fmt.Errorf("catalog repo: table info scan %s: %w", table, err)
		}
		if name == column {
			return true, nil
		}
	}
	if err := rows.Err(); err != nil {
		return false, fmt.Errorf("catalog repo: table info rows %s: %w", table, err)
	}
	return false, nil
}

// ProviderRecord describes a stored provider entity.
type ProviderRecord struct {
	ID              string
	Name            string
	DisplayName     string
	AdapterType     string
	TrustMode       string
	BaseURL         string
	LastTestAt      int64
	LastTestOK      bool
	LastError       string
	LastDiscoveryAt int64
}

// EndpointRecord describes a stored endpoint.
type EndpointRecord struct {
	ID               string
	ProviderID       string
	ProviderName     string
	DisplayName      string
	AdapterType      string
	BaseURL          string
	RouteKind        string
	OriginProvider   string
	OriginRouteLabel string
	AuthJSON         string
	LastTestAt       int64
	LastTestOK       bool
	LastError        string
}

// ModelEntryRecord describes a stored model catalog entry.
type ModelEntryRecord struct {
	ID                string
	EndpointID        string
	ModelID           string
	DisplayName       string
	FirstSeenAt       int64
	LastSeenAt        int64
	AvailabilityState string
	Approved          bool
	MissedRefreshes   int
	Source            string // "seed", "user", or "discovered"
	MetadataJSON      string
}

// RoleRecord describes a stored role.
type RoleRecord struct {
	ID                       string
	Name                     string
	RequiresStreaming        bool
	RequiresToolCalling      bool
	RequiresStructuredOutput bool
	RequiresVision           bool
	MaxCostTier              string
	MaxLatencyTier           string
	MinReliabilityTier       string
	RequiredInputModalities  []string
	RequiredOutputModalities []string
}

// RoleAssignmentRecord describes a role assignment.
type RoleAssignmentRecord struct {
	RoleID              string
	ModelCatalogEntryID string
	AssignedBy          string
	CreatedAt           int64
	Enabled             bool
}

// EnsureProvider upserts a provider and returns its record.
func (r *Repository) EnsureProvider(ctx context.Context, provider ProviderRecord) (ProviderRecord, error) {

	if r == nil || r.db == nil {
		return ProviderRecord{}, fmt.Errorf("catalog repo: db required")
	}

	now := time.Now().UnixMilli()
	provider.Name = strings.TrimSpace(provider.Name)
	if provider.Name == "" {
		return ProviderRecord{}, fmt.Errorf("catalog repo: provider name required")
	}

	if provider.ID == "" {
		provider.ID = newUUID()
	}

	if provider.TrustMode == "" {
		provider.TrustMode = "user_managed"
	}

	_, err := r.db.ExecContext(
		ctx,
		`INSERT INTO catalog_providers (id, name, display_name, adapter_type, trust_mode, base_url, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)
         ON CONFLICT(name) DO UPDATE SET
           display_name = excluded.display_name,
           adapter_type = excluded.adapter_type,
           trust_mode = excluded.trust_mode,
           base_url = excluded.base_url,
           updated_at = excluded.updated_at`,
		provider.ID,
		provider.Name,
		provider.DisplayName,
		provider.AdapterType,
		provider.TrustMode,
		provider.BaseURL,
		now,
		now,
	)
	if err != nil {
		return ProviderRecord{}, fmt.Errorf("catalog repo: ensure provider: %w", err)
	}

	row := r.db.QueryRowContext(ctx, `SELECT id, name, display_name, adapter_type, trust_mode, base_url, last_test_at, last_test_ok, last_error, last_discovery_at FROM catalog_providers WHERE name = ?`, provider.Name)
	var record ProviderRecord
	var lastTestAt sql.NullInt64
	var lastTestOK sql.NullInt64
	var lastError sql.NullString
	var lastDiscoveryAt sql.NullInt64
	if err := row.Scan(
		&record.ID,
		&record.Name,
		&record.DisplayName,
		&record.AdapterType,
		&record.TrustMode,
		&record.BaseURL,
		&lastTestAt,
		&lastTestOK,
		&lastError,
		&lastDiscoveryAt,
	); err != nil {
		return ProviderRecord{}, fmt.Errorf("catalog repo: ensure provider load: %w", err)
	}
	if lastTestAt.Valid {
		record.LastTestAt = lastTestAt.Int64
	}
	record.LastTestOK = lastTestOK.Valid && lastTestOK.Int64 == 1
	if lastError.Valid {
		record.LastError = lastError.String
	}
	if lastDiscoveryAt.Valid {
		record.LastDiscoveryAt = lastDiscoveryAt.Int64
	}
	return record, nil
}

// GetProviderByName loads a provider by name.
func (r *Repository) GetProviderByName(ctx context.Context, name string) (ProviderRecord, error) {

	if r == nil || r.db == nil {
		return ProviderRecord{}, fmt.Errorf("catalog repo: db required")
	}

	row := r.db.QueryRowContext(ctx, `SELECT id, name, display_name, adapter_type, trust_mode, base_url, last_test_at, last_test_ok, last_error, last_discovery_at FROM catalog_providers WHERE name = ?`, name)
	var record ProviderRecord
	var lastTestAt sql.NullInt64
	var lastTestOK sql.NullInt64
	var lastError sql.NullString
	var lastDiscoveryAt sql.NullInt64
	err := row.Scan(
		&record.ID,
		&record.Name,
		&record.DisplayName,
		&record.AdapterType,
		&record.TrustMode,
		&record.BaseURL,
		&lastTestAt,
		&lastTestOK,
		&lastError,
		&lastDiscoveryAt,
	)
	if errors.Is(err, sql.ErrNoRows) {
		return ProviderRecord{}, nil
	}
	if err != nil {
		return ProviderRecord{}, fmt.Errorf("catalog repo: get provider: %w", err)
	}
	if lastTestAt.Valid {
		record.LastTestAt = lastTestAt.Int64
	}
	record.LastTestOK = lastTestOK.Valid && lastTestOK.Int64 == 1
	if lastError.Valid {
		record.LastError = lastError.String
	}
	if lastDiscoveryAt.Valid {
		record.LastDiscoveryAt = lastDiscoveryAt.Int64
	}
	return record, nil
}

// ListProviders returns all providers in the catalog.
func (r *Repository) ListProviders(ctx context.Context) ([]ProviderRecord, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	rows, err := r.db.QueryContext(ctx, `SELECT id, name, display_name, adapter_type, trust_mode, base_url, last_test_at, last_test_ok, last_error, last_discovery_at FROM catalog_providers ORDER BY display_name`)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: list providers: %w", err)
	}
	defer func() { _ = rows.Close() }()

	var providers []ProviderRecord
	for rows.Next() {
		var record ProviderRecord
		var lastTestAt sql.NullInt64
		var lastTestOK sql.NullInt64
		var lastError sql.NullString
		var lastDiscoveryAt sql.NullInt64
		if err := rows.Scan(
			&record.ID,
			&record.Name,
			&record.DisplayName,
			&record.AdapterType,
			&record.TrustMode,
			&record.BaseURL,
			&lastTestAt,
			&lastTestOK,
			&lastError,
			&lastDiscoveryAt,
		); err != nil {
			return nil, fmt.Errorf("catalog repo: list providers scan: %w", err)
		}
		if lastTestAt.Valid {
			record.LastTestAt = lastTestAt.Int64
		}
		record.LastTestOK = lastTestOK.Valid && lastTestOK.Int64 == 1
		if lastError.Valid {
			record.LastError = lastError.String
		}
		if lastDiscoveryAt.Valid {
			record.LastDiscoveryAt = lastDiscoveryAt.Int64
		}
		providers = append(providers, record)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: list providers rows: %w", err)
	}
	return providers, nil
}

// UpdateProviderStatus records provider health or discovery metadata.
func (r *Repository) UpdateProviderStatus(ctx context.Context, providerID string, lastTestAt int64, lastTestOK bool, lastError string, lastDiscoveryAt int64) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if providerID == "" {
		return fmt.Errorf("catalog repo: provider id required")
	}

	_, err := r.db.ExecContext(
		ctx,
		`UPDATE catalog_providers
         SET last_test_at = ?, last_test_ok = ?, last_error = ?, last_discovery_at = ?, updated_at = ?
         WHERE id = ?`,
		nullIfZero(lastTestAt),
		boolToInt(lastTestOK),
		strings.TrimSpace(lastError),
		nullIfZero(lastDiscoveryAt),
		time.Now().UnixMilli(),
		providerID,
	)
	if err != nil {
		return fmt.Errorf("catalog repo: update provider status: %w", err)
	}
	return nil
}

// SaveProviderInputs stores non-secret provider inputs.
func (r *Repository) SaveProviderInputs(providerName string, inputs map[string]string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}

	ctx := context.Background()
	provider, err := r.GetProviderByName(ctx, providerName)
	if err != nil {
		return err
	}
	if provider.ID == "" {
		return fmt.Errorf("catalog repo: provider not found: %s", providerName)
	}

	return withTx(r.db, func(tx *sql.Tx) error {
		if _, err := tx.Exec(`DELETE FROM provider_inputs WHERE provider_id = ?`, provider.ID); err != nil {
			return fmt.Errorf("catalog repo: clear inputs: %w", err)
		}
		for key, value := range inputs {
			trimmedKey := strings.TrimSpace(key)
			trimmedValue := strings.TrimSpace(value)
			if trimmedKey == "" || trimmedValue == "" {
				continue
			}
			if _, err := tx.Exec(`INSERT INTO provider_inputs (provider_id, input_key, input_value) VALUES (?, ?, ?)`, provider.ID, trimmedKey, trimmedValue); err != nil {
				return fmt.Errorf("catalog repo: insert input: %w", err)
			}
		}
		return nil
	})
}

// LoadProviderInputs returns stored provider inputs.
func (r *Repository) LoadProviderInputs(providerName string) (map[string]string, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	ctx := context.Background()
	provider, err := r.GetProviderByName(ctx, providerName)
	if err != nil {
		return nil, err
	}
	if provider.ID == "" {
		return nil, fmt.Errorf("catalog repo: provider not found: %s", providerName)
	}

	rows, err := r.db.Query(`SELECT input_key, input_value FROM provider_inputs WHERE provider_id = ?`, provider.ID)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: load inputs: %w", err)
	}
	defer func() { _ = rows.Close() }()

	inputs := make(map[string]string)
	for rows.Next() {
		var key, value string
		if err := rows.Scan(&key, &value); err != nil {
			return nil, fmt.Errorf("catalog repo: load inputs scan: %w", err)
		}
		inputs[key] = value
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: load inputs rows: %w", err)
	}
	if len(inputs) == 0 {
		return nil, nil
	}
	return inputs, nil
}

// UpsertEndpoint inserts or updates an endpoint record.
func (r *Repository) UpsertEndpoint(ctx context.Context, endpoint EndpointRecord) (EndpointRecord, error) {

	if r == nil || r.db == nil {
		return EndpointRecord{}, fmt.Errorf("catalog repo: db required")
	}
	if endpoint.ProviderID == "" {
		return EndpointRecord{}, fmt.Errorf("catalog repo: provider id required")
	}
	if endpoint.DisplayName == "" {
		return EndpointRecord{}, fmt.Errorf("catalog repo: endpoint display name required")
	}
	if endpoint.AdapterType == "" {
		return EndpointRecord{}, fmt.Errorf("catalog repo: endpoint adapter type required")
	}

	now := time.Now().UnixMilli()
	if endpoint.ID == "" {
		endpoint.ID = newUUID()
	}
	endpoint.RouteKind = normalizeOptional(endpoint.RouteKind)
	endpoint.OriginProvider = normalizeOptional(endpoint.OriginProvider)
	endpoint.OriginRouteLabel = normalizeOptional(endpoint.OriginRouteLabel)

	_, err := r.db.ExecContext(
		ctx,
		`INSERT INTO catalog_endpoints (id, provider_id, display_name, adapter_type, base_url, route_kind, origin_provider, origin_route_label, auth_json, created_at, updated_at, last_test_at, last_test_ok, last_error)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
         ON CONFLICT(provider_id, route_kind, origin_provider, origin_route_label, base_url) DO UPDATE SET
           display_name = excluded.display_name,
           adapter_type = excluded.adapter_type,
           auth_json = excluded.auth_json,
           last_test_at = excluded.last_test_at,
           last_test_ok = excluded.last_test_ok,
           last_error = excluded.last_error,
           updated_at = excluded.updated_at`,
		endpoint.ID,
		endpoint.ProviderID,
		endpoint.DisplayName,
		endpoint.AdapterType,
		endpoint.BaseURL,
		endpoint.RouteKind,
		endpoint.OriginProvider,
		endpoint.OriginRouteLabel,
		endpoint.AuthJSON,
		now,
		now,
		nullIfZero(endpoint.LastTestAt),
		boolToInt(endpoint.LastTestOK),
		strings.TrimSpace(endpoint.LastError),
	)
	if err != nil {
		return EndpointRecord{}, fmt.Errorf("catalog repo: upsert endpoint: %w", err)
	}

	row := r.db.QueryRowContext(ctx, `SELECT id, provider_id, display_name, adapter_type, base_url, route_kind, origin_provider, origin_route_label, auth_json, last_test_at, last_test_ok, last_error FROM catalog_endpoints WHERE provider_id = ? AND route_kind = ? AND origin_provider = ? AND origin_route_label = ? AND base_url = ?`, endpoint.ProviderID, endpoint.RouteKind, endpoint.OriginProvider, endpoint.OriginRouteLabel, endpoint.BaseURL)
	var record EndpointRecord
	var lastTestAt sql.NullInt64
	var lastTestOK sql.NullInt64
	var lastError sql.NullString
	if err := row.Scan(
		&record.ID,
		&record.ProviderID,
		&record.DisplayName,
		&record.AdapterType,
		&record.BaseURL,
		&record.RouteKind,
		&record.OriginProvider,
		&record.OriginRouteLabel,
		&record.AuthJSON,
		&lastTestAt,
		&lastTestOK,
		&lastError,
	); err != nil {
		return EndpointRecord{}, fmt.Errorf("catalog repo: load endpoint: %w", err)
	}
	if lastTestAt.Valid {
		record.LastTestAt = lastTestAt.Int64
	}
	record.LastTestOK = lastTestOK.Valid && lastTestOK.Int64 == 1
	if lastError.Valid {
		record.LastError = lastError.String
	}
	return record, nil
}

// UpdateEndpointStatus updates endpoint health metadata.
func (r *Repository) UpdateEndpointStatus(ctx context.Context, endpointID string, lastTestAt int64, lastTestOK bool, lastError string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if endpointID == "" {
		return fmt.Errorf("catalog repo: endpoint id required")
	}

	_, err := r.db.ExecContext(
		ctx,
		`UPDATE catalog_endpoints SET last_test_at = ?, last_test_ok = ?, last_error = ?, updated_at = ? WHERE id = ?`,
		nullIfZero(lastTestAt),
		boolToInt(lastTestOK),
		strings.TrimSpace(lastError),
		time.Now().UnixMilli(),
		endpointID,
	)
	if err != nil {
		return fmt.Errorf("catalog repo: update endpoint status: %w", err)
	}
	return nil
}

// ListEndpoints returns all endpoints for UI display.
func (r *Repository) ListEndpoints(ctx context.Context) ([]EndpointRecord, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	rows, err := r.db.QueryContext(ctx, `SELECT e.id, e.provider_id, p.name, e.display_name, e.adapter_type, e.base_url, e.route_kind, e.origin_provider, e.origin_route_label, e.auth_json, e.last_test_at, e.last_test_ok, e.last_error FROM catalog_endpoints e JOIN catalog_providers p ON p.id = e.provider_id ORDER BY p.display_name, e.display_name`)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: list endpoints: %w", err)
	}
	defer func() { _ = rows.Close() }()

	var endpoints []EndpointRecord
	for rows.Next() {
		var record EndpointRecord
		var lastTestAt sql.NullInt64
		var lastTestOK sql.NullInt64
		var lastError sql.NullString
		if err := rows.Scan(
			&record.ID,
			&record.ProviderID,
			&record.ProviderName,
			&record.DisplayName,
			&record.AdapterType,
			&record.BaseURL,
			&record.RouteKind,
			&record.OriginProvider,
			&record.OriginRouteLabel,
			&record.AuthJSON,
			&lastTestAt,
			&lastTestOK,
			&lastError,
		); err != nil {
			return nil, fmt.Errorf("catalog repo: list endpoints scan: %w", err)
		}
		if lastTestAt.Valid {
			record.LastTestAt = lastTestAt.Int64
		}
		record.LastTestOK = lastTestOK.Valid && lastTestOK.Int64 == 1
		if lastError.Valid {
			record.LastError = lastError.String
		}
		endpoints = append(endpoints, record)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: list endpoints rows: %w", err)
	}
	return endpoints, nil
}

// GetEndpoint loads an endpoint by ID.
func (r *Repository) GetEndpoint(ctx context.Context, endpointID string) (EndpointRecord, error) {

	if r == nil || r.db == nil {
		return EndpointRecord{}, fmt.Errorf("catalog repo: db required")
	}

	row := r.db.QueryRowContext(ctx, `SELECT e.id, e.provider_id, p.name, e.display_name, e.adapter_type, e.base_url, e.route_kind, e.origin_provider, e.origin_route_label, e.auth_json, e.last_test_at, e.last_test_ok, e.last_error FROM catalog_endpoints e JOIN catalog_providers p ON p.id = e.provider_id WHERE e.id = ?`, endpointID)
	var record EndpointRecord
	var lastTestAt sql.NullInt64
	var lastTestOK sql.NullInt64
	var lastError sql.NullString
	err := row.Scan(
		&record.ID,
		&record.ProviderID,
		&record.ProviderName,
		&record.DisplayName,
		&record.AdapterType,
		&record.BaseURL,
		&record.RouteKind,
		&record.OriginProvider,
		&record.OriginRouteLabel,
		&record.AuthJSON,
		&lastTestAt,
		&lastTestOK,
		&lastError,
	)
	if errors.Is(err, sql.ErrNoRows) {
		return EndpointRecord{}, nil
	}
	if err != nil {
		return EndpointRecord{}, fmt.Errorf("catalog repo: get endpoint: %w", err)
	}
	if lastTestAt.Valid {
		record.LastTestAt = lastTestAt.Int64
	}
	record.LastTestOK = lastTestOK.Valid && lastTestOK.Int64 == 1
	if lastError.Valid {
		record.LastError = lastError.String
	}
	return record, nil
}

// ListModelEntriesByEndpoint returns model catalog entries for an endpoint.
func (r *Repository) ListModelEntriesByEndpoint(ctx context.Context, endpointID string) ([]ModelEntryRecord, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	rows, err := r.db.QueryContext(ctx, `SELECT id, endpoint_id, model_id, display_name, first_seen_at, last_seen_at, availability_state, approved, missed_refreshes, metadata_json FROM model_catalog_entries WHERE endpoint_id = ?`, endpointID)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: list models: %w", err)
	}
	defer func() { _ = rows.Close() }()

	var entries []ModelEntryRecord
	for rows.Next() {
		var entry ModelEntryRecord
		var approved int
		if err := rows.Scan(
			&entry.ID,
			&entry.EndpointID,
			&entry.ModelID,
			&entry.DisplayName,
			&entry.FirstSeenAt,
			&entry.LastSeenAt,
			&entry.AvailabilityState,
			&approved,
			&entry.MissedRefreshes,
			&entry.MetadataJSON,
		); err != nil {
			return nil, fmt.Errorf("catalog repo: list models scan: %w", err)
		}
		entry.Approved = approved == 1
		entries = append(entries, entry)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: list models rows: %w", err)
	}
	return entries, nil
}

// UpsertModelEntry inserts or updates a catalog entry.
func (r *Repository) UpsertModelEntry(ctx context.Context, entry ModelEntryRecord) (ModelEntryRecord, error) {

	if r == nil || r.db == nil {
		return ModelEntryRecord{}, fmt.Errorf("catalog repo: db required")
	}
	if entry.EndpointID == "" || entry.ModelID == "" {
		return ModelEntryRecord{}, fmt.Errorf("catalog repo: model entry requires endpoint and model id")
	}

	if entry.ID == "" {
		entry.ID = newUUID()
	}
	if entry.Source == "" {
		entry.Source = "discovered"
	}

	_, err := r.db.ExecContext(
		ctx,
		`INSERT INTO model_catalog_entries (id, endpoint_id, model_id, display_name, first_seen_at, last_seen_at, availability_state, approved, missed_refreshes, source, metadata_json)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
         ON CONFLICT(endpoint_id, model_id) DO UPDATE SET
           display_name = excluded.display_name,
           last_seen_at = excluded.last_seen_at,
           availability_state = excluded.availability_state,
           approved = excluded.approved,
           missed_refreshes = excluded.missed_refreshes,
           metadata_json = excluded.metadata_json`,
		entry.ID,
		entry.EndpointID,
		entry.ModelID,
		entry.DisplayName,
		entry.FirstSeenAt,
		entry.LastSeenAt,
		entry.AvailabilityState,
		boolToInt(entry.Approved),
		entry.MissedRefreshes,
		entry.Source,
		entry.MetadataJSON,
	)
	if err != nil {
		return ModelEntryRecord{}, fmt.Errorf("catalog repo: upsert model: %w", err)
	}

	row := r.db.QueryRowContext(ctx, `SELECT id, endpoint_id, model_id, display_name, first_seen_at, last_seen_at, availability_state, approved, missed_refreshes, source, metadata_json FROM model_catalog_entries WHERE endpoint_id = ? AND model_id = ?`, entry.EndpointID, entry.ModelID)
	var updated ModelEntryRecord
	var approved int
	if err := row.Scan(
		&updated.ID,
		&updated.EndpointID,
		&updated.ModelID,
		&updated.DisplayName,
		&updated.FirstSeenAt,
		&updated.LastSeenAt,
		&updated.AvailabilityState,
		&approved,
		&updated.MissedRefreshes,
		&updated.Source,
		&updated.MetadataJSON,
	); err != nil {
		return ModelEntryRecord{}, fmt.Errorf("catalog repo: load model: %w", err)
	}
	updated.Approved = approved == 1
	return updated, nil
}

// UpdateMissingModelEntry updates a missing model entry.
func (r *Repository) UpdateMissingModelEntry(ctx context.Context, entryID string, missedRefreshes int, availabilityState string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if entryID == "" {
		return fmt.Errorf("catalog repo: model entry id required")
	}

	_, err := r.db.ExecContext(
		ctx,
		`UPDATE model_catalog_entries SET missed_refreshes = ?, availability_state = ? WHERE id = ?`,
		missedRefreshes,
		availabilityState,
		entryID,
	)
	if err != nil {
		return fmt.Errorf("catalog repo: update missing model: %w", err)
	}
	return nil
}

// EnsureModelCapabilities inserts model capabilities if missing.
func (r *Repository) EnsureModelCapabilities(ctx context.Context, entryID string, supportsStreaming, supportsToolCalling, supportsStructuredOutput, supportsVision bool, inputModalities, outputModalities []string, source string, asOf int64) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if entryID == "" {
		return fmt.Errorf("catalog repo: model entry id required")
	}

	return withTx(r.db, func(tx *sql.Tx) error {
		_, err := tx.Exec(
			`INSERT INTO model_capabilities (model_catalog_entry_id, supports_streaming, supports_tool_calling, supports_structured_output, supports_vision, capabilities_source, capabilities_as_of)
             VALUES (?, ?, ?, ?, ?, ?, ?)
             ON CONFLICT(model_catalog_entry_id) DO UPDATE SET
               supports_streaming = excluded.supports_streaming,
               supports_tool_calling = excluded.supports_tool_calling,
               supports_structured_output = excluded.supports_structured_output,
               supports_vision = excluded.supports_vision,
               capabilities_source = excluded.capabilities_source,
               capabilities_as_of = excluded.capabilities_as_of`,
			entryID,
			boolToInt(supportsStreaming),
			boolToInt(supportsToolCalling),
			boolToInt(supportsStructuredOutput),
			boolToInt(supportsVision),
			source,
			asOf,
		)
		if err != nil {
			return fmt.Errorf("catalog repo: insert capabilities: %w", err)
		}

		if err := replaceModalities(tx, "model_capabilities_input_modalities", entryID, inputModalities); err != nil {
			return err
		}
		if err := replaceModalities(tx, "model_capabilities_output_modalities", entryID, outputModalities); err != nil {
			return err
		}
		return nil
	})
}

// EnsureModelSystemProfile inserts system profile defaults if missing.
func (r *Repository) EnsureModelSystemProfile(ctx context.Context, entryID string, latencyTier, costTier, reliabilityTier, source string, asOf int64) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if entryID == "" {
		return fmt.Errorf("catalog repo: model entry id required")
	}

	_, err := r.db.ExecContext(
		ctx,
		`INSERT INTO model_system_profile (model_catalog_entry_id, latency_tier, cost_tier, reliability_tier, system_profile_source, system_profile_as_of)
         VALUES (?, ?, ?, ?, ?, ?)
         ON CONFLICT(model_catalog_entry_id) DO UPDATE SET
           latency_tier = excluded.latency_tier,
           cost_tier = excluded.cost_tier,
           reliability_tier = excluded.reliability_tier,
           system_profile_source = excluded.system_profile_source,
           system_profile_as_of = excluded.system_profile_as_of`,
		entryID,
		latencyTier,
		costTier,
		reliabilityTier,
		source,
		asOf,
	)
	if err != nil {
		return fmt.Errorf("catalog repo: insert system profile: %w", err)
	}
	return nil
}

// EnsureModelUserAddenda inserts a user addenda row if missing.
func (r *Repository) EnsureModelUserAddenda(ctx context.Context, entryID string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if entryID == "" {
		return fmt.Errorf("catalog repo: model entry id required")
	}

	now := time.Now().UnixMilli()
	_, err := r.db.ExecContext(
		ctx,
		`INSERT INTO model_user_addenda (model_catalog_entry_id, notes, user_addenda_source, user_addenda_as_of)
         VALUES (?, ?, ?, ?)
         ON CONFLICT(model_catalog_entry_id) DO NOTHING`,
		entryID,
		"",
		"manual",
		now,
	)
	if err != nil {
		return fmt.Errorf("catalog repo: insert user addenda: %w", err)
	}
	return nil
}

// ModelCapabilitiesRecord holds model capabilities and modalities.
type ModelCapabilitiesRecord struct {
	SupportsStreaming        bool
	SupportsToolCalling      bool
	SupportsStructuredOutput bool
	SupportsVision           bool
	InputModalities          []string
	OutputModalities         []string
}

// GetModelEffectiveCostTier returns the resolved cost tier for a model entry.
func (r *Repository) GetModelEffectiveCostTier(ctx context.Context, entryID string) (string, error) {

	if r == nil || r.db == nil {
		return "", fmt.Errorf("catalog repo: db required")
	}
	if strings.TrimSpace(entryID) == "" {
		return "", fmt.Errorf("catalog repo: model entry id required")
	}

	var costTier sql.NullString
	err := r.db.QueryRowContext(
		ctx,
		`SELECT COALESCE(ua.cost_tier_override, sp.cost_tier)
         FROM model_system_profile sp
         LEFT JOIN model_user_addenda ua ON ua.model_catalog_entry_id = sp.model_catalog_entry_id
         WHERE sp.model_catalog_entry_id = ?`,
		entryID,
	).Scan(&costTier)
	if errors.Is(err, sql.ErrNoRows) {
		return "", nil
	}
	if err != nil {
		return "", fmt.Errorf("catalog repo: get model cost tier: %w", err)
	}
	if costTier.Valid {
		return costTier.String, nil
	}
	return "", nil
}

// GetModelCapabilities loads model capabilities for a model entry.
func (r *Repository) GetModelCapabilities(ctx context.Context, entryID string) (ModelCapabilitiesRecord, error) {

	if r == nil || r.db == nil {
		return ModelCapabilitiesRecord{}, fmt.Errorf("catalog repo: db required")
	}

	var record ModelCapabilitiesRecord
	var supportsStreaming, supportsToolCalling, supportsStructuredOutput, supportsVision int
	err := r.db.QueryRowContext(
		ctx,
		`SELECT supports_streaming, supports_tool_calling, supports_structured_output, supports_vision FROM model_capabilities WHERE model_catalog_entry_id = ?`,
		entryID,
	).Scan(&supportsStreaming, &supportsToolCalling, &supportsStructuredOutput, &supportsVision)
	if errors.Is(err, sql.ErrNoRows) {
		return ModelCapabilitiesRecord{}, nil
	}
	if err != nil {
		return ModelCapabilitiesRecord{}, fmt.Errorf("catalog repo: get capabilities: %w", err)
	}
	record.SupportsStreaming = supportsStreaming == 1
	record.SupportsToolCalling = supportsToolCalling == 1
	record.SupportsStructuredOutput = supportsStructuredOutput == 1
	record.SupportsVision = supportsVision == 1

	inputModalities, err := loadModalities(r.db, "model_capabilities_input_modalities", "model_catalog_entry_id", entryID)
	if err != nil {
		return ModelCapabilitiesRecord{}, err
	}
	outputModalities, err := loadModalities(r.db, "model_capabilities_output_modalities", "model_catalog_entry_id", entryID)
	if err != nil {
		return ModelCapabilitiesRecord{}, err
	}
	record.InputModalities = inputModalities
	record.OutputModalities = outputModalities
	return record, nil
}

// ModelSummaryRecord returns model entries with capabilities.
type ModelSummaryRecord struct {
	ModelEntryRecord
	ModelCapabilitiesRecord
	CostTier string
}

// ListModelSummaries returns models with intrinsic metadata.
func (r *Repository) ListModelSummaries(ctx context.Context) ([]ModelSummaryRecord, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	rows, err := r.db.QueryContext(ctx, `SELECT id, endpoint_id, model_id, display_name, first_seen_at, last_seen_at, availability_state, approved, missed_refreshes, source, metadata_json FROM model_catalog_entries ORDER BY model_id`)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: list model summaries: %w", err)
	}

	entries := make([]ModelEntryRecord, 0)
	for rows.Next() {
		var entry ModelEntryRecord
		var approved int
		if err := rows.Scan(
			&entry.ID,
			&entry.EndpointID,
			&entry.ModelID,
			&entry.DisplayName,
			&entry.FirstSeenAt,
			&entry.LastSeenAt,
			&entry.AvailabilityState,
			&approved,
			&entry.MissedRefreshes,
			&entry.Source,
			&entry.MetadataJSON,
		); err != nil {
			_ = rows.Close()
			return nil, fmt.Errorf("catalog repo: list model summaries scan: %w", err)
		}
		entry.Approved = approved == 1
		entries = append(entries, entry)
	}
	if err := rows.Err(); err != nil {
		_ = rows.Close()
		return nil, fmt.Errorf("catalog repo: list model summaries rows: %w", err)
	}

	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("catalog repo: list model summaries close: %w", err)
	}

	// Load per-model details only after closing the result cursor to avoid blocking
	// when the datastore is configured with a single open SQLite connection.
	summaries := make([]ModelSummaryRecord, 0, len(entries))
	for _, entry := range entries {
		capabilities, err := r.GetModelCapabilities(ctx, entry.ID)
		if err != nil {
			return nil, err
		}
		costTier, err := r.GetModelEffectiveCostTier(ctx, entry.ID)
		if err != nil {
			return nil, err
		}
		summaries = append(summaries, ModelSummaryRecord{
			ModelEntryRecord:        entry,
			ModelCapabilitiesRecord: capabilities,
			CostTier:                costTier,
		})
	}

	return summaries, nil
}

// UpsertRole inserts or updates a role.
func (r *Repository) UpsertRole(ctx context.Context, role RoleRecord) (RoleRecord, error) {

	if r == nil || r.db == nil {
		return RoleRecord{}, fmt.Errorf("catalog repo: db required")
	}
	role.Name = strings.TrimSpace(role.Name)
	if role.Name == "" {
		return RoleRecord{}, fmt.Errorf("catalog repo: role name required")
	}
	now := time.Now().UnixMilli()
	if role.ID == "" {
		role.ID = newUUID()
	}

	_, err := r.db.ExecContext(
		ctx,
		`INSERT INTO roles (id, name, requires_streaming, requires_tool_calling, requires_structured_output, requires_vision, max_cost_tier, max_latency_tier, min_reliability_tier, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
         ON CONFLICT(name) DO UPDATE SET
           requires_streaming = excluded.requires_streaming,
           requires_tool_calling = excluded.requires_tool_calling,
           requires_structured_output = excluded.requires_structured_output,
           requires_vision = excluded.requires_vision,
           max_cost_tier = excluded.max_cost_tier,
           max_latency_tier = excluded.max_latency_tier,
           min_reliability_tier = excluded.min_reliability_tier,
           updated_at = excluded.updated_at`,
		role.ID,
		role.Name,
		boolToInt(role.RequiresStreaming),
		boolToInt(role.RequiresToolCalling),
		boolToInt(role.RequiresStructuredOutput),
		boolToInt(role.RequiresVision),
		normalizeOptional(role.MaxCostTier),
		normalizeOptional(role.MaxLatencyTier),
		normalizeOptional(role.MinReliabilityTier),
		now,
		now,
	)
	if err != nil {
		return RoleRecord{}, fmt.Errorf("catalog repo: upsert role: %w", err)
	}

	record, err := r.GetRoleByName(ctx, role.Name)
	if err != nil {
		return RoleRecord{}, err
	}
	if err := r.replaceRoleModalities(ctx, record.ID, role.RequiredInputModalities, role.RequiredOutputModalities); err != nil {
		return RoleRecord{}, err
	}
	record.RequiredInputModalities = role.RequiredInputModalities
	record.RequiredOutputModalities = role.RequiredOutputModalities
	return record, nil
}

// GetRoleByID loads a role by ID.
func (r *Repository) GetRoleByID(ctx context.Context, roleID string) (RoleRecord, error) {

	if r == nil || r.db == nil {
		return RoleRecord{}, fmt.Errorf("catalog repo: db required")
	}

	row := r.db.QueryRowContext(ctx, `SELECT id, name, requires_streaming, requires_tool_calling, requires_structured_output, requires_vision, max_cost_tier, max_latency_tier, min_reliability_tier FROM roles WHERE id = ?`, roleID)
	record, err := scanRole(row)
	if errors.Is(err, sql.ErrNoRows) {
		return RoleRecord{}, nil
	}
	if err != nil {
		return RoleRecord{}, err
	}

	inputModalities, err := loadModalities(r.db, "role_required_input_modalities", "role_id", record.ID)
	if err != nil {
		return RoleRecord{}, err
	}
	outputModalities, err := loadModalities(r.db, "role_required_output_modalities", "role_id", record.ID)
	if err != nil {
		return RoleRecord{}, err
	}
	record.RequiredInputModalities = inputModalities
	record.RequiredOutputModalities = outputModalities
	return record, nil
}

// GetRoleByName loads a role by name.
func (r *Repository) GetRoleByName(ctx context.Context, name string) (RoleRecord, error) {

	if r == nil || r.db == nil {
		return RoleRecord{}, fmt.Errorf("catalog repo: db required")
	}

	row := r.db.QueryRowContext(ctx, `SELECT id, name, requires_streaming, requires_tool_calling, requires_structured_output, requires_vision, max_cost_tier, max_latency_tier, min_reliability_tier FROM roles WHERE name = ?`, name)
	record, err := scanRole(row)
	if errors.Is(err, sql.ErrNoRows) {
		return RoleRecord{}, nil
	}
	if err != nil {
		return RoleRecord{}, err
	}

	inputModalities, err := loadModalities(r.db, "role_required_input_modalities", "role_id", record.ID)
	if err != nil {
		return RoleRecord{}, err
	}
	outputModalities, err := loadModalities(r.db, "role_required_output_modalities", "role_id", record.ID)
	if err != nil {
		return RoleRecord{}, err
	}
	record.RequiredInputModalities = inputModalities
	record.RequiredOutputModalities = outputModalities
	return record, nil
}

// ListRoles returns all roles.
func (r *Repository) ListRoles(ctx context.Context) ([]RoleRecord, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	rows, err := r.db.QueryContext(ctx, `SELECT id, name, requires_streaming, requires_tool_calling, requires_structured_output, requires_vision, max_cost_tier, max_latency_tier, min_reliability_tier FROM roles ORDER BY name`)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: list roles: %w", err)
	}
	defer func() { _ = rows.Close() }()

	var roles []RoleRecord
	for rows.Next() {
		record, err := scanRole(rows)
		if err != nil {
			return nil, err
		}
		inputModalities, err := loadModalities(r.db, "role_required_input_modalities", "role_id", record.ID)
		if err != nil {
			return nil, err
		}
		outputModalities, err := loadModalities(r.db, "role_required_output_modalities", "role_id", record.ID)
		if err != nil {
			return nil, err
		}
		record.RequiredInputModalities = inputModalities
		record.RequiredOutputModalities = outputModalities
		roles = append(roles, record)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: list roles rows: %w", err)
	}
	return roles, nil
}

// DeleteRole removes a role by ID.
func (r *Repository) DeleteRole(ctx context.Context, roleID string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if roleID == "" {
		return fmt.Errorf("catalog repo: role id required")
	}

	_, err := r.db.ExecContext(ctx, `DELETE FROM roles WHERE id = ?`, roleID)
	if err != nil {
		return fmt.Errorf("catalog repo: delete role: %w", err)
	}
	return nil
}

// ListRoleAssignments returns all role assignments.
func (r *Repository) ListRoleAssignments(ctx context.Context) ([]RoleAssignmentRecord, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	rows, err := r.db.QueryContext(ctx, `SELECT role_id, model_catalog_entry_id, assigned_by, created_at, enabled FROM role_assignments`)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: list role assignments: %w", err)
	}
	defer func() { _ = rows.Close() }()

	var assignments []RoleAssignmentRecord
	for rows.Next() {
		var record RoleAssignmentRecord
		var enabled int
		if err := rows.Scan(&record.RoleID, &record.ModelCatalogEntryID, &record.AssignedBy, &record.CreatedAt, &enabled); err != nil {
			return nil, fmt.Errorf("catalog repo: list role assignments scan: %w", err)
		}
		record.Enabled = enabled == 1
		assignments = append(assignments, record)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: list role assignments rows: %w", err)
	}
	return assignments, nil
}

// UpsertRoleAssignment inserts or updates a role assignment.
func (r *Repository) UpsertRoleAssignment(ctx context.Context, assignment RoleAssignmentRecord) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if assignment.RoleID == "" || assignment.ModelCatalogEntryID == "" {
		return fmt.Errorf("catalog repo: role assignment requires role and model")
	}

	_, err := r.db.ExecContext(
		ctx,
		`INSERT INTO role_assignments (role_id, model_catalog_entry_id, assigned_by, created_at, enabled)
         VALUES (?, ?, ?, ?, ?)
         ON CONFLICT(role_id, model_catalog_entry_id) DO UPDATE SET
           assigned_by = excluded.assigned_by,
           created_at = excluded.created_at,
           enabled = excluded.enabled`,
		assignment.RoleID,
		assignment.ModelCatalogEntryID,
		assignment.AssignedBy,
		assignment.CreatedAt,
		boolToInt(assignment.Enabled),
	)
	if err != nil {
		return fmt.Errorf("catalog repo: upsert role assignment: %w", err)
	}
	return nil
}

// DeleteRoleAssignment removes a role assignment.
func (r *Repository) DeleteRoleAssignment(ctx context.Context, roleID, modelEntryID string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("catalog repo: db required")
	}
	if roleID == "" || modelEntryID == "" {
		return fmt.Errorf("catalog repo: role assignment requires role and model")
	}

	_, err := r.db.ExecContext(ctx, `DELETE FROM role_assignments WHERE role_id = ? AND model_catalog_entry_id = ?`, roleID, modelEntryID)
	if err != nil {
		return fmt.Errorf("catalog repo: delete role assignment: %w", err)
	}
	return nil
}

// ListModelLabels returns model labels for assignment display.
func (r *Repository) ListModelLabels(ctx context.Context) (map[string]string, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("catalog repo: db required")
	}

	rows, err := r.db.QueryContext(ctx, `SELECT m.id, m.model_id, e.display_name, p.display_name FROM model_catalog_entries m JOIN catalog_endpoints e ON e.id = m.endpoint_id JOIN catalog_providers p ON p.id = e.provider_id`)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: list model labels: %w", err)
	}
	defer func() { _ = rows.Close() }()

	labels := make(map[string]string)
	for rows.Next() {
		var id, modelID, endpointName, providerName string
		if err := rows.Scan(&id, &modelID, &endpointName, &providerName); err != nil {
			return nil, fmt.Errorf("catalog repo: list model labels scan: %w", err)
		}
		labels[id] = fmt.Sprintf("%s  %s  %s", providerName, endpointName, modelID)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: list model labels rows: %w", err)
	}
	return labels, nil
}

// MarshalAuthJSON creates a JSON string for endpoint auth hints.
func MarshalAuthJSON(data map[string]interface{}) (string, error) {

	if data == nil {
		return "", nil
	}
	payload, err := json.Marshal(data)
	if err != nil {
		return "", fmt.Errorf("catalog repo: encode auth json: %w", err)
	}
	return string(payload), nil
}

func newUUID() string {

	id, err := uuid.NewV7()
	if err != nil {
		return uuid.New().String()
	}
	return id.String()
}

func boolToInt(value bool) int {

	if value {
		return 1
	}
	return 0
}

func nullIfZero(value int64) interface{} {

	if value == 0 {
		return nil
	}
	return value
}

func normalizeOptional(value string) string {

	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return ""
	}
	return trimmed
}

func withTx(db *sql.DB, fn func(*sql.Tx) error) error {

	tx, err := db.Begin()
	if err != nil {
		return err
	}
	if err := fn(tx); err != nil {
		_ = tx.Rollback()
		return err
	}
	return tx.Commit()
}

func replaceModalities(tx *sql.Tx, table string, entryID string, modalities []string) error {

	if _, err := tx.Exec(fmt.Sprintf("DELETE FROM %s WHERE model_catalog_entry_id = ?", table), entryID); err != nil {
		return fmt.Errorf("catalog repo: clear modalities: %w", err)
	}
	for _, modality := range modalities {
		trimmed := strings.TrimSpace(modality)
		if trimmed == "" {
			continue
		}
		if _, err := tx.Exec(fmt.Sprintf("INSERT INTO %s (model_catalog_entry_id, modality) VALUES (?, ?)", table), entryID, trimmed); err != nil {
			return fmt.Errorf("catalog repo: insert modality: %w", err)
		}
	}
	return nil
}

func loadModalities(db *sql.DB, table, keyColumn, keyValue string) ([]string, error) {

	rows, err := db.Query(fmt.Sprintf("SELECT modality FROM %s WHERE %s = ? ORDER BY modality", table, keyColumn), keyValue)
	if err != nil {
		return nil, fmt.Errorf("catalog repo: load modalities: %w", err)
	}
	defer func() { _ = rows.Close() }()

	modalities := []string{}
	for rows.Next() {
		var modality string
		if err := rows.Scan(&modality); err != nil {
			return nil, fmt.Errorf("catalog repo: load modalities scan: %w", err)
		}
		modalities = append(modalities, modality)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("catalog repo: load modalities rows: %w", err)
	}
	if len(modalities) == 0 {
		return nil, nil
	}
	return modalities, nil
}

func scanRole(scanner interface{ Scan(...interface{}) error }) (RoleRecord, error) {

	var record RoleRecord
	var requiresStreaming, requiresToolCalling, requiresStructuredOutput, requiresVision int
	err := scanner.Scan(
		&record.ID,
		&record.Name,
		&requiresStreaming,
		&requiresToolCalling,
		&requiresStructuredOutput,
		&requiresVision,
		&record.MaxCostTier,
		&record.MaxLatencyTier,
		&record.MinReliabilityTier,
	)
	if err != nil {
		return RoleRecord{}, err
	}
	record.RequiresStreaming = requiresStreaming == 1
	record.RequiresToolCalling = requiresToolCalling == 1
	record.RequiresStructuredOutput = requiresStructuredOutput == 1
	record.RequiresVision = requiresVision == 1
	return record, nil
}

func (r *Repository) replaceRoleModalities(ctx context.Context, roleID string, inputModalities, outputModalities []string) error {

	return withTx(r.db, func(tx *sql.Tx) error {
		if _, err := tx.Exec(`DELETE FROM role_required_input_modalities WHERE role_id = ?`, roleID); err != nil {
			return fmt.Errorf("catalog repo: clear input modalities: %w", err)
		}
		for _, modality := range inputModalities {
			trimmed := strings.TrimSpace(modality)
			if trimmed == "" {
				continue
			}
			if _, err := tx.Exec(`INSERT INTO role_required_input_modalities (role_id, modality) VALUES (?, ?)`, roleID, trimmed); err != nil {
				return fmt.Errorf("catalog repo: insert input modality: %w", err)
			}
		}

		if _, err := tx.Exec(`DELETE FROM role_required_output_modalities WHERE role_id = ?`, roleID); err != nil {
			return fmt.Errorf("catalog repo: clear output modalities: %w", err)
		}
		for _, modality := range outputModalities {
			trimmed := strings.TrimSpace(modality)
			if trimmed == "" {
				continue
			}
			if _, err := tx.Exec(`INSERT INTO role_required_output_modalities (role_id, modality) VALUES (?, ?)`, roleID, trimmed); err != nil {
				return fmt.Errorf("catalog repo: insert output modality: %w", err)
			}
		}
		return nil
	})
}

```


--| internal/features/catalog/usecase/errors.go

```go
// errors.go defines structured error codes for catalog operations.
// internal/features/catalog/usecase/errors.go
package catalog

import "fmt"

// ErrorCode identifies catalog failure types.
type ErrorCode string

const (
	ErrorCodeProviderAuthFailure ErrorCode = "provider_auth_failure"
	ErrorCodeDiscoveryFailure    ErrorCode = "discovery_failure"
	ErrorCodeRoleValidation      ErrorCode = "role_validation_failure"
)

// CatalogError wraps a failure with a structured error code.
type CatalogError struct {
	Code    ErrorCode
	Message string
	Cause   error
}

// Error formats the catalog error for display.
func (e *CatalogError) Error() string {

	if e == nil {
		return ""
	}
	if e.Message == "" && e.Cause != nil {
		return e.Cause.Error()
	}
	if e.Message != "" {
		return e.Message
	}
	return fmt.Sprintf("catalog error: %s", e.Code)
}

// Unwrap returns the underlying cause.
func (e *CatalogError) Unwrap() error {

	if e == nil {
		return nil
	}
	return e.Cause
}

```


--| internal/features/catalog/usecase/orchestration.go

```go
// orchestration.go exposes catalog workflows for the UI.
// internal/features/catalog/usecase/orchestration.go
package catalog

import (
	"context"
	"fmt"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
)

// Orchestrator coordinates catalog interactions.
type Orchestrator struct {
	service *Service
	emitter coreports.Emitter
}

// NewOrchestrator creates a catalog orchestrator.
func NewOrchestrator(service *Service, emitter coreports.Emitter) *Orchestrator {

	return &Orchestrator{service: service, emitter: emitter}
}

// RefreshAll refreshes models for all endpoints.
func (o *Orchestrator) RefreshAll(ctx context.Context) error {

	if err := o.requireService(); err != nil {
		return err
	}
	return o.service.RefreshAll(ctx)
}

// GetOverview returns the catalog overview.
func (o *Orchestrator) GetOverview(ctx context.Context) (CatalogOverview, error) {

	if err := o.requireService(); err != nil {
		return CatalogOverview{}, err
	}
	return o.service.GetOverview(ctx)
}

// RefreshEndpoint refreshes models for a single endpoint.
func (o *Orchestrator) RefreshEndpoint(ctx context.Context, endpointID string) error {

	if err := o.requireService(); err != nil {
		return err
	}
	err := o.service.RefreshEndpoint(ctx, endpointID)
	if err == nil {
		o.emitCatalogUpdated()
	}
	return err
}

// TestEndpoint tests connectivity for a single endpoint.
func (o *Orchestrator) TestEndpoint(ctx context.Context, endpointID string) error {

	if err := o.requireService(); err != nil {
		return err
	}
	err := o.service.TestEndpoint(ctx, endpointID)
	if err == nil {
		o.emitCatalogUpdated()
	}
	return err
}

// SaveRole creates or updates a role.
func (o *Orchestrator) SaveRole(ctx context.Context, role RoleSummary) (RoleSummary, error) {

	if err := o.requireService(); err != nil {
		return RoleSummary{}, err
	}
	saved, err := o.service.SaveRole(ctx, role)
	if err == nil {
		o.emitCatalogUpdated()
	}
	return saved, err
}

// DeleteRole removes a role.
func (o *Orchestrator) DeleteRole(ctx context.Context, roleID string) error {

	if err := o.requireService(); err != nil {
		return err
	}
	err := o.service.DeleteRole(ctx, roleID)
	if err == nil {
		o.emitCatalogUpdated()
	}
	return err
}

// AssignRole assigns a model to a role.
func (o *Orchestrator) AssignRole(ctx context.Context, roleID, modelEntryID, assignedBy string) (RoleAssignmentResult, error) {

	if err := o.requireService(); err != nil {
		return RoleAssignmentResult{}, err
	}
	result, err := o.service.AssignRole(ctx, roleID, modelEntryID, assignedBy)
	if err == nil {
		o.emitCatalogUpdated()
	}
	return result, err
}

// UnassignRole removes a role assignment.
func (o *Orchestrator) UnassignRole(ctx context.Context, roleID, modelEntryID string) error {

	if err := o.requireService(); err != nil {
		return err
	}
	err := o.service.UnassignRole(ctx, roleID, modelEntryID)
	if err == nil {
		o.emitCatalogUpdated()
	}
	return err
}

func (o *Orchestrator) emitCatalogUpdated() {

	if o.emitter == nil {
		return
	}
	o.emitter.EmitCatalogUpdated()
}

// requireService validates orchestrator dependencies before use.
func (o *Orchestrator) requireService() error {

	if o == nil || o.service == nil {
		return fmt.Errorf("catalog service not configured")
	}
	return nil
}

```


--| internal/features/catalog/usecase/service.go

```go
// service.go coordinates model catalog discovery, endpoints, and roles.
// internal/features/catalog/usecase/service.go
package catalog

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"strings"
	"time"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	"github.com/MadeByDoug/wls-chatbot/internal/features/catalog/adapters/catalogrepo"
	"github.com/MadeByDoug/wls-chatbot/internal/features/settings/config"
	providerusecase "github.com/MadeByDoug/wls-chatbot/internal/features/settings/usecase"
)

// ProviderService describes provider operations required by the catalog.
type ProviderService interface {
	List() []providerusecase.Info
	RefreshResources(ctx context.Context, name string) error
	GetResources(name string) []providerusecase.Model
	TestConnection(ctx context.Context, name string) error
}

// Service manages catalog discovery and role assignments.
type Service struct {
	repo      *catalogrepo.Repository
	providers ProviderService
	cfg       config.AppConfig
	logger    coreports.Logger
}

// defaultRoleRecords defines app-provided role contracts seeded into the catalog.
var defaultRoleRecords = []catalogrepo.RoleRecord{
	{
		Name:                    "text_summarization",
		RequiredInputModalities: []string{"text"},
		RequiredOutputModalities: []string{"text"},
	},
	{
		Name:                    "video_transcription",
		RequiredInputModalities: []string{"video"},
		RequiredOutputModalities: []string{"text"},
	},
	{
		Name:                    "audio_transcription",
		RequiredInputModalities: []string{"audio"},
		RequiredOutputModalities: []string{"text"},
	},
}

// NewService creates a catalog service with required dependencies.
func NewService(repo *catalogrepo.Repository, providers ProviderService, cfg config.AppConfig, logger coreports.Logger) *Service {

	return &Service{
		repo:      repo,
		providers: providers,
		cfg:       cfg,
		logger:    logger,
	}
}

// RefreshAll refreshes models for all configured endpoints.
func (s *Service) RefreshAll(ctx context.Context) error {

	if s == nil {
		return fmt.Errorf("catalog service: missing dependencies")
	}
	if err := s.ensureDefaultRoles(ctx); err != nil {
		return err
	}

	providerInfos := s.indexProviders()
	refreshErrors := make([]error, 0)
	for _, providerConfig := range s.cfg.Providers {
		info := providerInfos[providerConfig.Name]
		if err := s.refreshProvider(ctx, providerConfig, info); err != nil {
			s.logWarn("Catalog refresh provider failed", err, coreports.LogField{Key: "provider", Value: providerConfig.Name})
			refreshErrors = append(refreshErrors, fmt.Errorf("%s: %w", providerConfig.Name, err))
		}
	}
	if len(refreshErrors) > 0 {
		return fmt.Errorf("catalog refresh failed for %d provider(s): %w", len(refreshErrors), errors.Join(refreshErrors...))
	}
	return nil
}

// RefreshEndpoint refreshes models for the endpoint's provider.
func (s *Service) RefreshEndpoint(ctx context.Context, endpointID string) error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("catalog service: repo required")
	}

	endpoint, err := s.repo.GetEndpoint(ctx, endpointID)
	if err != nil {
		return err
	}
	if endpoint.ID == "" {
		return fmt.Errorf("catalog service: endpoint not found")
	}

	providerConfig, ok := s.findProviderConfig(endpoint.ProviderName)
	if !ok {
		return fmt.Errorf("catalog service: provider not found for endpoint")
	}
	providerInfos := s.indexProviders()
	info := providerInfos[providerConfig.Name]
	return s.refreshProvider(ctx, providerConfig, info)
}

// TestEndpoint performs a connectivity test for the endpoint's provider.
func (s *Service) TestEndpoint(ctx context.Context, endpointID string) error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("catalog service: repo required")
	}

	endpoint, err := s.repo.GetEndpoint(ctx, endpointID)
	if err != nil {
		return err
	}
	if endpoint.ID == "" {
		return fmt.Errorf("catalog service: endpoint not found")
	}

	if err := s.providers.TestConnection(ctx, endpoint.ProviderName); err != nil {
		if statusErr := s.repo.UpdateEndpointStatus(ctx, endpointID, time.Now().UnixMilli(), false, err.Error()); statusErr != nil {
			s.logWarn("Catalog endpoint status update failed", statusErr, coreports.LogField{Key: "endpoint", Value: endpointID})
		}
		return &CatalogError{Code: ErrorCodeProviderAuthFailure, Message: err.Error(), Cause: err}
	}
	if statusErr := s.repo.UpdateEndpointStatus(ctx, endpointID, time.Now().UnixMilli(), true, ""); statusErr != nil {
		s.logWarn("Catalog endpoint status update failed", statusErr, coreports.LogField{Key: "endpoint", Value: endpointID})
	}
	return nil
}

// GetOverview returns catalog providers, endpoints, and roles.
func (s *Service) GetOverview(ctx context.Context) (CatalogOverview, error) {

	if s == nil || s.repo == nil {
		return CatalogOverview{}, fmt.Errorf("catalog service: repo required")
	}
	if err := s.ensureDefaultRoles(ctx); err != nil {
		return CatalogOverview{}, err
	}
	if err := s.ensureConnectedProviderCatalog(ctx); err != nil {
		return CatalogOverview{}, err
	}

	providers, err := s.repo.ListProviders(ctx)
	if err != nil {
		return CatalogOverview{}, err
	}
	endpoints, err := s.repo.ListEndpoints(ctx)
	if err != nil {
		return CatalogOverview{}, err
	}
	models, err := s.repo.ListModelSummaries(ctx)
	if err != nil {
		return CatalogOverview{}, err
	}
	roles, err := s.repo.ListRoles(ctx)
	if err != nil {
		return CatalogOverview{}, err
	}
	assignments, err := s.repo.ListRoleAssignments(ctx)
	if err != nil {
		return CatalogOverview{}, err
	}
	modelLabels, err := s.repo.ListModelLabels(ctx)
	if err != nil {
		return CatalogOverview{}, err
	}

	modelByEndpoint := make(map[string][]ModelSummary)
	for _, model := range models {
		modelByEndpoint[model.EndpointID] = append(modelByEndpoint[model.EndpointID], mapModelSummary(model))
	}
	for endpointID := range modelByEndpoint {
		sort.Slice(modelByEndpoint[endpointID], func(i, j int) bool {
			return modelByEndpoint[endpointID][i].ModelID < modelByEndpoint[endpointID][j].ModelID
		})
	}

	providerMap := make(map[string]catalogrepo.ProviderRecord)
	for _, provider := range providers {
		providerMap[provider.ID] = provider
	}

	endpointSummaries := make([]EndpointSummary, 0, len(endpoints))
	for _, endpoint := range endpoints {
		provider := providerMap[endpoint.ProviderID]
		endpointSummaries = append(endpointSummaries, EndpointSummary{
			ID:                  endpoint.ID,
			ProviderID:          endpoint.ProviderID,
			ProviderName:        endpoint.ProviderName,
			ProviderDisplayName: provider.DisplayName,
			DisplayName:         endpoint.DisplayName,
			AdapterType:         endpoint.AdapterType,
			BaseURL:             endpoint.BaseURL,
			RouteKind:           endpoint.RouteKind,
			OriginProvider:      endpoint.OriginProvider,
			OriginRouteLabel:    endpoint.OriginRouteLabel,
			LastTestAt:          endpoint.LastTestAt,
			LastTestOK:          endpoint.LastTestOK,
			LastError:           endpoint.LastError,
			Models:              modelByEndpoint[endpoint.ID],
		})
	}

	roleAssignments := make(map[string][]RoleAssignmentSummary)
	for _, assignment := range assignments {
		roleAssignments[assignment.RoleID] = append(roleAssignments[assignment.RoleID], RoleAssignmentSummary{
			RoleID:              assignment.RoleID,
			ModelCatalogEntryID: assignment.ModelCatalogEntryID,
			ModelLabel:          modelLabels[assignment.ModelCatalogEntryID],
			AssignedBy:          assignment.AssignedBy,
			CreatedAt:           assignment.CreatedAt,
			Enabled:             assignment.Enabled,
		})
	}

	roleSummaries := make([]RoleSummary, 0, len(roles))
	for _, role := range roles {
		roleSummaries = append(roleSummaries, RoleSummary{
			ID:   role.ID,
			Name: role.Name,
			Requirements: RoleRequirements{
				RequiredInputModalities:  role.RequiredInputModalities,
				RequiredOutputModalities: role.RequiredOutputModalities,
				RequiresStreaming:        role.RequiresStreaming,
				RequiresToolCalling:      role.RequiresToolCalling,
				RequiresStructuredOutput: role.RequiresStructuredOutput,
				RequiresVision:           role.RequiresVision,
			},
			Constraints: RoleConstraints{
				MaxCostTier:        role.MaxCostTier,
				MaxLatencyTier:     role.MaxLatencyTier,
				MinReliabilityTier: role.MinReliabilityTier,
			},
			Assignments: roleAssignments[role.ID],
		})
	}

	providerSummaries := make([]ProviderSummary, 0, len(providers))
	for _, provider := range providers {
		providerSummaries = append(providerSummaries, ProviderSummary{
			ID:              provider.ID,
			Name:            provider.Name,
			DisplayName:     provider.DisplayName,
			AdapterType:     provider.AdapterType,
			TrustMode:       provider.TrustMode,
			BaseURL:         provider.BaseURL,
			LastTestAt:      provider.LastTestAt,
			LastTestOK:      provider.LastTestOK,
			LastError:       provider.LastError,
			LastDiscoveryAt: provider.LastDiscoveryAt,
		})
	}

	return CatalogOverview{
		Providers: providerSummaries,
		Endpoints: endpointSummaries,
		Roles:     roleSummaries,
	}, nil
}

// ensureConnectedProviderCatalog backfills catalog endpoints for connected providers.
func (s *Service) ensureConnectedProviderCatalog(ctx context.Context) error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("catalog service: repo required")
	}

	endpoints, err := s.repo.ListEndpoints(ctx)
	if err != nil {
		return err
	}

	hasEndpointByProvider := make(map[string]struct{}, len(endpoints))
	for _, endpoint := range endpoints {
		hasEndpointByProvider[endpoint.ProviderName] = struct{}{}
	}

	providerInfos := s.indexProviders()
	for _, providerConfig := range s.cfg.Providers {
		info := providerInfos[providerConfig.Name]
		if !info.IsConnected {
			continue
		}
		if _, exists := hasEndpointByProvider[providerConfig.Name]; exists {
			continue
		}

		if err := s.refreshProvider(ctx, providerConfig, info); err != nil {
			s.logWarn("Catalog connected provider bootstrap failed", err, coreports.LogField{Key: "provider", Value: providerConfig.Name})
			continue
		}
		hasEndpointByProvider[providerConfig.Name] = struct{}{}
	}

	return nil
}

// SaveRole creates or updates a role definition.
func (s *Service) SaveRole(ctx context.Context, summary RoleSummary) (RoleSummary, error) {

	if s == nil || s.repo == nil {
		return RoleSummary{}, fmt.Errorf("catalog service: repo required")
	}

	record, err := s.repo.UpsertRole(ctx, catalogrepo.RoleRecord{
		ID:                       summary.ID,
		Name:                     summary.Name,
		RequiresStreaming:        summary.Requirements.RequiresStreaming,
		RequiresToolCalling:      summary.Requirements.RequiresToolCalling,
		RequiresStructuredOutput: summary.Requirements.RequiresStructuredOutput,
		RequiresVision:           summary.Requirements.RequiresVision,
		MaxCostTier:              summary.Constraints.MaxCostTier,
		MaxLatencyTier:           summary.Constraints.MaxLatencyTier,
		MinReliabilityTier:       summary.Constraints.MinReliabilityTier,
		RequiredInputModalities:  summary.Requirements.RequiredInputModalities,
		RequiredOutputModalities: summary.Requirements.RequiredOutputModalities,
	})
	if err != nil {
		return RoleSummary{}, err
	}

	return RoleSummary{
		ID:   record.ID,
		Name: record.Name,
		Requirements: RoleRequirements{
			RequiredInputModalities:  record.RequiredInputModalities,
			RequiredOutputModalities: record.RequiredOutputModalities,
			RequiresStreaming:        record.RequiresStreaming,
			RequiresToolCalling:      record.RequiresToolCalling,
			RequiresStructuredOutput: record.RequiresStructuredOutput,
			RequiresVision:           record.RequiresVision,
		},
		Constraints: RoleConstraints{
			MaxCostTier:        record.MaxCostTier,
			MaxLatencyTier:     record.MaxLatencyTier,
			MinReliabilityTier: record.MinReliabilityTier,
		},
	}, nil
}

// DeleteRole removes a role.
func (s *Service) DeleteRole(ctx context.Context, roleID string) error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("catalog service: repo required")
	}
	return s.repo.DeleteRole(ctx, roleID)
}

// AssignRole assigns a model to a role with validation.
func (s *Service) AssignRole(ctx context.Context, roleID, modelEntryID, assignedBy string) (RoleAssignmentResult, error) {

	if s == nil || s.repo == nil {
		return RoleAssignmentResult{}, fmt.Errorf("catalog service: repo required")
	}

	role, err := s.repo.GetRoleByID(ctx, roleID)
	if err != nil {
		return RoleAssignmentResult{}, err
	}
	if role.ID == "" {
		return RoleAssignmentResult{}, fmt.Errorf("catalog service: role not found")
	}

	capabilities, err := s.repo.GetModelCapabilities(ctx, modelEntryID)
	if err != nil {
		return RoleAssignmentResult{}, err
	}
	if capabilities.InputModalities == nil && capabilities.OutputModalities == nil {
		return RoleAssignmentResult{}, fmt.Errorf("catalog service: model capabilities missing")
	}

	missingModalities := diffModalities(role.RequiredInputModalities, capabilities.InputModalities)
	missingModalities = append(missingModalities, diffModalities(role.RequiredOutputModalities, capabilities.OutputModalities)...)

	missingFeatures := []string{}
	if role.RequiresStreaming && !capabilities.SupportsStreaming {
		missingFeatures = append(missingFeatures, "streaming")
	}
	if role.RequiresToolCalling && !capabilities.SupportsToolCalling {
		missingFeatures = append(missingFeatures, "tool_calling")
	}
	if role.RequiresStructuredOutput && !capabilities.SupportsStructuredOutput {
		missingFeatures = append(missingFeatures, "structured_output")
	}
	if role.RequiresVision && !capabilities.SupportsVision {
		missingFeatures = append(missingFeatures, "vision")
	}

	result := RoleAssignmentResult{MissingModalities: missingModalities, MissingFeatures: missingFeatures}
	if len(missingModalities) > 0 || len(missingFeatures) > 0 {
		message := "model does not satisfy role requirements"
		if len(missingModalities) > 0 || len(missingFeatures) > 0 {
			messageParts := []string{}
			if len(missingModalities) > 0 {
				messageParts = append(messageParts, fmt.Sprintf("missing modalities: %s", strings.Join(missingModalities, ", ")))
			}
			if len(missingFeatures) > 0 {
				messageParts = append(messageParts, fmt.Sprintf("missing features: %s", strings.Join(missingFeatures, ", ")))
			}
			message = fmt.Sprintf("%s (%s)", message, strings.Join(messageParts, "; "))
		}
		return result, &CatalogError{Code: ErrorCodeRoleValidation, Message: message}
	}

	if strings.TrimSpace(assignedBy) == "" {
		assignedBy = "user"
	}
	err = s.repo.UpsertRoleAssignment(ctx, catalogrepo.RoleAssignmentRecord{
		RoleID:              roleID,
		ModelCatalogEntryID: modelEntryID,
		AssignedBy:          assignedBy,
		CreatedAt:           time.Now().UnixMilli(),
		Enabled:             true,
	})
	if err != nil {
		return RoleAssignmentResult{}, err
	}
	return result, nil
}

// UnassignRole removes an assignment.
func (s *Service) UnassignRole(ctx context.Context, roleID, modelEntryID string) error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("catalog service: repo required")
	}
	return s.repo.DeleteRoleAssignment(ctx, roleID, modelEntryID)
}

func (s *Service) refreshProvider(ctx context.Context, providerConfig config.ProviderConfig, info providerusecase.Info) error {

	if s.repo == nil {
		return fmt.Errorf("catalog service: repo required")
	}

	record, err := s.repo.EnsureProvider(ctx, catalogrepo.ProviderRecord{
		Name:        providerConfig.Name,
		DisplayName: providerConfig.DisplayName,
		AdapterType: providerConfig.Type,
		TrustMode:   "user_managed",
		BaseURL:     providerConfig.BaseURL,
	})
	if err != nil {
		return err
	}

	if !info.IsConnected {
		return nil
	}

	if err := s.providers.RefreshResources(ctx, providerConfig.Name); err != nil {
		if statusErr := s.repo.UpdateProviderStatus(ctx, record.ID, time.Now().UnixMilli(), false, err.Error(), record.LastDiscoveryAt); statusErr != nil {
			s.logWarn("Catalog provider status update failed", statusErr, coreports.LogField{Key: "provider", Value: record.Name})
		}
		return &CatalogError{Code: ErrorCodeDiscoveryFailure, Message: err.Error(), Cause: err}
	}

	resources := s.providers.GetResources(providerConfig.Name)
	endpoints := s.buildEndpoints(providerConfig, info, resources, record)

	for _, endpoint := range endpoints {
		if err := s.syncEndpointModels(ctx, endpoint, resources); err != nil {
			s.logWarn("Catalog sync endpoint failed", err, coreports.LogField{Key: "endpoint", Value: endpoint.ID})
		}
	}

	if statusErr := s.repo.UpdateProviderStatus(ctx, record.ID, time.Now().UnixMilli(), true, "", time.Now().UnixMilli()); statusErr != nil {
		s.logWarn("Catalog provider status update failed", statusErr, coreports.LogField{Key: "provider", Value: record.Name})
	}
	return nil
}

func (s *Service) buildEndpoints(providerConfig config.ProviderConfig, info providerusecase.Info, resources []providerusecase.Model, provider catalogrepo.ProviderRecord) []catalogrepo.EndpointRecord {

	now := time.Now().UnixMilli()
	authJSON := s.buildEndpointAuth(info)

	endpointInputs, err := s.repo.LoadProviderInputs(providerConfig.Name)
	if err != nil {
		s.logWarn("Catalog provider inputs load failed", err, coreports.LogField{Key: "provider", Value: providerConfig.Name})
	}
	baseURL := providerConfig.BaseURL
	if providerConfig.Type == "cloudflare" {
		baseURL = resolveCloudflareBaseURL(providerConfig.BaseURL, endpointInputs)
	}

	endpoints := []catalogrepo.EndpointRecord{}
	if providerConfig.Type == "cloudflare" {
		workersModels, gatewayModels := splitCloudflareModels(resources)
		if len(workersModels) > 0 {
			endpoints = append(endpoints, catalogrepo.EndpointRecord{
				ProviderID:       provider.ID,
				ProviderName:     provider.Name,
				DisplayName:      "Workers AI",
				AdapterType:      providerConfig.Type,
				BaseURL:          baseURL,
				RouteKind:        "hosted",
				OriginProvider:   "cloudflare_workers_ai",
				OriginRouteLabel: "workers-ai",
				AuthJSON:         authJSON,
				LastTestAt:       now,
				LastTestOK:       info.Status != nil && info.Status.OK,
			})
		}
		if len(gatewayModels) > 0 {
			endpoints = append(endpoints, catalogrepo.EndpointRecord{
				ProviderID:       provider.ID,
				ProviderName:     provider.Name,
				DisplayName:      "Gateway Route",
				AdapterType:      providerConfig.Type,
				BaseURL:          baseURL,
				RouteKind:        "gateway_route",
				OriginProvider:   "other",
				OriginRouteLabel: "gateway",
				AuthJSON:         authJSON,
				LastTestAt:       now,
				LastTestOK:       info.Status != nil && info.Status.OK,
			})
		}
		return s.upsertEndpoints(endpoints)
	}

	routeKind := "direct"
	originProvider := ""
	if providerConfig.Type == "openrouter" {
		routeKind = "gateway_route"
		originProvider = "openrouter"
	}

	endpoints = append(endpoints, catalogrepo.EndpointRecord{
		ProviderID:       provider.ID,
		ProviderName:     provider.Name,
		DisplayName:      "Primary",
		AdapterType:      providerConfig.Type,
		BaseURL:          baseURL,
		RouteKind:        routeKind,
		OriginProvider:   originProvider,
		OriginRouteLabel: "",
		AuthJSON:         authJSON,
		LastTestAt:       now,
		LastTestOK:       info.Status != nil && info.Status.OK,
	})

	return s.upsertEndpoints(endpoints)
}

func (s *Service) upsertEndpoints(endpoints []catalogrepo.EndpointRecord) []catalogrepo.EndpointRecord {

	ctx := context.Background()
	results := make([]catalogrepo.EndpointRecord, 0, len(endpoints))
	for _, endpoint := range endpoints {
		record, err := s.repo.UpsertEndpoint(ctx, endpoint)
		if err != nil {
			s.logWarn("Catalog endpoint upsert failed", err, coreports.LogField{Key: "endpoint", Value: endpoint.DisplayName})
			continue
		}
		results = append(results, record)
	}
	return results
}

func (s *Service) syncEndpointModels(ctx context.Context, endpoint catalogrepo.EndpointRecord, resources []providerusecase.Model) error {

	existing, err := s.repo.ListModelEntriesByEndpoint(ctx, endpoint.ID)
	if err != nil {
		return err
	}

	existingByModel := make(map[string]catalogrepo.ModelEntryRecord, len(existing))
	for _, entry := range existing {
		existingByModel[entry.ModelID] = entry
	}

	models := resources
	if endpoint.RouteKind == "hosted" && endpoint.OriginProvider == "cloudflare_workers_ai" {
		workersModels, _ := splitCloudflareModels(resources)
		models = workersModels
	}
	if endpoint.RouteKind == "gateway_route" && endpoint.AdapterType == "cloudflare" {
		_, gatewayModels := splitCloudflareModels(resources)
		models = gatewayModels
	}

	now := time.Now().UnixMilli()
	seen := make(map[string]struct{})
	for _, model := range models {
		entry := existingByModel[model.ID]
		entry.EndpointID = endpoint.ID
		entry.ModelID = model.ID
		entry.DisplayName = model.Name
		if entry.FirstSeenAt == 0 {
			entry.FirstSeenAt = now
		}
		entry.LastSeenAt = now
		entry.AvailabilityState = "available"
		entry.Approved = true
		entry.MissedRefreshes = 0
		metadata, _ := json.Marshal(model)
		if len(metadata) > 0 {
			entry.MetadataJSON = string(metadata)
		}

		stored, err := s.repo.UpsertModelEntry(ctx, entry)
		if err != nil {
			return err
		}
		if err := s.ensureCapabilities(ctx, stored, model); err != nil {
			return err
		}
		seen[model.ID] = struct{}{}
	}

	for _, entry := range existing {
		if _, ok := seen[entry.ModelID]; ok {
			continue
		}
		missed := entry.MissedRefreshes + 1
		state := entry.AvailabilityState
		if missed >= 2 {
			state = "unknown"
		}
		if err := s.repo.UpdateMissingModelEntry(ctx, entry.ID, missed, state); err != nil {
			return err
		}
	}

	return nil
}

func (s *Service) ensureCapabilities(ctx context.Context, entry catalogrepo.ModelEntryRecord, model providerusecase.Model) error {

	inputModalities := []string{"text"}
	if model.SupportsVision {
		inputModalities = append(inputModalities, "image")
	}
	outputModalities := []string{"text"}

	if err := s.repo.EnsureModelCapabilities(
		ctx,
		entry.ID,
		model.SupportsStreaming,
		model.SupportsTools,
		false,
		model.SupportsVision,
		inputModalities,
		outputModalities,
		"declared",
		time.Now().UnixMilli(),
	); err != nil {
		return err
	}

	if err := s.repo.EnsureModelSystemProfile(
		ctx,
		entry.ID,
		"unknown",
		"unknown",
		"unknown",
		"summarized",
		time.Now().UnixMilli(),
	); err != nil {
		return err
	}

	return s.repo.EnsureModelUserAddenda(ctx, entry.ID)
}

func (s *Service) buildEndpointAuth(info providerusecase.Info) string {

	if info.CredentialFields == nil {
		return ""
	}

	fields := make([]map[string]interface{}, 0, len(info.CredentialFields))
	for _, field := range info.CredentialFields {
		fields = append(fields, map[string]interface{}{
			"name":     field.Name,
			"required": field.Required,
			"secret":   field.Secret,
		})
	}

	data := map[string]interface{}{
		"credential_fields": fields,
	}
	authJSON, err := catalogrepo.MarshalAuthJSON(data)
	if err != nil {
		return ""
	}
	return authJSON
}

func (s *Service) indexProviders() map[string]providerusecase.Info {

	infos := s.providers.List()
	index := make(map[string]providerusecase.Info, len(infos))
	for _, info := range infos {
		index[info.Name] = info
	}
	return index
}

func (s *Service) findProviderConfig(name string) (config.ProviderConfig, bool) {

	for _, providerConfig := range s.cfg.Providers {
		if providerConfig.Name == name {
			return providerConfig, true
		}
	}
	return config.ProviderConfig{}, false
}

// ensureDefaultRoles inserts app-provided roles when they are missing.
func (s *Service) ensureDefaultRoles(ctx context.Context) error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("catalog service: repo required")
	}

	for _, role := range defaultRoleRecords {
		existing, err := s.repo.GetRoleByName(ctx, role.Name)
		if err != nil {
			return err
		}
		if existing.ID != "" {
			continue
		}
		if _, err := s.repo.UpsertRole(ctx, role); err != nil {
			return err
		}
	}

	return nil
}

func resolveCloudflareBaseURL(baseURL string, inputs map[string]string) string {

	trimmed := strings.TrimSpace(baseURL)
	if trimmed != "" {
		return trimmed
	}
	accountID := strings.TrimSpace(inputs["account_id"])
	gatewayID := strings.TrimSpace(inputs["gateway_id"])
	if accountID == "" || gatewayID == "" {
		return ""
	}
	return fmt.Sprintf("https://gateway.ai.cloudflare.com/v1/%s/%s/compat", accountID, gatewayID)
}

func splitCloudflareModels(models []providerusecase.Model) ([]providerusecase.Model, []providerusecase.Model) {

	var workers []providerusecase.Model
	var gateway []providerusecase.Model
	for _, model := range models {
		if strings.HasPrefix(model.ID, "@cf/") {
			workers = append(workers, model)
		} else {
			gateway = append(gateway, model)
		}
	}
	return workers, gateway
}

func diffModalities(required, supported []string) []string {

	if len(required) == 0 {
		return nil
	}
	supportedSet := make(map[string]struct{}, len(supported))
	for _, modality := range supported {
		supportedSet[modality] = struct{}{}
	}
	var missing []string
	for _, modality := range required {
		if _, ok := supportedSet[modality]; !ok {
			missing = append(missing, modality)
		}
	}
	return missing
}

func mapModelSummary(record catalogrepo.ModelSummaryRecord) ModelSummary {

	contextWindow := parseContextWindow(record.MetadataJSON)
	costTier := strings.TrimSpace(record.CostTier)
	if costTier == "" {
		costTier = "unknown"
	}
	return ModelSummary{
		ID:                       record.ID,
		EndpointID:               record.EndpointID,
		ModelID:                  record.ModelID,
		DisplayName:              record.DisplayName,
		AvailabilityState:        record.AvailabilityState,
		ContextWindow:            contextWindow,
		CostTier:                 costTier,
		SupportsStreaming:        record.SupportsStreaming,
		SupportsToolCalling:      record.SupportsToolCalling,
		SupportsStructuredOutput: record.SupportsStructuredOutput,
		SupportsVision:           record.SupportsVision,
		InputModalities:          record.InputModalities,
		OutputModalities:         record.OutputModalities,
	}
}

// parseContextWindow extracts the context window from metadata JSON.
func parseContextWindow(metadata string) int {

	if strings.TrimSpace(metadata) == "" {
		return 0
	}
	var decoded struct {
		ContextWindow int `json:"contextWindow"`
	}
	if err := json.Unmarshal([]byte(metadata), &decoded); err != nil {
		return 0
	}
	return decoded.ContextWindow
}

func (s *Service) logWarn(message string, err error, fields ...coreports.LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Warn(message, err, fields...)
}

```


--| internal/features/catalog/usecase/types.go

```go
// types.go defines model catalog and role data transfer objects.
// internal/features/catalog/usecase/types.go
package catalog

// ProviderSummary represents provider metadata for the catalog.
type ProviderSummary struct {
	ID              string `json:"id"`
	Name            string `json:"name"`
	DisplayName     string `json:"displayName"`
	AdapterType     string `json:"adapterType"`
	TrustMode       string `json:"trustMode"`
	BaseURL         string `json:"baseUrl"`
	LastTestAt      int64  `json:"lastTestAt"`
	LastTestOK      bool   `json:"lastTestOk"`
	LastError       string `json:"lastError,omitempty"`
	LastDiscoveryAt int64  `json:"lastDiscoveryAt"`
}

// EndpointSummary represents an endpoint with its discovered models.
type EndpointSummary struct {
	ID                  string         `json:"id"`
	ProviderID          string         `json:"providerId"`
	ProviderName        string         `json:"providerName"`
	ProviderDisplayName string         `json:"providerDisplayName"`
	DisplayName         string         `json:"displayName"`
	AdapterType         string         `json:"adapterType"`
	BaseURL             string         `json:"baseUrl"`
	RouteKind           string         `json:"routeKind"`
	OriginProvider      string         `json:"originProvider"`
	OriginRouteLabel    string         `json:"originRouteLabel"`
	LastTestAt          int64          `json:"lastTestAt"`
	LastTestOK          bool           `json:"lastTestOk"`
	LastError           string         `json:"lastError,omitempty"`
	Models              []ModelSummary `json:"models"`
}

// ModelSummary describes a catalog model and intrinsic capabilities.
type ModelSummary struct {
	ID                       string   `json:"id"`
	EndpointID               string   `json:"endpointId"`
	ModelID                  string   `json:"modelId"`
	DisplayName              string   `json:"displayName"`
	AvailabilityState        string   `json:"availabilityState"`
	ContextWindow            int      `json:"contextWindow"`
	CostTier                 string   `json:"costTier"`
	SupportsStreaming        bool     `json:"supportsStreaming"`
	SupportsToolCalling      bool     `json:"supportsToolCalling"`
	SupportsStructuredOutput bool     `json:"supportsStructuredOutput"`
	SupportsVision           bool     `json:"supportsVision"`
	InputModalities          []string `json:"inputModalities"`
	OutputModalities         []string `json:"outputModalities"`
}

// RoleRequirements describes required modalities and features for a role.
type RoleRequirements struct {
	RequiredInputModalities  []string `json:"requiredInputModalities"`
	RequiredOutputModalities []string `json:"requiredOutputModalities"`
	RequiresStreaming        bool     `json:"requiresStreaming"`
	RequiresToolCalling      bool     `json:"requiresToolCalling"`
	RequiresStructuredOutput bool     `json:"requiresStructuredOutput"`
	RequiresVision           bool     `json:"requiresVision"`
}

// RoleConstraints describe optional constraints for a role.
type RoleConstraints struct {
	MaxCostTier        string `json:"maxCostTier,omitempty"`
	MaxLatencyTier     string `json:"maxLatencyTier,omitempty"`
	MinReliabilityTier string `json:"minReliabilityTier,omitempty"`
}

// RoleSummary describes a role and its assignments.
type RoleSummary struct {
	ID           string                  `json:"id"`
	Name         string                  `json:"name"`
	Requirements RoleRequirements        `json:"requirements"`
	Constraints  RoleConstraints         `json:"constraints"`
	Assignments  []RoleAssignmentSummary `json:"assignments"`
}

// RoleAssignmentSummary describes a role assignment entry.
type RoleAssignmentSummary struct {
	RoleID              string `json:"roleId"`
	ModelCatalogEntryID string `json:"modelCatalogEntryId"`
	ModelLabel          string `json:"modelLabel"`
	AssignedBy          string `json:"assignedBy"`
	CreatedAt           int64  `json:"createdAt"`
	Enabled             bool   `json:"enabled"`
}

// RoleAssignmentResult describes assignment validation errors.
type RoleAssignmentResult struct {
	MissingModalities []string `json:"missingModalities,omitempty"`
	MissingFeatures   []string `json:"missingFeatures,omitempty"`
}

// CatalogOverview combines endpoints and roles for the settings UI.
type CatalogOverview struct {
	Providers []ProviderSummary `json:"providers"`
	Endpoints []EndpointSummary `json:"endpoints"`
	Roles     []RoleSummary     `json:"roles"`
}

```


--| internal/features/chat/adapters/chatrepo/sqlite.go

```go
// sqlite.go persists chat conversations with a normalized SQLite schema.
// internal/features/chat/adapters/chatrepo/sqlite.go
package chatrepo

import (
	"database/sql"
	"errors"
	"fmt"

	chatdomain "github.com/MadeByDoug/wls-chatbot/internal/features/chat/domain"
	chatports "github.com/MadeByDoug/wls-chatbot/internal/features/chat/ports"
)

const chatSchema = `
CREATE TABLE IF NOT EXISTS chat_conversations (
	id TEXT PRIMARY KEY,
	title TEXT NOT NULL,
	provider TEXT NOT NULL,
	model TEXT NOT NULL,
	temperature REAL NOT NULL,
	max_tokens INTEGER NOT NULL,
	system_prompt TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL,
	is_archived INTEGER NOT NULL CHECK (is_archived IN (0, 1))
);

CREATE TABLE IF NOT EXISTS chat_messages (
	id TEXT PRIMARY KEY,
	conversation_id TEXT NOT NULL,
	role TEXT NOT NULL,
	timestamp INTEGER NOT NULL,
	is_streaming INTEGER NOT NULL CHECK (is_streaming IN (0, 1)),
	provider TEXT,
	model TEXT,
	tokens_in INTEGER,
	tokens_out INTEGER,
	tokens_total INTEGER,
	latency_ms INTEGER,
	finish_reason TEXT,
	status_code INTEGER,
	error_message TEXT,
	FOREIGN KEY (conversation_id) REFERENCES chat_conversations(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_chat_messages_conversation_ts
ON chat_messages (conversation_id, timestamp DESC);

CREATE TABLE IF NOT EXISTS chat_message_blocks (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	message_id TEXT NOT NULL,
	block_index INTEGER NOT NULL,
	block_type TEXT NOT NULL,
	content TEXT NOT NULL,
	language TEXT,
	is_collapsed INTEGER NOT NULL CHECK (is_collapsed IN (0, 1)),
	artifact_id TEXT,
	artifact_name TEXT,
	artifact_type TEXT,
	artifact_content TEXT,
	artifact_language TEXT,
	artifact_version INTEGER,
	artifact_created_at INTEGER,
	artifact_updated_at INTEGER,
	action_id TEXT,
	action_tool_name TEXT,
	action_description TEXT,
	action_status TEXT,
	action_result TEXT,
	action_started_at INTEGER,
	action_completed_at INTEGER,
	FOREIGN KEY (message_id) REFERENCES chat_messages(id) ON DELETE CASCADE
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_chat_message_blocks_order
ON chat_message_blocks (message_id, block_index);
`

// Repository stores conversations in SQLite.
type Repository struct {
	db *sql.DB
}

// NewRepository creates a SQLite-backed chat repository.
func NewRepository(db *sql.DB) (*Repository, error) {

	if db == nil {
		return nil, fmt.Errorf("chat repo: db required")
	}
	if _, err := db.Exec(chatSchema); err != nil {
		return nil, fmt.Errorf("chat repo: ensure schema: %w", err)
	}

	return &Repository{db: db}, nil
}

var _ chatports.ChatRepository = (*Repository)(nil)

// Create saves a new conversation.
func (r *Repository) Create(conv *chatdomain.Conversation) error {

	if err := r.validateConversation(conv); err != nil {
		return err
	}

	return withTx(r.db, func(tx *sql.Tx) error {
		if err := insertConversation(tx, conv); err != nil {
			return err
		}
		if err := replaceMessages(tx, conv.ID, conv.Messages); err != nil {
			return err
		}
		return nil
	})
}

// Get returns a conversation by ID.
func (r *Repository) Get(id string) (*chatdomain.Conversation, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("chat repo: db required")
	}
	if id == "" {
		return nil, nil
	}

	var conv chatdomain.Conversation
	var isArchived int
	err := r.db.QueryRow(
		`SELECT id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived
		 FROM chat_conversations
		 WHERE id = ?`,
		id,
	).Scan(
		&conv.ID,
		&conv.Title,
		&conv.Settings.Provider,
		&conv.Settings.Model,
		&conv.Settings.Temperature,
		&conv.Settings.MaxTokens,
		&conv.Settings.SystemPrompt,
		&conv.CreatedAt,
		&conv.UpdatedAt,
		&isArchived,
	)
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("chat repo: get conversation: %w", err)
	}
	conv.IsArchived = isArchived == 1

	messages, err := loadMessages(r.db, conv.ID)
	if err != nil {
		return nil, err
	}
	conv.Messages = messages

	return &conv, nil
}

// List returns all conversations.
func (r *Repository) List() ([]*chatdomain.Conversation, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("chat repo: db required")
	}

	rows, err := r.db.Query(
		`SELECT id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived
		 FROM chat_conversations
		 ORDER BY updated_at DESC`,
	)
	if err != nil {
		return nil, fmt.Errorf("chat repo: list conversations: %w", err)
	}

	conversations := make([]*chatdomain.Conversation, 0)
	for rows.Next() {
		conv := &chatdomain.Conversation{}
		var isArchived int
		if err := rows.Scan(
			&conv.ID,
			&conv.Title,
			&conv.Settings.Provider,
			&conv.Settings.Model,
			&conv.Settings.Temperature,
			&conv.Settings.MaxTokens,
			&conv.Settings.SystemPrompt,
			&conv.CreatedAt,
			&conv.UpdatedAt,
			&isArchived,
		); err != nil {
			return nil, fmt.Errorf("chat repo: list scan conversation: %w", err)
		}
		conv.IsArchived = isArchived == 1
		conversations = append(conversations, conv)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chat repo: list rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("chat repo: close rows: %w", err)
	}

	for _, conv := range conversations {
		messages, err := loadMessages(r.db, conv.ID)
		if err != nil {
			return nil, err
		}
		conv.Messages = messages
	}

	return conversations, nil
}

// Update persists a conversation update.
func (r *Repository) Update(conv *chatdomain.Conversation) error {

	if err := r.validateConversation(conv); err != nil {
		return err
	}

	return withTx(r.db, func(tx *sql.Tx) error {
		if err := upsertConversation(tx, conv); err != nil {
			return err
		}
		if err := replaceMessages(tx, conv.ID, conv.Messages); err != nil {
			return err
		}
		return nil
	})
}

// Delete removes a conversation by ID.
func (r *Repository) Delete(id string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("chat repo: db required")
	}
	if id == "" {
		return nil
	}

	if _, err := r.db.Exec("DELETE FROM chat_conversations WHERE id = ?", id); err != nil {
		return fmt.Errorf("chat repo: delete: %w", err)
	}
	return nil
}

// validateConversation validates repository and conversation inputs.
func (r *Repository) validateConversation(conv *chatdomain.Conversation) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("chat repo: db required")
	}
	if conv == nil || conv.ID == "" {
		return fmt.Errorf("chat repo: conversation required")
	}
	return nil
}

// withTx executes a function in a transaction.
func withTx(db *sql.DB, fn func(tx *sql.Tx) error) (err error) {

	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("chat repo: begin tx: %w", err)
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	if err = fn(tx); err != nil {
		return err
	}
	if err = tx.Commit(); err != nil {
		return fmt.Errorf("chat repo: commit tx: %w", err)
	}

	return nil
}

// insertConversation inserts a new conversation row.
func insertConversation(tx *sql.Tx, conv *chatdomain.Conversation) error {

	_, err := tx.Exec(
		`INSERT INTO chat_conversations (id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		conv.ID,
		conv.Title,
		conv.Settings.Provider,
		conv.Settings.Model,
		conv.Settings.Temperature,
		conv.Settings.MaxTokens,
		conv.Settings.SystemPrompt,
		conv.CreatedAt,
		conv.UpdatedAt,
		boolToInt(conv.IsArchived),
	)
	if err != nil {
		return fmt.Errorf("chat repo: insert conversation: %w", err)
	}
	return nil
}

// upsertConversation inserts or updates a conversation row.
func upsertConversation(tx *sql.Tx, conv *chatdomain.Conversation) error {

	_, err := tx.Exec(
		`INSERT INTO chat_conversations (id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		  title = excluded.title,
		  provider = excluded.provider,
		  model = excluded.model,
		  temperature = excluded.temperature,
		  max_tokens = excluded.max_tokens,
		  system_prompt = excluded.system_prompt,
		  created_at = excluded.created_at,
		  updated_at = excluded.updated_at,
		  is_archived = excluded.is_archived`,
		conv.ID,
		conv.Title,
		conv.Settings.Provider,
		conv.Settings.Model,
		conv.Settings.Temperature,
		conv.Settings.MaxTokens,
		conv.Settings.SystemPrompt,
		conv.CreatedAt,
		conv.UpdatedAt,
		boolToInt(conv.IsArchived),
	)
	if err != nil {
		return fmt.Errorf("chat repo: upsert conversation: %w", err)
	}
	return nil
}

// replaceMessages rewrites all messages and blocks for a conversation.
func replaceMessages(tx *sql.Tx, conversationID string, messages []*chatdomain.Message) error {

	if _, err := tx.Exec("DELETE FROM chat_messages WHERE conversation_id = ?", conversationID); err != nil {
		return fmt.Errorf("chat repo: delete messages: %w", err)
	}

	for _, message := range messages {
		if message == nil || message.ID == "" {
			continue
		}
		messageConversationID := message.ConversationID
		if messageConversationID == "" {
			messageConversationID = conversationID
		}

		provider := sql.NullString{}
		model := sql.NullString{}
		tokensIn := sql.NullInt64{}
		tokensOut := sql.NullInt64{}
		tokensTotal := sql.NullInt64{}
		latencyMs := sql.NullInt64{}
		finishReason := sql.NullString{}
		statusCode := sql.NullInt64{}
		errorMessage := sql.NullString{}

		if message.Metadata != nil {
			provider = newNullString(message.Metadata.Provider)
			model = newNullString(message.Metadata.Model)
			tokensIn = sql.NullInt64{Int64: int64(message.Metadata.TokensIn), Valid: true}
			tokensOut = sql.NullInt64{Int64: int64(message.Metadata.TokensOut), Valid: true}
			tokensTotal = sql.NullInt64{Int64: int64(message.Metadata.TokensTotal), Valid: true}
			if !tokensTotal.Valid || tokensTotal.Int64 == 0 {
				tokensTotal = sql.NullInt64{Int64: int64(message.Metadata.TokensIn + message.Metadata.TokensOut), Valid: true}
			}
			latencyMs = sql.NullInt64{Int64: message.Metadata.LatencyMs, Valid: true}
			finishReason = newNullString(message.Metadata.FinishReason)
			statusCode = sql.NullInt64{Int64: int64(message.Metadata.StatusCode), Valid: true}
			errorMessage = newNullString(message.Metadata.ErrorMessage)
		}

		if errorText := findFirstErrorContent(message.Blocks); errorText != "" {
			errorMessage = newNullString(errorText)
		}

		if _, err := tx.Exec(
			`INSERT INTO chat_messages
			 (id, conversation_id, role, timestamp, is_streaming, provider, model, tokens_in, tokens_out, tokens_total, latency_ms, finish_reason, status_code, error_message)
			 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
			message.ID,
			messageConversationID,
			string(message.Role),
			message.Timestamp,
			boolToInt(message.IsStreaming),
			provider,
			model,
			tokensIn,
			tokensOut,
			tokensTotal,
			latencyMs,
			finishReason,
			statusCode,
			errorMessage,
		); err != nil {
			return fmt.Errorf("chat repo: insert message: %w", err)
		}

		for blockIndex, block := range message.Blocks {
			if err := insertMessageBlock(tx, message.ID, blockIndex, block); err != nil {
				return err
			}
		}
	}

	return nil
}

// insertMessageBlock inserts one block row for a message.
func insertMessageBlock(tx *sql.Tx, messageID string, blockIndex int, block chatdomain.Block) error {

	artifactID := sql.NullString{}
	artifactName := sql.NullString{}
	artifactType := sql.NullString{}
	artifactContent := sql.NullString{}
	artifactLanguage := sql.NullString{}
	artifactVersion := sql.NullInt64{}
	artifactCreatedAt := sql.NullInt64{}
	artifactUpdatedAt := sql.NullInt64{}

	if block.Artifact != nil {
		artifactID = newNullString(block.Artifact.ID)
		artifactName = newNullString(block.Artifact.Name)
		artifactType = newNullString(block.Artifact.Type)
		artifactContent = newNullString(block.Artifact.Content)
		artifactLanguage = newNullString(block.Artifact.Language)
		artifactVersion = sql.NullInt64{Int64: int64(block.Artifact.Version), Valid: true}
		artifactCreatedAt = sql.NullInt64{Int64: block.Artifact.CreatedAt, Valid: true}
		artifactUpdatedAt = sql.NullInt64{Int64: block.Artifact.UpdatedAt, Valid: true}
	}

	actionID := sql.NullString{}
	actionToolName := sql.NullString{}
	actionDescription := sql.NullString{}
	actionStatus := sql.NullString{}
	actionResult := sql.NullString{}
	actionStartedAt := sql.NullInt64{}
	actionCompletedAt := sql.NullInt64{}

	if block.Action != nil {
		actionID = newNullString(block.Action.ID)
		actionToolName = newNullString(block.Action.ToolName)
		actionDescription = newNullString(block.Action.Description)
		actionStatus = newNullString(string(block.Action.Status))
		actionResult = newNullString(block.Action.Result)
		actionStartedAt = sql.NullInt64{Int64: block.Action.StartedAt, Valid: true}
		actionCompletedAt = sql.NullInt64{Int64: block.Action.CompletedAt, Valid: true}
	}

	_, err := tx.Exec(
		`INSERT INTO chat_message_blocks
		 (message_id, block_index, block_type, content, language, is_collapsed,
		  artifact_id, artifact_name, artifact_type, artifact_content, artifact_language, artifact_version, artifact_created_at, artifact_updated_at,
		  action_id, action_tool_name, action_description, action_status, action_result, action_started_at, action_completed_at)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		messageID,
		blockIndex,
		string(block.Type),
		block.Content,
		nullableString(block.Language),
		boolToInt(block.IsCollapsed),
		artifactID,
		artifactName,
		artifactType,
		artifactContent,
		artifactLanguage,
		artifactVersion,
		artifactCreatedAt,
		artifactUpdatedAt,
		actionID,
		actionToolName,
		actionDescription,
		actionStatus,
		actionResult,
		actionStartedAt,
		actionCompletedAt,
	)
	if err != nil {
		return fmt.Errorf("chat repo: insert block: %w", err)
	}

	return nil
}

// loadMessages fetches messages and blocks for one conversation.
func loadMessages(db *sql.DB, conversationID string) ([]*chatdomain.Message, error) {

	rows, err := db.Query(
		`SELECT id, role, timestamp, is_streaming, provider, model, tokens_in, tokens_out, tokens_total, latency_ms, finish_reason, status_code, error_message
		 FROM chat_messages
		 WHERE conversation_id = ?
		 ORDER BY timestamp ASC, id ASC`,
		conversationID,
	)
	if err != nil {
		return nil, fmt.Errorf("chat repo: list messages: %w", err)
	}

	messages := make([]*chatdomain.Message, 0)
	for rows.Next() {
		msg := &chatdomain.Message{ConversationID: conversationID}
		var (
			role        string
			isStreaming int
			provider    sql.NullString
			model       sql.NullString
			tokensIn    sql.NullInt64
			tokensOut   sql.NullInt64
			tokensTotal sql.NullInt64
			latencyMs   sql.NullInt64
			finish      sql.NullString
			statusCode  sql.NullInt64
			errorText   sql.NullString
		)
		if err := rows.Scan(
			&msg.ID,
			&role,
			&msg.Timestamp,
			&isStreaming,
			&provider,
			&model,
			&tokensIn,
			&tokensOut,
			&tokensTotal,
			&latencyMs,
			&finish,
			&statusCode,
			&errorText,
		); err != nil {
			return nil, fmt.Errorf("chat repo: scan message: %w", err)
		}
		msg.Role = chatdomain.Role(role)
		msg.IsStreaming = isStreaming == 1

		meta := &chatdomain.MessageMetadata{}
		if provider.Valid {
			meta.Provider = provider.String
		}
		if model.Valid {
			meta.Model = model.String
		}
		if tokensIn.Valid {
			meta.TokensIn = int(tokensIn.Int64)
		}
		if tokensOut.Valid {
			meta.TokensOut = int(tokensOut.Int64)
		}
		if tokensTotal.Valid {
			meta.TokensTotal = int(tokensTotal.Int64)
		}
		if latencyMs.Valid {
			meta.LatencyMs = latencyMs.Int64
		}
		if finish.Valid {
			meta.FinishReason = finish.String
		}
		if statusCode.Valid {
			meta.StatusCode = int(statusCode.Int64)
		}
		if errorText.Valid {
			meta.ErrorMessage = errorText.String
		}
		if hasMetadata(meta) {
			msg.Metadata = meta
		}

		messages = append(messages, msg)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chat repo: message rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("chat repo: close message rows: %w", err)
	}

	for _, msg := range messages {
		blocks, err := loadBlocks(db, msg.ID)
		if err != nil {
			return nil, err
		}
		msg.Blocks = blocks
	}

	return messages, nil
}

// loadBlocks fetches all blocks for one message.
func loadBlocks(db *sql.DB, messageID string) ([]chatdomain.Block, error) {

	rows, err := db.Query(
		`SELECT block_type, content, language, is_collapsed,
		        artifact_id, artifact_name, artifact_type, artifact_content, artifact_language, artifact_version, artifact_created_at, artifact_updated_at,
		        action_id, action_tool_name, action_description, action_status, action_result, action_started_at, action_completed_at
		 FROM chat_message_blocks
		 WHERE message_id = ?
		 ORDER BY block_index ASC`,
		messageID,
	)
	if err != nil {
		return nil, fmt.Errorf("chat repo: list blocks: %w", err)
	}
	defer func() { _ = rows.Close() }()

	blocks := make([]chatdomain.Block, 0)
	for rows.Next() {
		var (
			blockType        string
			content          string
			language         sql.NullString
			isCollapsed      int
			artifactID       sql.NullString
			artifactName     sql.NullString
			artifactType     sql.NullString
			artifactContent  sql.NullString
			artifactLanguage sql.NullString
			artifactVersion  sql.NullInt64
			artifactCreated  sql.NullInt64
			artifactUpdated  sql.NullInt64
			actionID         sql.NullString
			actionToolName   sql.NullString
			actionDesc       sql.NullString
			actionStatus     sql.NullString
			actionResult     sql.NullString
			actionStarted    sql.NullInt64
			actionCompleted  sql.NullInt64
		)
		if err := rows.Scan(
			&blockType,
			&content,
			&language,
			&isCollapsed,
			&artifactID,
			&artifactName,
			&artifactType,
			&artifactContent,
			&artifactLanguage,
			&artifactVersion,
			&artifactCreated,
			&artifactUpdated,
			&actionID,
			&actionToolName,
			&actionDesc,
			&actionStatus,
			&actionResult,
			&actionStarted,
			&actionCompleted,
		); err != nil {
			return nil, fmt.Errorf("chat repo: scan block: %w", err)
		}

		block := chatdomain.Block{
			Type:        chatdomain.BlockType(blockType),
			Content:     content,
			Language:    nullableValue(language),
			IsCollapsed: isCollapsed == 1,
		}
		if artifactID.Valid || artifactName.Valid || artifactType.Valid || artifactContent.Valid {
			block.Artifact = &chatdomain.Artifact{
				ID:        nullableValue(artifactID),
				Name:      nullableValue(artifactName),
				Type:      nullableValue(artifactType),
				Content:   nullableValue(artifactContent),
				Language:  nullableValue(artifactLanguage),
				Version:   int(nullableInt64Value(artifactVersion)),
				CreatedAt: nullableInt64Value(artifactCreated),
				UpdatedAt: nullableInt64Value(artifactUpdated),
			}
		}
		if actionID.Valid || actionToolName.Valid || actionDesc.Valid || actionStatus.Valid || actionResult.Valid {
			block.Action = &chatdomain.ActionExecution{
				ID:          nullableValue(actionID),
				ToolName:    nullableValue(actionToolName),
				Description: nullableValue(actionDesc),
				Status:      chatdomain.ActionStatus(nullableValue(actionStatus)),
				Result:      nullableValue(actionResult),
				StartedAt:   nullableInt64Value(actionStarted),
				CompletedAt: nullableInt64Value(actionCompleted),
				Args:        nil,
			}
		}

		blocks = append(blocks, block)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chat repo: block rows: %w", err)
	}

	return blocks, nil
}

// hasMetadata reports whether metadata carries meaningful values.
func hasMetadata(meta *chatdomain.MessageMetadata) bool {

	if meta == nil {
		return false
	}
	return meta.Provider != "" ||
		meta.Model != "" ||
		meta.TokensIn != 0 ||
		meta.TokensOut != 0 ||
		meta.TokensTotal != 0 ||
		meta.LatencyMs != 0 ||
		meta.FinishReason != "" ||
		meta.StatusCode != 0 ||
		meta.ErrorMessage != ""
}

// findFirstErrorContent extracts the first error block text in a message.
func findFirstErrorContent(blocks []chatdomain.Block) string {

	for _, block := range blocks {
		if block.Type == chatdomain.BlockTypeError && block.Content != "" {
			return block.Content
		}
	}
	return ""
}

// newNullString maps empty strings to NULL.
func newNullString(value string) sql.NullString {

	if value == "" {
		return sql.NullString{}
	}
	return sql.NullString{String: value, Valid: true}
}

// nullableString maps empty strings to NULL for writes.
func nullableString(value string) sql.NullString {

	return newNullString(value)
}

// nullableValue converts a nullable string to a plain value.
func nullableValue(value sql.NullString) string {

	if !value.Valid {
		return ""
	}
	return value.String
}

// nullableInt64Value converts a nullable int64 to a plain value.
func nullableInt64Value(value sql.NullInt64) int64 {

	if !value.Valid {
		return 0
	}
	return value.Int64
}

// boolToInt maps booleans into SQLite-friendly integers.
func boolToInt(value bool) int {

	if value {
		return 1
	}
	return 0
}

```


--| internal/features/chat/domain/conversation.go

```go
// define conversation state and behavior for chat sessions.
// internal/features/chat/domain/conversation.go
package chat

import (
	"crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"sync"
	"time"
)

// ConversationSettings holds the configuration for a conversation.
type ConversationSettings struct {
	Provider     string  `json:"provider"`
	Model        string  `json:"model"`
	Temperature  float64 `json:"temperature,omitempty"`
	MaxTokens    int     `json:"maxTokens,omitempty"`
	SystemPrompt string  `json:"systemPrompt,omitempty"`
}

// Conversation represents a chat conversation.
type Conversation struct {
	mu         sync.RWMutex
	ID         string               `json:"id"`
	Title      string               `json:"title"`
	Messages   []*Message           `json:"messages"`
	Settings   ConversationSettings `json:"settings"`
	CreatedAt  int64                `json:"createdAt"`
	UpdatedAt  int64                `json:"updatedAt"`
	IsArchived bool                 `json:"isArchived"`
}

// ConversationSummary is a lightweight representation for listing.
type ConversationSummary struct {
	ID           string `json:"id"`
	Title        string `json:"title"`
	LastMessage  string `json:"lastMessage,omitempty"`
	MessageCount int    `json:"messageCount"`
	UpdatedAt    int64  `json:"updatedAt"`
}

// NewConversation creates a new conversation with the given settings.
func NewConversation(settings ConversationSettings) *Conversation {

	now := time.Now().UnixMilli()
	return &Conversation{
		ID:        generateID(),
		Title:     "New conversation",
		Messages:  []*Message{},
		Settings:  settings,
		CreatedAt: now,
		UpdatedAt: now,
	}
}

// Lock locks the conversation for writes.
func (c *Conversation) Lock() {

	c.mu.Lock()
}

// Unlock releases the conversation write lock.
func (c *Conversation) Unlock() {

	c.mu.Unlock()
}

// CheckIsArchived returns the archived status safely.
func (c *Conversation) CheckIsArchived() bool {

	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.IsArchived
}

// AddMessage adds a message to the conversation.
func (c *Conversation) AddMessage(msg *Message) {

	c.mu.Lock()
	defer c.mu.Unlock()

	c.Messages = append(c.Messages, msg)
	c.UpdatedAt = time.Now().UnixMilli()
}

// GetSummary returns a lightweight summary of the conversation.
func (c *Conversation) GetSummary() ConversationSummary {

	c.mu.RLock()
	defer c.mu.RUnlock()

	summary := ConversationSummary{
		ID:           c.ID,
		Title:        c.Title,
		MessageCount: len(c.Messages),
		UpdatedAt:    c.UpdatedAt,
	}

	if len(c.Messages) > 0 {
		lastMsg := c.Messages[len(c.Messages)-1]
		if len(lastMsg.Blocks) > 0 {
			content := lastMsg.Blocks[0].Content
			if len(content) > 100 {
				summary.LastMessage = content[:100]
			} else {
				summary.LastMessage = content
			}
		}
	}

	return summary
}

// Snapshot returns a deep copy of the conversation for safe reads.
func (c *Conversation) Snapshot() *Conversation {

	if c == nil {
		return nil
	}

	c.mu.RLock()
	defer c.mu.RUnlock()

	return &Conversation{
		ID:         c.ID,
		Title:      c.Title,
		Messages:   cloneMessages(c.Messages),
		Settings:   c.Settings,
		CreatedAt:  c.CreatedAt,
		UpdatedAt:  c.UpdatedAt,
		IsArchived: c.IsArchived,
	}
}

// generateID creates a random ID.
func generateID() string {

	b := make([]byte, 16)
	read, err := rand.Read(b)
	if err != nil || read != len(b) {
		now := time.Now().UnixNano()
		binary.LittleEndian.PutUint64(b[:8], uint64(now))
		binary.LittleEndian.PutUint64(b[8:], uint64(now>>1))
	}
	return hex.EncodeToString(b)
}

// cloneMessages deep copies message pointers for snapshots.
func cloneMessages(messages []*Message) []*Message {

	if messages == nil {
		return nil
	}

	cloned := make([]*Message, len(messages))
	for i, message := range messages {
		cloned[i] = cloneMessage(message)
	}
	return cloned
}

// cloneMessage deep copies a message for snapshots.
func cloneMessage(message *Message) *Message {

	if message == nil {
		return nil
	}

	return &Message{
		ID:             message.ID,
		ConversationID: message.ConversationID,
		Role:           message.Role,
		Blocks:         cloneBlocks(message.Blocks),
		Timestamp:      message.Timestamp,
		IsStreaming:    message.IsStreaming,
		Metadata:       cloneMetadata(message.Metadata),
	}
}

// cloneBlocks deep copies blocks for snapshots.
func cloneBlocks(blocks []Block) []Block {

	if blocks == nil {
		return nil
	}

	cloned := make([]Block, len(blocks))
	for i, block := range blocks {
		cloned[i] = Block{
			Type:        block.Type,
			Content:     block.Content,
			Language:    block.Language,
			Artifact:    cloneArtifact(block.Artifact),
			Action:      cloneAction(block.Action),
			IsCollapsed: block.IsCollapsed,
		}
	}
	return cloned
}

// cloneArtifact deep copies an artifact for snapshots.
func cloneArtifact(artifact *Artifact) *Artifact {

	if artifact == nil {
		return nil
	}

	clone := *artifact
	return &clone
}

// cloneAction deep copies an action execution for snapshots.
func cloneAction(action *ActionExecution) *ActionExecution {

	if action == nil {
		return nil
	}

	clone := *action
	if action.Args != nil {
		clone.Args = make(map[string]interface{}, len(action.Args))
		for key, value := range action.Args {
			clone.Args[key] = value
		}
	}
	return &clone
}

// cloneMetadata deep copies message metadata for snapshots.
func cloneMetadata(metadata *MessageMetadata) *MessageMetadata {

	if metadata == nil {
		return nil
	}

	clone := *metadata
	return &clone
}

```


--| internal/features/chat/domain/message.go

```go
// define message types and content blocks.
// internal/features/chat/domain/message.go
package chat

import (
	"time"
)

// Role represents the sender of a message.
type Role string

const (
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleTool      Role = "tool"
)

// BlockType represents the type of content in a message block.
type BlockType string

const (
	BlockTypeText     BlockType = "text"
	BlockTypeCode     BlockType = "code"
	BlockTypeArtifact BlockType = "artifact"
	BlockTypeThinking BlockType = "thinking"
	BlockTypeAction   BlockType = "action"
	BlockTypeError    BlockType = "error"
	BlockTypeImage    BlockType = "image"
)

// ActionStatus represents the status of a tool action.
type ActionStatus string

const (
	ActionStatusPending   ActionStatus = "pending"
	ActionStatusApproved  ActionStatus = "approved"
	ActionStatusRejected  ActionStatus = "rejected"
	ActionStatusRunning   ActionStatus = "running"
	ActionStatusCompleted ActionStatus = "completed"
	ActionStatusFailed    ActionStatus = "failed"
)

// ActionExecution represents a tool call and its execution state.
type ActionExecution struct {
	ID          string                 `json:"id"`
	ToolName    string                 `json:"toolName"`
	Description string                 `json:"description"`
	Args        map[string]interface{} `json:"args"`
	Status      ActionStatus           `json:"status"`
	Result      string                 `json:"result,omitempty"`
	StartedAt   int64                  `json:"startedAt,omitempty"`
	CompletedAt int64                  `json:"completedAt,omitempty"`
}

// Artifact represents a generated document, code file, or other content.
type Artifact struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Type      string `json:"type"` // document, code, diagram, image, data
	Content   string `json:"content"`
	Language  string `json:"language,omitempty"`
	Version   int    `json:"version"`
	CreatedAt int64  `json:"createdAt"`
	UpdatedAt int64  `json:"updatedAt"`
}

// Block represents a content block within a message.
type Block struct {
	Type        BlockType        `json:"type"`
	Content     string           `json:"content"`
	Language    string           `json:"language,omitempty"`
	Artifact    *Artifact        `json:"artifact,omitempty"`
	Action      *ActionExecution `json:"action,omitempty"`
	IsCollapsed bool             `json:"isCollapsed,omitempty"`
}

// Message represents a single message in a conversation.
type Message struct {
	ID             string           `json:"id"`
	ConversationID string           `json:"conversationId"`
	Role           Role             `json:"role"`
	Blocks         []Block          `json:"blocks"`
	Timestamp      int64            `json:"timestamp"`
	IsStreaming    bool             `json:"isStreaming,omitempty"`
	Metadata       *MessageMetadata `json:"metadata,omitempty"`
}

// NewMessage creates a new message with the given role and content.
func NewMessage(conversationID string, role Role, content string) *Message {

	return &Message{
		ID:             generateID(),
		ConversationID: conversationID,
		Role:           role,
		Blocks: []Block{
			{
				Type:    BlockTypeText,
				Content: content,
			},
		},
		Timestamp: time.Now().UnixMilli(),
	}
}

// NewStreamingMessage creates a new message that will receive streaming content.
func NewStreamingMessage(conversationID string, role Role) *Message {

	return &Message{
		ID:             generateID(),
		ConversationID: conversationID,
		Role:           role,
		Blocks:         []Block{},
		Timestamp:      time.Now().UnixMilli(),
		IsStreaming:    true,
	}
}

```


--| internal/features/chat/domain/metadata.go

```go
// describe metadata captured from provider responses.
// internal/features/chat/domain/metadata.go
package chat

// MessageMetadata contains information about message generation.
type MessageMetadata struct {
	Provider     string `json:"provider,omitempty"`
	Model        string `json:"model,omitempty"`
	TokensIn     int    `json:"tokensIn,omitempty"`
	TokensOut    int    `json:"tokensOut,omitempty"`
	TokensTotal  int    `json:"tokensTotal,omitempty"`
	LatencyMs    int64  `json:"latencyMs,omitempty"`
	FinishReason string `json:"finishReason,omitempty"`
	StatusCode   int    `json:"statusCode,omitempty"`
	ErrorMessage string `json:"errorMessage,omitempty"`
}

```


--| internal/features/chat/ports/chat_repository.go

```go
// define chat conversation persistence contracts.
// internal/features/chat/ports/chat_repository.go
package ports

import chatdomain "github.com/MadeByDoug/wls-chatbot/internal/features/chat/domain"

// ChatRepository defines storage operations for conversations.
type ChatRepository interface {
	Create(conv *chatdomain.Conversation) error
	Get(id string) (*chatdomain.Conversation, error)
	List() ([]*chatdomain.Conversation, error)
	Update(conv *chatdomain.Conversation) error
	Delete(id string) error
}

```


--| internal/features/chat/ports/status.go

```go
// normalize status codes from errors.
// internal/features/chat/ports/status.go
package ports

import "errors"

// StatusCoder is an interface for errors that have a status code.
type StatusCoder interface {
	StatusCode() int
}

// StatusCodeFromErr extracts a status code from an error if available.
func StatusCodeFromErr(err error) int {

	var coder StatusCoder
	if errors.As(err, &coder) {
		return coder.StatusCode()
	}
	return 0
}

```


--| internal/features/chat/usecase/orchestration.go

```go
// orchestrate chat workflows, streaming, and event emission.
// internal/features/chat/usecase/orchestration.go
package chat

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	chatports "github.com/MadeByDoug/wls-chatbot/internal/features/chat/ports"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

// Orchestrator coordinates chat workflows and event emission.
type Orchestrator struct {
	service  *Service
	registry providercore.ProviderRegistry
	secrets  providercore.SecretStore
	emitter  coreports.ChatEmitter
	stream   *streamManager
}

// NewOrchestrator creates a chat orchestrator with required dependencies.
func NewOrchestrator(chatService *Service, registry providercore.ProviderRegistry, secrets providercore.SecretStore, emitter coreports.ChatEmitter) *Orchestrator {

	return &Orchestrator{
		service:  chatService,
		registry: registry,
		secrets:  secrets,
		emitter:  emitter,
		stream:   newStreamManager(),
	}
}

// CreateConversation creates a new conversation with the given settings.
func (o *Orchestrator) CreateConversation(providerName, model string) (*Conversation, error) {

	return o.service.CreateConversation(ConversationSettings{
		Provider: providerName,
		Model:    model,
	})
}

// SetActiveConversation sets the active conversation by ID.
func (o *Orchestrator) SetActiveConversation(id string) {

	o.service.SetActiveConversation(id)
}

// GetActiveConversation returns the currently active conversation.
func (o *Orchestrator) GetActiveConversation() *Conversation {

	id := o.service.ActiveConversationID()
	if id == "" {
		return nil
	}
	return o.service.GetConversation(id)
}

// GetConversation returns a conversation by ID.
func (o *Orchestrator) GetConversation(id string) *Conversation {

	return o.service.GetConversation(id)
}

// ListConversations returns summaries of all conversations.
func (o *Orchestrator) ListConversations() []ConversationSummary {

	return o.service.ListConversations()
}

// ListDeletedConversations returns summaries of archived conversations.
func (o *Orchestrator) ListDeletedConversations() []ConversationSummary {

	return o.service.ListDeletedConversations()
}

// UpdateConversationModel updates the model for a conversation.
func (o *Orchestrator) UpdateConversationModel(conversationID, model string) bool {

	return o.service.UpdateConversationModel(conversationID, model)
}

// UpdateConversationProvider updates the provider for a conversation.
func (o *Orchestrator) UpdateConversationProvider(conversationID, provider string) bool {

	return o.service.UpdateConversationProvider(conversationID, provider)
}

// DeleteConversation archives a conversation by ID.
func (o *Orchestrator) DeleteConversation(id string) bool {

	return o.service.DeleteConversation(id)
}

// RestoreConversation restores an archived conversation by ID.
func (o *Orchestrator) RestoreConversation(id string) bool {

	return o.service.RestoreConversation(id)
}

// PurgeConversation permanently deletes a conversation by ID.
func (o *Orchestrator) PurgeConversation(id string) bool {

	return o.service.PurgeConversation(id)
}

// SendMessage sends a user message and initiates a streaming response.
func (o *Orchestrator) SendMessage(ctx context.Context, conversationID, content string) (*Message, error) {

	conversationID = strings.TrimSpace(conversationID)
	content = strings.TrimSpace(content)
	if conversationID == "" {
		return nil, errors.New("conversation ID required")
	}
	if content == "" {
		return nil, errors.New("message content required")
	}

	conversation := o.service.GetConversation(conversationID)
	if conversation == nil {
		return nil, fmt.Errorf("conversation not found: %s", conversationID)
	}
	if conversation.IsArchived {
		return nil, fmt.Errorf("conversation archived: %s", conversationID)
	}

	userMsg := o.service.AddMessage(conversationID, RoleUser, content)
	if userMsg == nil {
		return nil, fmt.Errorf("failed to persist user message for conversation: %s", conversationID)
	}

	o.maybeAutoTitle(conversationID, userMsg)

	o.emitChatEvent(coreports.ChatEvent{
		Type:           "chat.message",
		ConversationID: conversationID,
		MessageID:      userMsg.ID,
		Timestamp:      time.Now().UnixMilli(),
		Payload:        userMsg,
	})

	conv := o.service.GetConversation(conversationID)
	if conv == nil {
		return userMsg, nil
	}

	providerName := strings.TrimSpace(conv.Settings.Provider)
	if providerName == "" {
		return userMsg, nil
	}

	streamMsg := o.service.CreateStreamingMessage(conversationID, RoleAssistant)
	if streamMsg == nil {
		return userMsg, nil
	}

	o.emitChatEvent(coreports.ChatEvent{
		Type:           "chat.stream.start",
		ConversationID: conversationID,
		MessageID:      streamMsg.ID,
		Timestamp:      time.Now().UnixMilli(),
		Payload:        streamMsg,
	})

	prov, err := o.ensureProviderConfigured(providerName)
	if err != nil {
		o.emitStreamError(conversationID, streamMsg.ID, err)
		metadata := o.buildMetadata(providerName, conv.Settings.Model, "error", nil, time.Now(), err)
		_ = o.service.FinalizeMessage(conversationID, streamMsg.ID, metadata)
		return userMsg, nil
	}

	chatMessages := o.buildProviderMessages(conv, streamMsg.ID)
	opts := providergateway.ChatOptions{
		Model:       conv.Settings.Model,
		Temperature: conv.Settings.Temperature,
		MaxTokens:   conv.Settings.MaxTokens,
		Stream:      true,
	}

	ctx, cancel := context.WithCancel(ctx)
	o.stream.start(conversationID, streamMsg.ID, cancel)

	chunks, err := prov.Chat(ctx, chatMessages, opts)
	if err != nil {
		o.stream.clear(conversationID, streamMsg.ID)
		o.emitStreamError(conversationID, streamMsg.ID, err)
		metadata := o.buildMetadata(providerName, conv.Settings.Model, "error", nil, time.Now(), err)
		_ = o.service.FinalizeMessage(conversationID, streamMsg.ID, metadata)
		return userMsg, nil
	}

	go o.consumeStream(conversationID, streamMsg.ID, providerName, conv.Settings.Model, chunks)

	return userMsg, nil
}

// StopStream cancels the currently running stream.
func (o *Orchestrator) StopStream() {

	o.stream.stop()
}

// emitChatEvent sends a chat event through the emitter if available.
func (o *Orchestrator) emitChatEvent(event coreports.ChatEvent) {

	if o.emitter == nil {
		return
	}
	o.emitter.EmitChatEvent(event)
}

// emitStreamChunk publishes a streaming chunk event.
func (o *Orchestrator) emitStreamChunk(conversationID, messageID string, blockIndex int, content string) {

	o.emitChatEvent(coreports.ChatEvent{
		Type:           "chat.stream.chunk",
		ConversationID: conversationID,
		MessageID:      messageID,
		Timestamp:      time.Now().UnixMilli(),
		Payload: coreports.StreamChunkPayload{
			BlockIndex: blockIndex,
			Content:    content,
			IsDone:     false,
		},
	})
}

// emitStreamError publishes a streaming error event.
func (o *Orchestrator) emitStreamError(conversationID, messageID string, err error) {

	payload := coreports.StreamChunkPayload{
		BlockIndex: 0,
		Content:    "",
		IsDone:     true,
		Error:      err.Error(),
		StatusCode: chatports.StatusCodeFromErr(err),
	}
	o.emitChatEvent(coreports.ChatEvent{
		Type:           "chat.stream.error",
		ConversationID: conversationID,
		MessageID:      messageID,
		Timestamp:      time.Now().UnixMilli(),
		Payload:        payload,
	})
}

// emitStreamComplete publishes a stream completion event.
func (o *Orchestrator) emitStreamComplete(conversationID, messageID string, metadata *MessageMetadata) {

	o.emitChatEvent(coreports.ChatEvent{
		Type:           "chat.stream.complete",
		ConversationID: conversationID,
		MessageID:      messageID,
		Timestamp:      time.Now().UnixMilli(),
		Payload: coreports.StreamChunkPayload{
			BlockIndex: 0,
			Content:    "",
			IsDone:     true,
			Metadata:   metadata,
		},
	})
}

// ensureProviderConfigured returns a configured provider or an error.
func (o *Orchestrator) ensureProviderConfigured(name string) (providercore.Provider, error) {

	if o.registry == nil {
		return nil, fmt.Errorf("provider registry not configured")
	}
	prov := o.registry.Get(name)
	if prov == nil {
		return nil, fmt.Errorf("provider not found: %s", name)
	}

	fields := prov.CredentialFields()
	credentials := make(providercore.ProviderCredentials)
	for _, field := range fields {
		if !field.Secret {
			continue
		}
		if o.secrets == nil {
			if field.Required {
				return nil, fmt.Errorf("secret store not configured")
			}
			continue
		}
		value, err := o.secrets.GetProviderSecret(name, field.Name)
		if err != nil || strings.TrimSpace(value) == "" {
			if field.Required {
				return nil, fmt.Errorf("missing required credential: %s", field.Name)
			}
			continue
		}
		credentials[field.Name] = value
	}
	if len(credentials) > 0 {
		_ = prov.Configure(providercore.ProviderConfig{Credentials: credentials})
	}
	return prov, nil
}

// buildProviderMessages builds the provider-facing message list.
func (o *Orchestrator) buildProviderMessages(conv *Conversation, streamingMessageID string) []providergateway.ProviderMessage {

	conv.Lock()
	defer conv.Unlock()

	messages := make([]providergateway.ProviderMessage, 0, len(conv.Messages)+1)
	systemPrompt := strings.TrimSpace(conv.Settings.SystemPrompt)
	if systemPrompt != "" {
		messages = append(messages, providergateway.ProviderMessage{
			Role:    providergateway.RoleSystem,
			Content: systemPrompt,
		})
	}

	for _, msg := range conv.Messages {
		if msg.ID == streamingMessageID && len(msg.Blocks) == 0 {
			continue
		}
		content := textFromBlocks(msg.Blocks)
		if strings.TrimSpace(content) == "" {
			continue
		}
		messages = append(messages, providergateway.ProviderMessage{
			Role:    providergateway.Role(msg.Role),
			Content: content,
		})
	}
	return messages
}

// textFromBlocks builds a text-only content string from message blocks.
func textFromBlocks(blocks []Block) string {

	if len(blocks) == 0 {
		return ""
	}

	var builder strings.Builder
	for _, block := range blocks {
		if block.Type == BlockTypeText {
			builder.WriteString(block.Content)
		}
	}
	return builder.String()
}

// consumeStream handles incoming provider chunks and emits events.
func (o *Orchestrator) consumeStream(conversationID, messageID, providerName, fallbackModel string, chunks <-chan providergateway.Chunk) {

	defer o.stream.clear(conversationID, messageID)

	start := time.Now()
	var (
		finishReason string
		usage        *providergateway.UsageStats
		model        string
	)

	for chunk := range chunks {
		if chunk.Error != nil {
			if isContextCanceled(chunk.Error) {
				metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), "cancelled", usage, start, nil)
				_ = o.service.FinalizeMessage(conversationID, messageID, metadata)
				o.emitStreamComplete(conversationID, messageID, metadata)
			} else {
				o.emitStreamError(conversationID, messageID, chunk.Error)
				metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), "error", usage, start, chunk.Error)
				_ = o.service.FinalizeMessage(conversationID, messageID, metadata)
			}
			return
		}

		if chunk.Content != "" {
			if !o.service.AppendToMessage(conversationID, messageID, 0, chunk.Content) {
				err := fmt.Errorf("failed to persist stream chunk")
				o.emitStreamError(conversationID, messageID, err)
				metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), "error", usage, start, err)
				_ = o.service.FinalizeMessage(conversationID, messageID, metadata)
				return
			}
			o.emitStreamChunk(conversationID, messageID, 0, chunk.Content)
		}
		if chunk.Model != "" {
			model = chunk.Model
		}
		if chunk.Usage != nil {
			usage = chunk.Usage
		}
		if chunk.FinishReason != "" {
			finishReason = chunk.FinishReason
		}
	}

	if finishReason == "" && o.stream.wasCancelled(conversationID, messageID) {
		finishReason = "cancelled"
	}

	metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), finishReason, usage, start, nil)
	if !o.service.FinalizeMessage(conversationID, messageID, metadata) {
		err := fmt.Errorf("failed to persist stream completion")
		o.emitStreamError(conversationID, messageID, err)
		return
	}
	o.emitStreamComplete(conversationID, messageID, metadata)
}

// buildMetadata builds message metadata from provider results.
func (o *Orchestrator) buildMetadata(
	providerName,
	model,
	finishReason string,
	usage *providergateway.UsageStats,
	start time.Time,
	err error,
) *MessageMetadata {

	meta := &MessageMetadata{
		Provider:     providerName,
		Model:        model,
		FinishReason: finishReason,
		LatencyMs:    time.Since(start).Milliseconds(),
	}
	if meta.FinishReason == "" {
		meta.FinishReason = "stop"
	}
	if usage != nil {
		meta.TokensIn = usage.PromptTokens
		meta.TokensOut = usage.CompletionTokens
		meta.TokensTotal = usage.TotalTokens
		if meta.TokensTotal == 0 {
			meta.TokensTotal = usage.PromptTokens + usage.CompletionTokens
		}
	}
	if err != nil {
		meta.StatusCode = chatports.StatusCodeFromErr(err)
		meta.ErrorMessage = err.Error()
	}
	return meta
}

// maybeAutoTitle updates the conversation title on the first user message.
func (o *Orchestrator) maybeAutoTitle(conversationID string, message *Message) {

	if message.Role != RoleUser {
		return
	}
	conv := o.service.GetConversation(conversationID)
	if conv == nil {
		return
	}
	conv.Lock()
	messageCount := len(conv.Messages)
	conv.Unlock()
	if messageCount != 1 {
		return
	}
	if len(message.Blocks) == 0 {
		return
	}
	content := message.Blocks[0].Content
	if content == "" {
		return
	}
	if len(content) > 50 {
		content = content[:50] + "..."
	}
	if o.service.SetConversationTitle(conversationID, content) {
		o.emitChatEvent(coreports.ChatEvent{
			Type:           "chat.conversation.title",
			ConversationID: conversationID,
			Timestamp:      time.Now().UnixMilli(),
			Payload: coreports.ConversationTitlePayload{
				Title: content,
			},
		})
	}
}

// chooseModel selects the best available model name.
func chooseModel(primary, fallback string) string {

	if strings.TrimSpace(primary) != "" {
		return primary
	}
	return fallback
}

// isContextCanceled checks for context cancellation errors.
func isContextCanceled(err error) bool {

	return errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded)
}

```


--| internal/features/chat/usecase/service.go

```go
// manage conversation lifecycle and message state mutations.
// internal/features/chat/usecase/service.go
package chat

import (
	"sync"
	"time"
)

// Service manages conversations and messages.
type Service struct {
	repo Repository

	mu           sync.RWMutex
	activeConvID string
}

// NewService creates a new chat service with the provided repository.
func NewService(repo Repository) *Service {

	return &Service{
		repo: repo,
	}
}

// CreateConversation creates a new conversation with the given settings.
func (s *Service) CreateConversation(settings ConversationSettings) (*Conversation, error) {

	conv := NewConversation(settings)
	if err := s.repo.Create(conv); err != nil {
		return nil, err
	}
	s.SetActiveConversation(conv.ID)
	return conv, nil
}

// SetActiveConversation marks a conversation as active.
func (s *Service) SetActiveConversation(id string) {

	s.mu.Lock()
	s.activeConvID = id
	s.mu.Unlock()
}

// ActiveConversationID returns the active conversation ID.
func (s *Service) ActiveConversationID() string {

	s.mu.RLock()
	id := s.activeConvID
	s.mu.RUnlock()
	return id
}

// GetConversation retrieves a conversation by ID.
func (s *Service) GetConversation(id string) *Conversation {

	conv, err := s.repo.Get(id)
	if err != nil {
		return nil
	}
	if conv == nil {
		return nil
	}
	return conv.Snapshot()
}

// ListConversations returns summaries of all conversations, sorted by updatedAt.
func (s *Service) ListConversations() []ConversationSummary {

	return s.listConversationsByArchivedStatus(false)
}

// ListDeletedConversations returns summaries for archived conversations.
func (s *Service) ListDeletedConversations() []ConversationSummary {

	return s.listConversationsByArchivedStatus(true)
}

// listConversationsByArchivedStatus returns summaries filtered by archive status.
func (s *Service) listConversationsByArchivedStatus(archived bool) []ConversationSummary {

	convs, err := s.repo.List()
	if err != nil {
		return nil
	}
	summaries := make([]ConversationSummary, 0, len(convs))
	for _, conv := range convs {
		if conv.CheckIsArchived() == archived {
			summaries = append(summaries, conv.GetSummary())
		}
	}

	// Sort by updatedAt descending
	for i := 0; i < len(summaries)-1; i++ {
		for j := i + 1; j < len(summaries); j++ {
			if summaries[j].UpdatedAt > summaries[i].UpdatedAt {
				summaries[i], summaries[j] = summaries[j], summaries[i]
			}
		}
	}

	return summaries
}

// AddMessage adds a message to a conversation.
func (s *Service) AddMessage(conversationID string, role Role, content string) *Message {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return nil
	}
	if conv == nil || conv.CheckIsArchived() {
		return nil
	}

	msg := NewMessage(conversationID, role, content)
	conv.AddMessage(msg)
	if err := s.repo.Update(conv); err != nil {
		return nil
	}
	return msg
}

// SetConversationTitle updates the title for a conversation.
func (s *Service) SetConversationTitle(conversationID, title string) bool {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return false
	}
	if conv == nil {
		return false
	}

	conv.Lock()
	conv.Title = title
	conv.UpdatedAt = time.Now().UnixMilli()
	conv.Unlock()

	return s.repo.Update(conv) == nil
}

// CreateStreamingMessage creates a new streaming message placeholder.
func (s *Service) CreateStreamingMessage(conversationID string, role Role) *Message {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return nil
	}
	if conv == nil || conv.CheckIsArchived() {
		return nil
	}

	msg := NewStreamingMessage(conversationID, role)
	conv.AddMessage(msg)
	if err := s.repo.Update(conv); err != nil {
		return nil
	}
	return msg
}

// AppendToMessage appends content to a streaming message.
func (s *Service) AppendToMessage(conversationID, messageID string, blockIndex int, content string) bool {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return false
	}
	if conv == nil {
		return false
	}

	conv.Lock()
	defer conv.Unlock()

	updated := false
	for _, msg := range conv.Messages {
		if msg.ID == messageID {
			// Extend blocks if needed
			for len(msg.Blocks) <= blockIndex {
				msg.Blocks = append(msg.Blocks, Block{Type: BlockTypeText})
			}
			msg.Blocks[blockIndex].Content += content
			updated = true
			break
		}
	}

	if updated {
		if err := s.repo.Update(conv); err != nil {
			return false
		}
	}

	return updated
}

// FinalizeMessage marks a streaming message as complete.
func (s *Service) FinalizeMessage(conversationID, messageID string, metadata *MessageMetadata) bool {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return false
	}
	if conv == nil {
		return false
	}

	conv.Lock()
	defer conv.Unlock()

	updated := false
	for _, msg := range conv.Messages {
		if msg.ID == messageID {
			msg.IsStreaming = false
			msg.Metadata = metadata
			updated = true
			break
		}
	}

	if updated {
		if err := s.repo.Update(conv); err != nil {
			return false
		}
	}

	return updated
}

// DeleteConversation moves a conversation into the recycle bin.
func (s *Service) DeleteConversation(id string) bool {

	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv == nil || conv.CheckIsArchived() {
		return false
	}

	conv.Lock()
	conv.IsArchived = true
	conv.UpdatedAt = time.Now().UnixMilli()
	conv.Unlock()

	if s.ActiveConversationID() == id {
		s.SetActiveConversation("")
	}

	return s.repo.Update(conv) == nil
}

// RestoreConversation restores a conversation from the recycle bin.
func (s *Service) RestoreConversation(id string) bool {

	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv == nil || !conv.CheckIsArchived() {
		return false
	}

	conv.Lock()
	conv.IsArchived = false
	conv.UpdatedAt = time.Now().UnixMilli()
	conv.Unlock()

	return s.repo.Update(conv) == nil
}

// PurgeConversation permanently deletes a conversation.
func (s *Service) PurgeConversation(id string) bool {

	if s.ActiveConversationID() == id {
		s.SetActiveConversation("")
	}

	err := s.repo.Delete(id)
	return err == nil
}

// UpdateConversationModel updates the model for a conversation.
func (s *Service) UpdateConversationModel(id, model string) bool {

	if model == "" {
		return false
	}
	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv != nil && !conv.CheckIsArchived() {
		conv.Lock()
		defer conv.Unlock()
		conv.Settings.Model = model
		conv.UpdatedAt = time.Now().UnixMilli()
		return s.repo.Update(conv) == nil
	}
	return false
}

// UpdateConversationProvider updates the provider for a conversation.
func (s *Service) UpdateConversationProvider(id, provider string) bool {

	if provider == "" {
		return false
	}
	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv != nil && !conv.CheckIsArchived() {
		conv.Lock()
		defer conv.Unlock()
		conv.Settings.Provider = provider
		conv.UpdatedAt = time.Now().UnixMilli()
		return s.repo.Update(conv) == nil
	}
	return false
}

```


--| internal/features/chat/usecase/stream_manager.go

```go
// manage cancellation state for streaming chat responses.
// internal/features/chat/usecase/stream_manager.go
package chat

import (
	"context"
	"sync"
	"time"
)

// streamInfo captures metadata about the active stream.
type streamInfo struct {
	conversationID string
	messageID      string
	startedAt      time.Time
	cancelled      bool
}

// streamManager controls the lifecycle of a single active stream.
type streamManager struct {
	mu     sync.Mutex
	cancel context.CancelFunc
	info   *streamInfo
}

// newStreamManager constructs a stream manager.
func newStreamManager() *streamManager {

	return &streamManager{}
}

// start records the active stream and stores its cancel function.
func (s *streamManager) start(conversationID, messageID string, cancel context.CancelFunc) {

	s.mu.Lock()
	defer s.mu.Unlock()
	if s.cancel != nil {
		s.cancel()
	}
	s.cancel = cancel
	s.info = &streamInfo{
		conversationID: conversationID,
		messageID:      messageID,
		startedAt:      time.Now(),
	}
}

// stop cancels the active stream if present.
func (s *streamManager) stop() {

	s.mu.Lock()
	if s.info != nil {
		s.info.cancelled = true
	}
	cancel := s.cancel
	s.mu.Unlock()
	if cancel != nil {
		cancel()
	}
}

// wasCancelled reports whether the active stream was cancelled.
func (s *streamManager) wasCancelled(conversationID, messageID string) bool {

	s.mu.Lock()
	defer s.mu.Unlock()
	if s.info == nil {
		return false
	}
	if s.info.conversationID != conversationID || s.info.messageID != messageID {
		return false
	}
	return s.info.cancelled
}

// clear removes the active stream if it matches the given identifiers.
func (s *streamManager) clear(conversationID, messageID string) {

	var cancel context.CancelFunc
	s.mu.Lock()
	if s.info != nil && s.info.conversationID == conversationID && s.info.messageID == messageID {
		cancel = s.cancel
		s.cancel = nil
		s.info = nil
	}
	s.mu.Unlock()
	if cancel != nil {
		cancel()
	}
}

```


--| internal/features/chat/usecase/types.go

```go
// re-export domain types and ports for the chat use case.
// internal/features/chat/usecase/types.go
package chat

import (
	chatdomain "github.com/MadeByDoug/wls-chatbot/internal/features/chat/domain"
	chatports "github.com/MadeByDoug/wls-chatbot/internal/features/chat/ports"
)

type Conversation = chatdomain.Conversation
type ConversationSettings = chatdomain.ConversationSettings
type ConversationSummary = chatdomain.ConversationSummary
type Message = chatdomain.Message
type MessageMetadata = chatdomain.MessageMetadata
type Role = chatdomain.Role
type Block = chatdomain.Block
type BlockType = chatdomain.BlockType

type Repository = chatports.ChatRepository

const (
	RoleUser      = chatdomain.RoleUser
	RoleAssistant = chatdomain.RoleAssistant
	RoleSystem    = chatdomain.RoleSystem
	RoleTool      = chatdomain.RoleTool
)

const (
	BlockTypeText     = chatdomain.BlockTypeText
	BlockTypeCode     = chatdomain.BlockTypeCode
	BlockTypeArtifact = chatdomain.BlockTypeArtifact
	BlockTypeThinking = chatdomain.BlockTypeThinking
	BlockTypeAction   = chatdomain.BlockTypeAction
	BlockTypeError    = chatdomain.BlockTypeError
	BlockTypeImage    = chatdomain.BlockTypeImage
)

// NewConversation builds a new conversation from domain settings.
func NewConversation(settings ConversationSettings) *Conversation {

	return chatdomain.NewConversation(settings)
}

// NewMessage builds a new domain message.
func NewMessage(conversationID string, role Role, content string) *Message {

	return chatdomain.NewMessage(conversationID, role, content)
}

// NewStreamingMessage builds a streaming placeholder message.
func NewStreamingMessage(conversationID string, role Role) *Message {

	return chatdomain.NewStreamingMessage(conversationID, role)
}

```


--| internal/features/notifications/adapters/notificationrepo/sqlite.go

```go
// sqlite.go persists notifications in SQLite.
// internal/features/notifications/adapters/notificationrepo/sqlite.go
package notificationrepo

import (
	"database/sql"
	"fmt"

	notificationdomain "github.com/MadeByDoug/wls-chatbot/internal/features/notifications/domain"
	notificationports "github.com/MadeByDoug/wls-chatbot/internal/features/notifications/ports"
)

const notificationSchema = `
CREATE TABLE IF NOT EXISTS notifications (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	type TEXT NOT NULL,
	title TEXT NOT NULL,
	message TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	read_at INTEGER
);

CREATE INDEX IF NOT EXISTS idx_notifications_created_at
ON notifications (created_at DESC);
`

// Repository stores notifications in SQLite.
type Repository struct {
	db *sql.DB
}

// NewRepository creates a SQLite-backed notification repository.
func NewRepository(db *sql.DB) (*Repository, error) {

	if db == nil {
		return nil, fmt.Errorf("notification repo: db required")
	}

	if _, err := db.Exec(notificationSchema); err != nil {
		return nil, fmt.Errorf("notification repo: ensure schema: %w", err)
	}

	return &Repository{db: db}, nil
}

var _ notificationports.NotificationRepository = (*Repository)(nil)

// Create stores a notification record.
func (r *Repository) Create(notification *notificationdomain.Notification) (*notificationdomain.Notification, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("notification repo: db required")
	}
	if notification == nil {
		return nil, fmt.Errorf("notification repo: notification required")
	}

	var readAt interface{} = nil
	if notification.ReadAt != nil {
		readAt = *notification.ReadAt
	}

	result, err := r.db.Exec(
		`INSERT INTO notifications (type, title, message, created_at, read_at)
		 VALUES (?, ?, ?, ?, ?)`,
		notification.Type,
		notification.Title,
		notification.Message,
		notification.CreatedAt,
		readAt,
	)
	if err != nil {
		return nil, fmt.Errorf("notification repo: create: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("notification repo: create id: %w", err)
	}

	copy := *notification
	copy.ID = id
	return &copy, nil
}

// List returns stored notifications ordered by created time.
func (r *Repository) List() ([]*notificationdomain.Notification, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("notification repo: db required")
	}

	rows, err := r.db.Query(
		`SELECT id, type, title, message, created_at, read_at
		 FROM notifications
		 ORDER BY created_at DESC`,
	)
	if err != nil {
		return nil, fmt.Errorf("notification repo: list: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	results := make([]*notificationdomain.Notification, 0)
	for rows.Next() {
		var notification notificationdomain.Notification
		var readAt sql.NullInt64
		if err := rows.Scan(
			&notification.ID,
			&notification.Type,
			&notification.Title,
			&notification.Message,
			&notification.CreatedAt,
			&readAt,
		); err != nil {
			return nil, fmt.Errorf("notification repo: scan: %w", err)
		}
		if readAt.Valid {
			value := readAt.Int64
			notification.ReadAt = &value
		}
		results = append(results, &notification)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("notification repo: rows: %w", err)
	}

	return results, nil
}

// Delete removes a notification by id.
func (r *Repository) Delete(id int64) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("notification repo: db required")
	}
	if id <= 0 {
		return fmt.Errorf("notification repo: id required")
	}

	if _, err := r.db.Exec("DELETE FROM notifications WHERE id = ?", id); err != nil {
		return fmt.Errorf("notification repo: delete: %w", err)
	}
	return nil
}

// Clear removes all notifications.
func (r *Repository) Clear() error {

	if r == nil || r.db == nil {
		return fmt.Errorf("notification repo: db required")
	}

	if _, err := r.db.Exec("DELETE FROM notifications"); err != nil {
		return fmt.Errorf("notification repo: clear: %w", err)
	}
	return nil
}

```


--| internal/features/notifications/domain/notification.go

```go
// notification.go defines notification records.
// internal/features/notifications/domain/notification.go
package domain

import "time"

// Type describes a notification category.
type Type string

const (
	TypeInfo  Type = "info"
	TypeError Type = "error"
)

// Notification captures a stored notification entry.
type Notification struct {
	ID        int64  `json:"id"`
	Type      Type   `json:"type"`
	Title     string `json:"title"`
	Message   string `json:"message"`
	CreatedAt int64  `json:"createdAt"`
	ReadAt    *int64 `json:"readAt,omitempty"`
}

// NewNotification constructs a new notification with a timestamp.
func NewNotification(kind Type, title, message string) *Notification {

	return &Notification{
		Type:      kind,
		Title:     title,
		Message:   message,
		CreatedAt: time.Now().UnixMilli(),
	}
}

// MarkRead stamps a notification as read.
func (n *Notification) MarkRead() {

	if n == nil {
		return
	}
	readAt := time.Now().UnixMilli()
	n.ReadAt = &readAt
}

```


--| internal/features/notifications/ports/notification_repository.go

```go
// notification_repository.go declares notification persistence ports.
// internal/features/notifications/ports/notification_repository.go
package ports

import "github.com/MadeByDoug/wls-chatbot/internal/features/notifications/domain"

// NotificationRepository persists notifications.
type NotificationRepository interface {
	Create(notification *domain.Notification) (*domain.Notification, error)
	List() ([]*domain.Notification, error)
	Delete(id int64) error
	Clear() error
}

```


--| internal/features/notifications/usecase/orchestration.go

```go
// orchestration.go exposes notification workflows for adapters.
// internal/features/notifications/usecase/orchestration.go
package notifications

import "fmt"

// Orchestrator coordinates notification workflows for adapters.
type Orchestrator struct {
	service *Service
}

// NewOrchestrator creates a notification orchestrator.
func NewOrchestrator(service *Service) *Orchestrator {

	return &Orchestrator{service: service}
}

// CreateNotification persists a notification and returns the stored record.
func (o *Orchestrator) CreateNotification(payload NotificationPayload) (*Notification, error) {

	if o == nil || o.service == nil {
		return nil, fmt.Errorf("notifications service not configured")
	}

	return o.service.Create(payload)
}

// ListNotifications returns stored notifications.
func (o *Orchestrator) ListNotifications() []Notification {

	if o == nil || o.service == nil {
		return []Notification{}
	}

	return o.service.List()
}

// DeleteNotification removes a notification by id.
func (o *Orchestrator) DeleteNotification(id int64) bool {

	if o == nil || o.service == nil {
		return false
	}

	return o.service.Delete(id) == nil
}

// ClearNotifications removes all notifications.
func (o *Orchestrator) ClearNotifications() bool {

	if o == nil || o.service == nil {
		return false
	}

	return o.service.Clear() == nil
}

```


--| internal/features/notifications/usecase/service.go

```go
// service.go manages notification lifecycle operations.
// internal/features/notifications/usecase/service.go
package notifications

import (
	"fmt"
	"strings"

	notificationdomain "github.com/MadeByDoug/wls-chatbot/internal/features/notifications/domain"
)

// Service coordinates notification persistence.
type Service struct {
	repo Repository
}

// NewService creates a notification service with the provided repository.
func NewService(repo Repository) *Service {

	return &Service{repo: repo}
}

// Create persists a new notification and returns the stored record.
func (s *Service) Create(payload NotificationPayload) (*Notification, error) {

	if s == nil || s.repo == nil {
		return nil, fmt.Errorf("notifications: repo required")
	}

	message := strings.TrimSpace(payload.Message)
	if message == "" {
		return nil, fmt.Errorf("notifications: message required")
	}

	kind := TypeInfo
	if strings.EqualFold(strings.TrimSpace(payload.Type), string(TypeError)) {
		kind = TypeError
	}

	title := strings.TrimSpace(payload.Title)
	notification := notificationdomain.NewNotification(kind, title, message)
	return s.repo.Create(notification)
}

// List returns the stored notifications in descending order.
func (s *Service) List() []Notification {

	if s == nil || s.repo == nil {
		return []Notification{}
	}

	list, err := s.repo.List()
	if err != nil {
		return []Notification{}
	}

	result := make([]Notification, 0, len(list))
	for _, notification := range list {
		if notification == nil {
			continue
		}
		result = append(result, *notification)
	}

	return result
}

// Delete removes a notification by id.
func (s *Service) Delete(id int64) error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("notifications: repo required")
	}
	if id <= 0 {
		return fmt.Errorf("notifications: id required")
	}

	return s.repo.Delete(id)
}

// Clear removes all notifications.
func (s *Service) Clear() error {

	if s == nil || s.repo == nil {
		return fmt.Errorf("notifications: repo required")
	}

	return s.repo.Clear()
}

```


--| internal/features/notifications/usecase/types.go

```go
// types.go re-exports notification domain types and ports.
// internal/features/notifications/usecase/types.go
package notifications

import (
	notificationdomain "github.com/MadeByDoug/wls-chatbot/internal/features/notifications/domain"
	notificationports "github.com/MadeByDoug/wls-chatbot/internal/features/notifications/ports"
)

type Notification = notificationdomain.Notification

type NotificationType = notificationdomain.Type

type Repository = notificationports.NotificationRepository

// NotificationPayload describes input needed to create a notification.
type NotificationPayload struct {
	Type    string `json:"type"`
	Title   string `json:"title"`
	Message string `json:"message"`
}

const (
	TypeInfo  = notificationdomain.TypeInfo
	TypeError = notificationdomain.TypeError
)

```


--| internal/features/providers/adapters/anthropic/provider.go

```go
// provider.go implements the Anthropic provider adapter.
// internal/features/providers/adapters/anthropic/provider.go
package anthropic

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	anthropicsdk "github.com/anthropics/anthropic-sdk-go"
	"github.com/anthropics/anthropic-sdk-go/option"
	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/providerhttp"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	defaultAnthropicMaxTokens = 1024
	CredentialAPIKey          = providercore.CredentialAPIKey
	RoleUser                  = providergateway.RoleUser
	RoleAssistant             = providergateway.RoleAssistant
	RoleSystem                = providergateway.RoleSystem
)

// Anthropic implements the Provider interface for Anthropic.
type Anthropic struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*Anthropic)(nil)

// New creates a new Anthropic provider.
func New(config Config) *Anthropic {

	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = "https://api.anthropic.com"
	}

	return &Anthropic{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (a *Anthropic) Name() string {

	return a.name
}

// DisplayName returns the human-readable provider name.
func (a *Anthropic) DisplayName() string {

	return a.displayName
}

// Models returns the available models.
func (a *Anthropic) Models() []Model {

	return a.models
}

// CredentialFields returns the expected credential inputs.
func (a *Anthropic) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (a *Anthropic) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			a.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		a.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		a.baseURL = config.BaseURL
	}
	if config.Models != nil {
		a.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (a *Anthropic) SetHTTPClient(client HTTPClient) {

	if client != nil {
		a.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (a *Anthropic) httpClient() HTTPClient {

	if a.client == nil {
		a.client = providerhttp.NewDefaultClient()
	}
	return a.client
}

// TestConnection verifies the API is reachable.
func (a *Anthropic) TestConnection(ctx context.Context) error {

	_, err := a.ListResources(ctx)
	return err
}

// ListResources fetches the available models from Anthropic.
func (a *Anthropic) ListResources(ctx context.Context) ([]Model, error) {

	client := a.newSDKClient()
	page, err := client.Models.List(ctx, anthropicsdk.ModelListParams{})
	if err != nil {
		return nil, a.wrapAnthropicError(err)
	}

	models := make([]Model, 0, len(page.Data))
	for _, item := range page.Data {
		if item.ID == "" {
			continue
		}
		name := strings.TrimSpace(item.DisplayName)
		if name == "" {
			name = item.ID
		}
		models = append(models, Model{
			ID:   item.ID,
			Name: name,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// Chat implements streaming chat completion.
func (a *Anthropic) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	if strings.TrimSpace(opts.Model) == "" {
		return nil, fmt.Errorf("model required")
	}

	apiMessages, systemBlocks := a.toAnthropicMessages(messages)
	if len(apiMessages) == 0 {
		return nil, fmt.Errorf("messages required")
	}

	params := anthropicsdk.MessageNewParams{
		Model:     anthropicsdk.Model(opts.Model),
		MaxTokens: int64(a.resolveMaxTokens(opts)),
		Messages:  apiMessages,
	}
	if len(systemBlocks) > 0 {
		params.System = systemBlocks
	}
	if opts.Temperature > 0 {
		params.Temperature = anthropicsdk.Float(opts.Temperature)
	}
	if len(opts.StopWords) > 0 {
		params.StopSequences = opts.StopWords
	}

	if opts.Stream {
		return a.chatStreaming(ctx, params)
	}
	return a.chatOnce(ctx, params)
}

// resolveMaxTokens returns a valid max token value for Anthropic.
func (a *Anthropic) resolveMaxTokens(opts ChatOptions) int {

	if opts.MaxTokens > 0 {
		return opts.MaxTokens
	}
	return defaultAnthropicMaxTokens
}

// toAnthropicMessages converts provider messages into Anthropic params.
func (a *Anthropic) toAnthropicMessages(messages []ProviderMessage) ([]anthropicsdk.MessageParam, []anthropicsdk.TextBlockParam) {

	apiMessages := make([]anthropicsdk.MessageParam, 0, len(messages))
	systemBlocks := make([]anthropicsdk.TextBlockParam, 0)

	for _, msg := range messages {
		content := strings.TrimSpace(msg.Content)
		if content == "" {
			continue
		}

		if msg.Role == RoleSystem {
			systemBlocks = append(systemBlocks, anthropicsdk.TextBlockParam{Text: content})
			continue
		}

		block := anthropicsdk.NewTextBlock(content)
		if msg.Role == RoleAssistant {
			apiMessages = append(apiMessages, anthropicsdk.NewAssistantMessage(block))
			continue
		}

		apiMessages = append(apiMessages, anthropicsdk.NewUserMessage(block))
	}

	return apiMessages, systemBlocks
}

// chatOnce executes a non-streaming Anthropic chat request.
func (a *Anthropic) chatOnce(ctx context.Context, params anthropicsdk.MessageNewParams) (<-chan Chunk, error) {

	client := a.newSDKClient()
	resp, err := client.Messages.New(ctx, params)
	if err != nil {
		return nil, a.wrapAnthropicError(err)
	}

	content := a.textFromContentBlocks(resp.Content)
	chunks := make(chan Chunk, 1)
	go func() {
		defer close(chunks)
		chunks <- Chunk{
			Content:      content,
			Model:        string(resp.Model),
			FinishReason: a.mapStopReason(resp.StopReason),
			Usage:        a.toUsageStats(resp.Usage),
		}
	}()

	return chunks, nil
}

// chatStreaming executes a streaming Anthropic chat request.
func (a *Anthropic) chatStreaming(ctx context.Context, params anthropicsdk.MessageNewParams) (<-chan Chunk, error) {

	client := a.newSDKClient()
	stream := client.Messages.NewStreaming(ctx, params)
	chunks := make(chan Chunk, 100)

	go func() {
		defer close(chunks)
		defer func() { _ = stream.Close() }()

		message := anthropicsdk.Message{}
		for stream.Next() {
			event := stream.Current()
			if err := message.Accumulate(event); err != nil {
				chunks <- Chunk{Error: err}
				return
			}

			switch variant := event.AsAny().(type) {
			case anthropicsdk.ContentBlockDeltaEvent:
				delta := variant.Delta.AsAny()
				if textDelta, ok := delta.(anthropicsdk.TextDelta); ok {
					if text := textDelta.Text; text != "" {
						chunks <- Chunk{
							Content: text,
							Model:   string(message.Model),
						}
					}
				}
			}
		}

		if err := stream.Err(); err != nil {
			chunks <- Chunk{Error: a.wrapAnthropicError(err)}
			return
		}

		chunks <- Chunk{
			Model:        string(message.Model),
			FinishReason: a.mapStopReason(message.StopReason),
			Usage:        a.toUsageStats(message.Usage),
		}
	}()

	return chunks, nil
}

// textFromContentBlocks flattens Anthropic content blocks into plain text.
func (a *Anthropic) textFromContentBlocks(blocks []anthropicsdk.ContentBlockUnion) string {

	if len(blocks) == 0 {
		return ""
	}

	var builder strings.Builder
	for _, block := range blocks {
		if block.Type != "text" {
			continue
		}
		if block.Text == "" {
			continue
		}
		builder.WriteString(block.Text)
	}
	return builder.String()
}

// toUsageStats converts Anthropic usage into provider usage stats.
func (a *Anthropic) toUsageStats(usage anthropicsdk.Usage) *UsageStats {

	if usage.InputTokens == 0 && usage.OutputTokens == 0 {
		return nil
	}
	prompt := int(usage.InputTokens)
	completion := int(usage.OutputTokens)
	return &UsageStats{
		PromptTokens:     prompt,
		CompletionTokens: completion,
		TotalTokens:      prompt + completion,
	}
}

// mapStopReason normalizes Anthropic stop reasons for the provider response.
func (a *Anthropic) mapStopReason(reason anthropicsdk.StopReason) string {

	if reason == "" {
		return ""
	}
	return string(reason)
}

// newSDKClient constructs an Anthropic SDK client.
func (a *Anthropic) newSDKClient() anthropicsdk.Client {

	opts := []option.RequestOption{
		option.WithAPIKey(a.apiKey),
		option.WithHTTPClient(a.httpClient()),
	}
	if a.baseURL != "" {
		opts = append(opts, option.WithBaseURL(a.baseURL))
	}
	return anthropicsdk.NewClient(opts...)
}

// wrapAnthropicError normalizes SDK errors into APIError when possible.
func (a *Anthropic) wrapAnthropicError(err error) error {

	var apiErr *anthropicsdk.Error
	if errors.As(err, &apiErr) {
		return &providerhttp.APIError{Code: apiErr.StatusCode, Message: apiErr.Error()}
	}
	return err
}

// GenerateImage generates an image. Anthropic does not support this capability.
func (a *Anthropic) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("anthropic provider does not support image generation")
}

// EditImage returns not supported error.
func (a *Anthropic) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/providers/adapters/cloudflare/provider.go

```go
// provider.go implements the Cloudflare AI Gateway provider adapter.
// internal/features/providers/adapters/cloudflare/provider.go
package cloudflare

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"
	"strings"

	"github.com/cloudflare/cloudflare-go"
	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/providerhttp"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type ProviderCredentials = providercore.ProviderCredentials
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client
type Logger = coreports.Logger
type LogField = coreports.LogField

const (
	CredentialAccountID       = providercore.CredentialAccountID
	CredentialGatewayID       = providercore.CredentialGatewayID
	CredentialCloudflareToken = providercore.CredentialCloudflareToken
	CredentialAPIKey          = providercore.CredentialAPIKey
	CredentialToken           = providercore.CredentialToken
)

// Cloudflare implements the Provider interface for Cloudflare AI Gateway.
type Cloudflare struct {
	name            string
	displayName     string
	baseURL         string
	accountID       string
	gatewayID       string
	upstreamAPIKey  string
	cloudflareToken string
	gatewayToken    string
	logger          Logger
	models          []Model
	client          HTTPClient
}

var _ Provider = (*Cloudflare)(nil)

// New creates a new Cloudflare provider.
func New(config Config) *Cloudflare {

	provider := &Cloudflare{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     config.BaseURL,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
	_ = provider.Configure(config)
	return provider
}

// Name returns the provider identifier.
func (c *Cloudflare) Name() string {

	return c.name
}

// DisplayName returns the human-readable provider name.
func (c *Cloudflare) DisplayName() string {

	return c.displayName
}

// Models returns the available models.
func (c *Cloudflare) Models() []Model {

	return c.models
}

// CredentialFields returns the expected credential inputs.
func (c *Cloudflare) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:        CredentialAccountID,
			Label:       "Account ID",
			Required:    true,
			Secret:      false,
			Placeholder: "Cloudflare account ID",
			Help:        "The Cloudflare account identifier that owns the AI Gateway.",
		},
		{
			Name:        CredentialGatewayID,
			Label:       "Gateway ID",
			Required:    true,
			Secret:      false,
			Placeholder: "AI Gateway ID",
			Help:        "The gateway identifier from your Cloudflare AI Gateway settings.",
		},
		{
			Name:        CredentialCloudflareToken,
			Label:       "Cloudflare API Token",
			Required:    false,
			Secret:      true,
			Placeholder: "Cloudflare API token",
			Help:        "Required for Cloudflare-hosted Workers AI models (for example @cf/...).",
		},
		{
			Name:        CredentialAPIKey,
			Label:       "Upstream API Key (optional)",
			Required:    false,
			Secret:      true,
			Placeholder: "Provider API key",
			Help:        "Required for non-Workers AI models (for example openai/... or anthropic/...).",
		},
		{
			Name:        CredentialToken,
			Label:       "Gateway Auth Token (optional)",
			Required:    false,
			Secret:      true,
			Placeholder: "AI Gateway token",
			Help:        "Optional token for Cloudflare AI Gateway authentication (cf-aig-authorization).",
		},
	}
}

// Configure updates the provider configuration.
func (c *Cloudflare) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAccountID]; ok {
			c.accountID = strings.TrimSpace(value)
		}
		if value, ok := config.Credentials[CredentialCloudflareToken]; ok {
			c.cloudflareToken = strings.TrimSpace(value)
		}
	}
	if config.BaseURL != "" {
		c.baseURL = config.BaseURL
	}
	if config.Models != nil {
		c.models = config.Models
	}
	if config.Logger != nil {
		c.logger = config.Logger
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (c *Cloudflare) SetHTTPClient(client HTTPClient) {

	if client != nil {
		c.client = client
	}
}

// SetLogger sets the logger used for debug output.
func (c *Cloudflare) SetLogger(logger Logger) {

	if logger != nil {
		c.logger = logger
	}
}

// httpClient returns the configured HTTP client or a default client.
func (c *Cloudflare) httpClient() HTTPClient {

	if c.client == nil {
		c.client = providerhttp.NewDefaultClient()
	}
	return c.client
}

// newSDKClient creates a new Cloudflare SDK client.
func (c *Cloudflare) newSDKClient() (*cloudflare.API, error) {
	// Cloudflare SDK requires API Token.
	token := c.cloudflareToken
	if token == "" {
		return nil, fmt.Errorf("cloudflare API token required for SDK usage")
	}

	// Create client
	api, err := cloudflare.NewWithAPIToken(token)
	if err != nil {
		return nil, err
	}
	
	if c.client != nil {
		// propagate client if feasible, but SDK v0.116 doesn't easily expose it via NewWithAPIToken
	}
	
	return api, nil
}

// TestConnection verifies the API is reachable.
func (c *Cloudflare) TestConnection(ctx context.Context) error {
	// Simple validation
	if c.accountID == "" || c.cloudflareToken == "" {
		return fmt.Errorf("account ID and Cloudflare token required")
	}
	return nil
}

// ListResources fetches the available models.
func (c *Cloudflare) ListResources(ctx context.Context) ([]Model, error) {

	// SDK List logic using api.Raw
	api, err := c.newSDKClient()
	if err != nil {
		return nil, err
	}
	if c.accountID == "" {
		return nil, fmt.Errorf("account ID required for listing models")
	}

	// Try to list text generation models via generic search endpoint if available, 
	// or assume standard models. Since SDK doesn't expose ListWorkersAIModels, 
	// and we removed legacy, we attempt `GET accounts/{id}/ai/models/search` 
	// which is the common endpoint.
	
	endpoint := fmt.Sprintf("accounts/%s/ai/models/search", c.accountID)
	// Some docs say `/ai/models/search`, others just `/ai/models`.
	// We'll try one. If it fails, we return error (strict no legacy).
	
	res, err := api.Raw(ctx, "GET", endpoint, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to list models via SDK: %w", err)
	}
	
	if !res.Success {
		return nil, fmt.Errorf("failed to list models: active success=false in response")
	}

	// Response structure for models search
	var listRes struct {
		Result []struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Task        struct {
				Name string `json:"name"`
			} `json:"task"`
		} `json:"result"`
	}
	
	if err := json.Unmarshal(res.Result, &listRes); err != nil {
		// fall back to empty list if parsing fails? Or strict error?
		return nil, fmt.Errorf("failed to parse models list: %w", err)
	}

	var models []Model
	seen := make(map[string]struct{})
	
	for _, m := range listRes.Result {
		// Filter for text generation or image models if desired?
		// For now, include all or just Text Generation.
		// "Text Generation" task name usually.
		if m.Task.Name == "Text Generation" || m.Task.Name == "Text-to-Image" {
			id := "@cf/" + m.Name
			if !strings.HasPrefix(m.Name, "@cf/") {
				// usually name is full like "meta/llama-2-7b-chat-int8" ? 
				// The API returns name like "meta/llama-2-7b-chat-int8".
				// Workers AI requires "@cf/" prefix often, or just name? 
				// SDK examples often show "@cf/meta/llama..."
				id = "@cf/" + m.Name
			}
			
			if _, ok := seen[id]; !ok {
				models = append(models, Model{
					ID:   id,
					Name: m.Name,
				})
				seen[id] = struct{}{}
			}
		}
	}
	
	if len(models) > 0 {
		sort.Slice(models, func(i, j int) bool {
			return models[i].ID < models[j].ID
		})
	}
	return models, nil
}

// Chat implements streaming chat completion.
func (c *Cloudflare) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	// Strict SDK / Workers AI logic
	if c.accountID == "" {
		return nil, fmt.Errorf("account ID required")
	}
	
	model := resolveModelName(opts.Model)

	api, err := c.newSDKClient()
	if err != nil {
		return nil, err
	}
	
	endpoint := fmt.Sprintf("accounts/%s/ai/run/%s", c.accountID, model)
	
	reqBody := map[string]interface{}{}
	sdkMessages := make([]map[string]string, 0, len(messages))
	for _, msg := range messages {
		if strings.TrimSpace(msg.Content) == "" {
			continue
		}
		sdkMessages = append(sdkMessages, map[string]string{
			"role":    string(msg.Role),
			"content": msg.Content,
		})
	}
	reqBody["messages"] = sdkMessages
	reqBody["max_tokens"] = opts.MaxTokens
	
	if opts.Stream {
		// SDK api.Raw does not support streaming (buffers response).
		// Per user instruction "Remove legacy", we cannot fallback to manual HTTP.
		// We return error for streaming requests.
		return nil, fmt.Errorf("streaming not supported with current SDK integration")
	}

	// Non-streaming via SDK Raw
	res, err := api.Raw(ctx, "POST", endpoint, reqBody, nil)
	if err != nil {
		return nil, err
	}
	
	if !res.Success {
		if len(res.Errors) > 0 {
			return nil, fmt.Errorf("ai error: %s", res.Errors[0].Message)
		}
		return nil, fmt.Errorf("ai request failed")
	}

	var aiRes struct {
		Response string `json:"response"`
	}
	if err := json.Unmarshal(res.Result, &aiRes); err != nil {
		return nil, fmt.Errorf("failed to parse AI response: %w", err)
	}
	
	chunks := make(chan Chunk, 1)
	chunks <- Chunk{
		Content: aiRes.Response,
	}
	close(chunks)
	return chunks, nil
}

// resolveModelName normalizes model names for Workers AI.
func resolveModelName(model string) string {
	model = strings.TrimSpace(model)
	// Ensure @cf prefix if missing and looks like it needs one?
	// or assume input is correct.
	// Common convention: "llama-2..." -> "@cf/meta/llama-2..."
	// But we can't guess vendor.
	// If it doesn't start with @cf/, we assume user provided full path or we fail?
	// Let's assume input is raw ID.
	return model
}

// logDebug writes debug output if a logger is configured.
func (c *Cloudflare) logDebug(message string, fields ...LogField) {

	if c.logger == nil {
		return
	}
	c.logger.Debug(message, fields...)
}

// isWorkersAIBaseURL reports whether the base URL targets Workers AI directly.
func isWorkersAIBaseURL(baseURL string) bool {
	return strings.Contains(strings.ToLower(baseURL), "/workers-ai/")
}

// GenerateImage generates an image. Cloudflare Workers AI supports this, but implementation is pending specific model support verification.
func (c *Cloudflare) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	// SDK's api.Raw() expects JSON response, but Image Gen returns binary (PNG).
	// Cannot use SDK's Raw method for this as it tries to parse JSON.
	return nil, fmt.Errorf("cloudflare provider image generation not yet implemented via SDK")
}

// EditImage returns not supported error.
func (c *Cloudflare) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/providers/adapters/gemini/provider.go

```go
// provider.go implements the Gemini provider adapter.
// internal/features/providers/adapters/gemini/provider.go
package gemini

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"

	"google.golang.org/genai"
	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/providerhttp"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey = providercore.CredentialAPIKey
	RoleAssistant    = providergateway.RoleAssistant
)

// Gemini implements the Provider interface for Google's Gemini API.
type Gemini struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*Gemini)(nil)

// New creates a new Gemini provider.
func New(config Config) *Gemini {

	baseURL := config.BaseURL
	// The SDK handles default base URL. Only set if explicitly provided?
	// Actually, SDK config might need it.

	return &Gemini{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (g *Gemini) Name() string {
	return g.name
}

// DisplayName returns the human-readable provider name.
func (g *Gemini) DisplayName() string {
	return g.displayName
}

// Models returns the available models.
func (g *Gemini) Models() []Model {
	return g.models
}

// CredentialFields returns the expected credential inputs.
func (g *Gemini) CredentialFields() []CredentialField {
	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (g *Gemini) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			g.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		g.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		g.baseURL = config.BaseURL
	}
	if config.Models != nil {
		g.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (g *Gemini) SetHTTPClient(client HTTPClient) {

	if client != nil {
		g.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (g *Gemini) httpClient() HTTPClient {

	if g.client == nil {
		g.client = providerhttp.NewDefaultClient()
	}
	return g.client
}

// newSDKClient creates a new Gemini SDK client.
func (g *Gemini) newSDKClient(ctx context.Context) (*genai.Client, error) {
	opts := &genai.ClientConfig{
		APIKey: g.apiKey,
	}
	// If base URL is custom, check if genai client supports it.
	// Looking at typical genai patterns, it's often implicit.
	// We'll trust the default unless we find a way to set it in ClientConfig if needed.
	// NOTE: google.golang.org/genai might not expose BaseURL directly in config, 
	// but let's assume standard behavior or skip if not needed for migration.
	
	if g.client != nil {
		if client, ok := g.client.(*http.Client); ok {
			opts.HTTPClient = client
		}
	}

	return genai.NewClient(ctx, opts)
}

// TestConnection verifies the Gemini API is reachable.
func (g *Gemini) TestConnection(ctx context.Context) error {

	url := fmt.Sprintf("%s/models?key=%s", g.baseURL, g.apiKey)
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return err
	}

	resp, err := g.httpClient().Do(req)
	if err != nil {
		return err
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return &providerhttp.APIError{Code: resp.StatusCode, Message: string(body)}
	}

	return nil
}

// ListResources fetches the available models from the Gemini API.
func (g *Gemini) ListResources(ctx context.Context) ([]Model, error) {
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, err
	}

	pager, err := client.Models.List(ctx, nil)
	if err != nil {
		return nil, err
	}
	// Supports Go 1.23 iterator? The error said `assignment mismatch`.
	// Most likely `List` returns `*genai.ModelListIterator`.
	// If it handles standard iterator:
	
	models := make([]Model, 0)
	for _, item := range pager.Items {
		
		name := item.DisplayName
		if name == "" {
			name = item.Name // fallback
		}
		
		id := strings.TrimPrefix(item.Name, "models/")

		models = append(models, Model{
			ID:   id,
			Name: name,
		})
	}
	
	sort.Slice(models, func(i, j int) bool {
		return models[i].Name < models[j].Name
	})

	return models, nil
}

// Chat implements streaming chat completion for Gemini.
func (g *Gemini) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, err
	}

	sdkParts := make([]*genai.Content, 0, len(messages))
	for _, msg := range messages {
		if strings.TrimSpace(msg.Content) == "" {
			continue
		}
		role := "user"
		if msg.Role == RoleAssistant {
			role = "model"
		}
		sdkParts = append(sdkParts, &genai.Content{
			Role: role,
			Parts: []*genai.Part{
				{Text: msg.Content},
			},
		})
	}

	config := &genai.GenerateContentConfig{
		Temperature:     g.float32Ptr(opts.Temperature),
		MaxOutputTokens: int32(opts.MaxTokens),
	}

	modelID := opts.Model
	
	if opts.Stream {
		stream := client.Models.GenerateContentStream(ctx, modelID, sdkParts, config)
		chunks := make(chan Chunk, 100)
		go func() {
			defer close(chunks)
			// Go 1.23 iterator loop
			for resp, err := range stream {
				if err != nil {
					chunks <- Chunk{Error: err}
					return
				}
				
				// Process chunk
				for _, cand := range resp.Candidates {
					text := ""
					for _, part := range cand.Content.Parts {
						text += part.Text
					}
					chunk := Chunk{
						Content:      text,
						FinishReason: "", 
					}
					if resp.UsageMetadata != nil {
						chunk.Usage = &UsageStats{
							PromptTokens:     int(resp.UsageMetadata.PromptTokenCount),
							CompletionTokens: int(resp.UsageMetadata.CandidatesTokenCount),
							TotalTokens:      int(resp.UsageMetadata.TotalTokenCount),
						}
					}
					chunks <- chunk
				}
			}
		}()
		return chunks, nil
	}

	// Non-streaming
	resp, err := client.Models.GenerateContent(ctx, modelID, sdkParts, config)
	if err != nil {
		return nil, err
	}
	
	chunks := make(chan Chunk, 1)
	go func() {
		defer close(chunks)
		for _, cand := range resp.Candidates {
			text := ""
			for _, part := range cand.Content.Parts {
				text += part.Text
			}
			chunk := Chunk{
				Content:      text,
				FinishReason: "",
			}
			if resp.UsageMetadata != nil {
				chunk.Usage = &UsageStats{
					PromptTokens:     int(resp.UsageMetadata.PromptTokenCount),
					CompletionTokens: int(resp.UsageMetadata.CandidatesTokenCount),
					TotalTokens:      int(resp.UsageMetadata.TotalTokenCount),
				}
			}
			chunks <- chunk
		}
	}()
	return chunks, nil
}

func (g *Gemini) float32Ptr(v float64) *float32 {
	if v == 0 {
		return nil
	}
	val := float32(v)
	return &val
}





// GenerateImage generates an image using the Gemini/Imagen predict API.
func (g *Gemini) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {

	// Default to a known Imagen model if not specified.
	model := opts.Model
	if model == "" {
		model = "imagen-4.0-generate-001"
	}

	// Gemini models (gemini-2.5-flash-image, etc.) use the GenerateContent API (multimodal).
	if strings.HasPrefix(model, "gemini") {
		return g.generateContentImage(ctx, model, opts)
	}

	// Use genai library for Imagen models (Imagen 3/4)
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create SDK client: %w", err)
	}

	cfg := &genai.GenerateImagesConfig{
		NumberOfImages: int32(opts.N),
	}
	if cfg.NumberOfImages == 0 {
		cfg.NumberOfImages = 1
	}

	// Aspect Ratio mapping
	if opts.Size == "1024x1024" || opts.Size == "1:1" {
		cfg.AspectRatio = "1:1"
	} else if opts.Size == "16:9" {
		cfg.AspectRatio = "16:9"
	} else if opts.Size == "9:16" {
		cfg.AspectRatio = "9:16"
	} else if opts.Size == "3:4" {
		cfg.AspectRatio = "3:4"
	} else if opts.Size == "4:3" {
		cfg.AspectRatio = "4:3"
	}

	resp, err := client.Models.GenerateImages(ctx, opts.Model, opts.Prompt, cfg)
	if err != nil {
		return nil, fmt.Errorf("genai generate images failed: %w", err)
	}

	result := &providergateway.ImageResult{
		// Data: make([]providergateway.ImageData, len(resp.GeneratedImages)),
		Data: make([]providergateway.ImageData, 0),
	}

	for _, img := range resp.GeneratedImages {
		result.Data = append(result.Data, providergateway.ImageData{
			B64JSON: base64.StdEncoding.EncodeToString(img.Image.ImageBytes),
		})
	}

	return result, nil
}

// generateContentImage handles image generation for Gemini models via the GenerateContent API.
func (g *Gemini) generateContentImage(ctx context.Context, model string, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, err
	}

	// Construct content parts
	parts := []*genai.Part{
		{Text: opts.Prompt},
	}

	// Config
	// Note: Gemini models typically produce 1 image per request via GenerateContent defaults or strict configs.
	// The Go SDK might not expose explicit image count in GenerateContentConfig effectively for all models yet,
	// checking genai.GenerateContentConfig...
	config := &genai.GenerateContentConfig{
		// Temperature, etc. might apply.
		// For image generation, response MimeType might be specified?
	}

	resp, err := client.Models.GenerateContent(ctx, model, []*genai.Content{{Parts: parts}}, config)
	if err != nil {
		return nil, fmt.Errorf("generate content failed: %w", err)
	}

	if len(resp.Candidates) == 0 {
		return nil, fmt.Errorf("no candidates returned")
	}

	result := &providergateway.ImageResult{
		Data: make([]providergateway.ImageData, 0),
	}

	for _, cand := range resp.Candidates {
		for _, part := range cand.Content.Parts {
			if part.InlineData != nil {
				result.Data = append(result.Data, providergateway.ImageData{
					B64JSON: base64.StdEncoding.EncodeToString(part.InlineData.Data),
				})
			} else if part.FileData != nil {
				// URI based
				result.Data = append(result.Data, providergateway.ImageData{
					URL: part.FileData.FileURI,
				})
			}
		}
	}

	if len(result.Data) == 0 {
		return nil, fmt.Errorf("no image data found in response")
	}

	return result, nil
}

// EditImage edits an image using the Gemini/Imagen predict API.
func (g *Gemini) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {

	// Logic for imagen-3.0-capability-image-editing-001 or newer equivalents
	// Currently Imagen 4+ via genai SDK does not expose EditImage/Masking directly in the public docs provided.
	// We will attempt to use the genai client if possible, but standard 'GenerateImages' is text-to-image.
	
	return nil, fmt.Errorf("image editing is not currently supported by the genai library for Imagen 4 models (Text-to-Image only). Please use 'generate image' without an input image.")
}

// loadInputImage reads image from file path or returns error.
func loadInputImage(input string) ([]byte, error) {
	// Simple check: is it a file that exists?
	// If not, is it valid base64?
	
	// Try reading file first
	data, err := os.ReadFile(input)
	if err == nil {
		return data, nil
	}
	
	// If read file fails, maybe it is base64?
	decoded, err := base64.StdEncoding.DecodeString(input)
	if err == nil {
		return decoded, nil
	}
	
	return nil, fmt.Errorf("input is neither a valid file path nor base64 string")
}


```


--| internal/features/providers/adapters/grok/provider.go

```go
// provider.go implements the Grok (xAI) provider adapter.
// internal/features/providers/adapters/grok/provider.go
package grok

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/providerhttp"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
	openaisdk "github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey = providercore.CredentialAPIKey
	RoleUser         = providergateway.RoleUser
	RoleAssistant    = providergateway.RoleAssistant
	RoleSystem       = providergateway.RoleSystem
)

// Grok implements the Provider interface for xAI.
type Grok struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*Grok)(nil)

// New creates a new Grok provider.
func New(config Config) *Grok {
	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = "https://api.x.ai/v1"
	}

	return &Grok{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (g *Grok) Name() string {
	return g.name
}

// DisplayName returns the human-readable provider name.
func (g *Grok) DisplayName() string {
	return g.displayName
}

// Models returns the available models.
func (g *Grok) Models() []Model {
	return g.models
}

// CredentialFields returns the expected credential inputs.
func (g *Grok) CredentialFields() []CredentialField {
	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (g *Grok) Configure(config Config) error {
	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			g.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		g.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		g.baseURL = config.BaseURL
	}
	if config.Models != nil {
		g.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (g *Grok) SetHTTPClient(client HTTPClient) {
	if client != nil {
		g.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (g *Grok) httpClient() HTTPClient {
	if g.client == nil {
		g.client = providerhttp.NewDefaultClient()
	}
	return g.client
}

// TestConnection verifies the API is reachable.
func (g *Grok) TestConnection(ctx context.Context) error {
	return g.testConnectionSDK(ctx)
}

// ListResources fetches the available models.
func (g *Grok) ListResources(ctx context.Context) ([]Model, error) {
	return g.listResourcesSDK(ctx)
}

// Chat implements streaming chat completion.
func (g *Grok) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {
	return g.chatSDK(ctx, messages, opts)
}

// GenerateImage generates an image using the OpenAI SDK (xAI compatible).
func (g *Grok) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	// xAI doesn't currently support image generation via this endpoint publicly documented as identical to OpenAI's DALL-E,
	// but the user requested it. We will assume compatibility or return error if it fails.
	// Actually, Grok 2 has image generation capabilities. It might be via the same /images/generations endpoint.
	
	client := g.newSDKClient()
	params := openaisdk.ImageGenerateParams{
		Prompt: opts.Prompt,
		Model:  openaisdk.ImageModel(opts.Model),
	}

	if opts.N > 0 {
		params.N = openaisdk.Int(int64(opts.N))
	}
	if opts.Size != "" {
		params.Size = openaisdk.ImageGenerateParamsSize(opts.Size)
	}
	if opts.Quality != "" {
		params.Quality = openaisdk.ImageGenerateParamsQuality(opts.Quality)
	}
	if opts.Style != "" {
		params.Style = openaisdk.ImageGenerateParamsStyle(opts.Style)
	}
	if opts.ResponseFormat != "" {
		params.ResponseFormat = openaisdk.ImageGenerateParamsResponseFormat(opts.ResponseFormat)
	}
	if opts.User != "" {
		params.User = openaisdk.String(opts.User)
	}

	resp, err := client.Images.Generate(ctx, params)
	if err != nil {
		return nil, g.wrapOpenAIError(err)
	}

	result := &providergateway.ImageResult{
		Created: resp.Created,
		Data:    make([]providergateway.ImageData, len(resp.Data)),
	}

	for i, d := range resp.Data {
		result.Data[i] = providergateway.ImageData{
			URL:           d.URL,
			B64JSON:       d.B64JSON,
			RevisedPrompt: d.RevisedPrompt,
		}
	}

	return result, nil
}

// normalizeBaseURL ensures the base URL ends with a slash.
func (g *Grok) normalizeBaseURL() string {
	baseURL := strings.TrimSpace(g.baseURL)
	if baseURL == "" {
		return baseURL
	}
	if !strings.HasSuffix(baseURL, "/") {
		baseURL += "/"
	}
	return baseURL
}

// newSDKClient constructs an OpenAI SDK client pointed at xAI.
func (g *Grok) newSDKClient() openaisdk.Client {
	opts := []option.RequestOption{
		option.WithAPIKey(g.apiKey),
		option.WithBaseURL(g.normalizeBaseURL()),
	}
	return openaisdk.NewClient(opts...)
}

// testConnectionSDK validates connectivity.
func (g *Grok) testConnectionSDK(ctx context.Context) error {
	client := g.newSDKClient()
	_, err := client.Models.List(ctx)
	if err != nil {
		return g.wrapOpenAIError(err)
	}
	return nil
}

// listResourcesSDK lists models.
func (g *Grok) listResourcesSDK(ctx context.Context) ([]Model, error) {
	client := g.newSDKClient()
	page, err := client.Models.List(ctx)
	if err != nil {
		return nil, g.wrapOpenAIError(err)
	}

	models := make([]Model, 0, len(page.Data))
	for _, item := range page.Data {
		if item.ID == "" {
			continue
		}
		// Basic filter or simply list all
		models = append(models, Model{
			ID:   item.ID,
			Name: item.ID,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// chatSDK executes chat requests.
func (g *Grok) chatSDK(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {
	client := g.newSDKClient()
	params := openaisdk.ChatCompletionNewParams{
		Model:    openaisdk.ChatModel(opts.Model),
		Messages: g.toSDKMessages(messages),
	}
	
	if opts.Temperature > 0 {
		params.Temperature = openaisdk.Float(opts.Temperature)
	}
	if opts.MaxTokens > 0 {
		params.MaxTokens = openaisdk.Int(int64(opts.MaxTokens))
	}
	if opts.Stream {
		params.StreamOptions = openaisdk.ChatCompletionStreamOptionsParam{
			IncludeUsage: openaisdk.Bool(true),
		}
	}

	if !opts.Stream {
		resp, err := client.Chat.Completions.New(ctx, params)
		if err != nil {
			return nil, g.wrapOpenAIError(err)
		}
		chunks := make(chan Chunk, 1)
		go func() {
			defer close(chunks)
			if len(resp.Choices) == 0 {
				return
			}
			choice := resp.Choices[0]
			chunk := Chunk{
				Content:      choice.Message.Content,
				FinishReason: choice.FinishReason,
				Usage:        g.toUsageStats(resp.Usage),
			}
			chunks <- chunk
		}()
		return chunks, nil
	}

	stream := client.Chat.Completions.NewStreaming(ctx, params)
	chunks := make(chan Chunk, 100)
	go func() {
		defer close(chunks)
		defer func() { _ = stream.Close() }()

		for stream.Next() {
			cur := stream.Current()
			usage := g.toUsageStatsFromChunk(cur)
			content := ""
			finishReason := ""

			if len(cur.Choices) > 0 {
				choice := cur.Choices[0]
				content = choice.Delta.Content
				finishReason = choice.FinishReason
			}

			if content == "" && finishReason == "" && usage == nil {
				continue
			}

			chunks <- Chunk{
				Content:      content,
				Model:        cur.Model,
				FinishReason: finishReason,
				Usage:        usage,
			}
		}

		if err := stream.Err(); err != nil {
			chunks <- Chunk{Error: g.wrapOpenAIError(err)}
		}
	}()

	return chunks, nil
}

// toSDKMessages converts chat messages to SDK message params.
func (g *Grok) toSDKMessages(messages []ProviderMessage) []openaisdk.ChatCompletionMessageParamUnion {
	result := make([]openaisdk.ChatCompletionMessageParamUnion, 0, len(messages))
	for _, msg := range messages {
		content := msg.Content
		if strings.TrimSpace(content) == "" {
			continue
		}

		switch msg.Role {
		case RoleSystem:
			result = append(result, openaisdk.SystemMessage(content))
		case RoleAssistant:
			result = append(result, openaisdk.AssistantMessage(content))
		case RoleUser:
			result = append(result, openaisdk.UserMessage(content))
		default:
			result = append(result, openaisdk.UserMessage(content))
		}
	}
	return result
}

// toUsageStats converts SDK usage to provider usage stats.
func (g *Grok) toUsageStats(usage openaisdk.CompletionUsage) *UsageStats {
	if usage.TotalTokens == 0 && usage.PromptTokens == 0 && usage.CompletionTokens == 0 {
		return nil
	}
	return &UsageStats{
		PromptTokens:     int(usage.PromptTokens),
		CompletionTokens: int(usage.CompletionTokens),
		TotalTokens:      int(usage.TotalTokens),
	}
}

// toUsageStatsFromChunk extracts usage stats from a streaming chunk.
func (g *Grok) toUsageStatsFromChunk(chunk openaisdk.ChatCompletionChunk) *UsageStats {
	if !chunk.JSON.Usage.Valid() {
		return nil
	}
	return g.toUsageStats(chunk.Usage)
}

// wrapOpenAIError normalizes SDK errors into APIError when possible.
func (g *Grok) wrapOpenAIError(err error) error {
	var apiErr *openaisdk.Error
	if errors.As(err, &apiErr) {
		message := strings.TrimSpace(apiErr.Message)
		if message == "" {
			message = strings.TrimSpace(apiErr.RawJSON())
		}
		return &providerhttp.APIError{Code: apiErr.StatusCode, Message: message}
	}
	return err
}

// GenerateImage returns not supported error (if not already implemented elsewhere, relying on interface compliance).
// ACTUALLY I need to check if GenerateImage is missing. If Gork compiles, it must have it.
// I will just append EditImage.
// EditImage returns not supported error.
func (g *Grok) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/providers/adapters/openai/provider.go

```go
// provider.go implements the OpenAI provider adapter.
// internal/features/providers/adapters/openai/provider.go
package openai

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/providerhttp"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
	openaisdk "github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey = providercore.CredentialAPIKey
	RoleUser         = providergateway.RoleUser
	RoleAssistant    = providergateway.RoleAssistant
	RoleSystem       = providergateway.RoleSystem
)

// OpenAI implements the Provider interface for OpenAI-compatible APIs.
// Works with OpenAI, Groq, and other OpenAI-compatible endpoints.
type OpenAI struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*OpenAI)(nil)

// New creates a new OpenAI provider.
func New(config Config) *OpenAI {

	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = "https://api.openai.com/v1"
	}

	return &OpenAI{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (o *OpenAI) Name() string {

	return o.name
}

// DisplayName returns the human-readable provider name.
func (o *OpenAI) DisplayName() string {

	return o.displayName
}

// Models returns the available models.
func (o *OpenAI) Models() []Model {

	return o.models
}

// CredentialFields returns the expected credential inputs.
func (o *OpenAI) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (o *OpenAI) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			o.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		o.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		o.baseURL = config.BaseURL
	}
	if config.Models != nil {
		o.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (o *OpenAI) SetHTTPClient(client HTTPClient) {

	if client != nil {
		o.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (o *OpenAI) httpClient() HTTPClient {

	if o.client == nil {
		o.client = providerhttp.NewDefaultClient()
	}
	return o.client
}

// TestConnection verifies the API is reachable.
func (o *OpenAI) TestConnection(ctx context.Context) error {

	if o.usesOpenAISDK() {
		return o.testConnectionSDK(ctx)
	}

	headers := o.authHeaders()
	_, err := providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
	return err
}

// ListResources fetches the available models from an OpenAI-compatible API.
func (o *OpenAI) ListResources(ctx context.Context) ([]Model, error) {

	if o.usesOpenAISDK() {
		return o.listResourcesSDK(ctx)
	}

	headers := o.authHeaders()
	return providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
}

// Chat implements streaming chat completion.
func (o *OpenAI) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	if o.usesOpenAISDK() {
		return o.chatSDK(ctx, messages, opts)
	}

	headers := o.authHeaders()
	return providerhttp.ChatOpenAICompat(ctx, o.httpClient(), o.baseURL, headers, messages, opts)
}

// usesOpenAISDK decides whether to use the OpenAI SDK.
func (o *OpenAI) usesOpenAISDK() bool {

	return strings.Contains(strings.ToLower(o.baseURL), "api.openai.com")
}

// authHeaders returns configured request headers.
func (o *OpenAI) authHeaders() map[string]string {

	if strings.TrimSpace(o.apiKey) == "" {
		return nil
	}
	return map[string]string{
		"Authorization": "Bearer " + o.apiKey,
	}
}

// normalizeBaseURL ensures the base URL ends with a slash.
func (o *OpenAI) normalizeBaseURL() string {

	baseURL := strings.TrimSpace(o.baseURL)
	if baseURL == "" {
		return baseURL
	}
	if !strings.HasSuffix(baseURL, "/") {
		baseURL += "/"
	}
	return baseURL
}

// newSDKClient constructs an OpenAI SDK client.
func (o *OpenAI) newSDKClient() openaisdk.Client {

	opts := []option.RequestOption{option.WithAPIKey(o.apiKey)}
	if o.baseURL != "" {
		opts = append(opts, option.WithBaseURL(o.normalizeBaseURL()))
	}
	return openaisdk.NewClient(opts...)
}

// testConnectionSDK validates connectivity using the OpenAI SDK.
func (o *OpenAI) testConnectionSDK(ctx context.Context) error {

	client := o.newSDKClient()
	_, err := client.Models.List(ctx)
	if err != nil {
		return o.wrapOpenAIError(err)
	}
	return nil
}

// listResourcesSDK lists models using the OpenAI SDK.
func (o *OpenAI) listResourcesSDK(ctx context.Context) ([]Model, error) {

	client := o.newSDKClient()
	page, err := client.Models.List(ctx)
	if err != nil {
		return nil, o.wrapOpenAIError(err)
	}

	models := make([]Model, 0, len(page.Data))
	for _, item := range page.Data {
		if item.ID == "" {
			continue
		}
		models = append(models, Model{
			ID:   item.ID,
			Name: item.ID,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// chatSDK executes chat requests with the OpenAI SDK.
func (o *OpenAI) chatSDK(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	client := o.newSDKClient()
	params := openaisdk.ChatCompletionNewParams{
		Model:    openaisdk.ChatModel(opts.Model),
		Messages: o.toSDKMessages(messages),
	}
	if opts.Temperature > 0 {
		params.Temperature = openaisdk.Float(opts.Temperature)
	}
	if opts.MaxTokens > 0 {
		params.MaxTokens = openaisdk.Int(int64(opts.MaxTokens))
	}
	if opts.Stream {
		params.StreamOptions = openaisdk.ChatCompletionStreamOptionsParam{
			IncludeUsage: openaisdk.Bool(true),
		}
	}

	if !opts.Stream {
		resp, err := client.Chat.Completions.New(ctx, params)
		if err != nil {
			return nil, o.wrapOpenAIError(err)
		}
		chunks := make(chan Chunk, 1)
		go func() {
			defer close(chunks)
			if len(resp.Choices) == 0 {
				return
			}
			choice := resp.Choices[0]
			chunk := Chunk{
				Content:      choice.Message.Content,
				FinishReason: choice.FinishReason,
				Usage:        o.toUsageStats(resp.Usage),
			}
			chunks <- chunk
		}()
		return chunks, nil
	}

	stream := client.Chat.Completions.NewStreaming(ctx, params)
	chunks := make(chan Chunk, 100)
	go func() {
		defer close(chunks)
		defer func() { _ = stream.Close() }()

		for stream.Next() {
			cur := stream.Current()
			usage := o.toUsageStatsFromChunk(cur)
			content := ""
			finishReason := ""

			if len(cur.Choices) > 0 {
				choice := cur.Choices[0]
				content = choice.Delta.Content
				finishReason = choice.FinishReason
			}

			if content == "" && finishReason == "" && usage == nil {
				continue
			}

			chunks <- Chunk{
				Content:      content,
				Model:        cur.Model,
				FinishReason: finishReason,
				Usage:        usage,
			}
		}

		if err := stream.Err(); err != nil {
			chunks <- Chunk{Error: o.wrapOpenAIError(err)}
		}
	}()

	return chunks, nil
}

// toSDKMessages converts chat messages to SDK message params.
func (o *OpenAI) toSDKMessages(messages []ProviderMessage) []openaisdk.ChatCompletionMessageParamUnion {

	result := make([]openaisdk.ChatCompletionMessageParamUnion, 0, len(messages))
	for _, msg := range messages {
		content := msg.Content
		if strings.TrimSpace(content) == "" {
			continue
		}

		switch msg.Role {
		case RoleSystem:
			result = append(result, openaisdk.SystemMessage(content))
		case RoleAssistant:
			result = append(result, openaisdk.AssistantMessage(content))
		case RoleUser:
			result = append(result, openaisdk.UserMessage(content))
		default:
			result = append(result, openaisdk.UserMessage(content))
		}
	}
	return result
}

// toUsageStats converts SDK usage to provider usage stats.
func (o *OpenAI) toUsageStats(usage openaisdk.CompletionUsage) *UsageStats {

	if usage.TotalTokens == 0 && usage.PromptTokens == 0 && usage.CompletionTokens == 0 {
		return nil
	}
	return &UsageStats{
		PromptTokens:     int(usage.PromptTokens),
		CompletionTokens: int(usage.CompletionTokens),
		TotalTokens:      int(usage.TotalTokens),
	}
}

// toUsageStatsFromChunk extracts usage stats from a streaming chunk.
func (o *OpenAI) toUsageStatsFromChunk(chunk openaisdk.ChatCompletionChunk) *UsageStats {

	if !chunk.JSON.Usage.Valid() {
		return nil
	}
	return o.toUsageStats(chunk.Usage)
}

// wrapOpenAIError normalizes SDK errors into APIError when possible.
// wrapOpenAIError normalizes SDK errors into APIError when possible.
func (o *OpenAI) wrapOpenAIError(err error) error {

	var apiErr *openaisdk.Error
	if errors.As(err, &apiErr) {
		message := strings.TrimSpace(apiErr.Message)
		if message == "" {
			message = strings.TrimSpace(apiErr.RawJSON())
		}
		return &providerhttp.APIError{Code: apiErr.StatusCode, Message: message}
	}
	return err
}

// GenerateImage generates an image using the OpenAI SDK.
func (o *OpenAI) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {

	client := o.newSDKClient()
	params := openaisdk.ImageGenerateParams{
		Prompt: opts.Prompt,
		Model:  openaisdk.ImageModel(opts.Model),
	}

	if opts.N > 0 {
		params.N = openaisdk.Int(int64(opts.N))
	}
	if opts.Size != "" {
		params.Size = openaisdk.ImageGenerateParamsSize(opts.Size)
	}
	if opts.Quality != "" {
		params.Quality = openaisdk.ImageGenerateParamsQuality(opts.Quality)
	}
	if opts.Style != "" {
		params.Style = openaisdk.ImageGenerateParamsStyle(opts.Style)
	}
	if opts.ResponseFormat != "" {
		params.ResponseFormat = openaisdk.ImageGenerateParamsResponseFormat(opts.ResponseFormat)
	}
	if opts.User != "" {
		params.User = openaisdk.String(opts.User)
	}

	resp, err := client.Images.Generate(ctx, params)
	if err != nil {
		return nil, o.wrapOpenAIError(err)
	}

	result := &providergateway.ImageResult{
		Created: resp.Created,
		Data:    make([]providergateway.ImageData, len(resp.Data)),
	}

	for i, d := range resp.Data {
		result.Data[i] = providergateway.ImageData{
			URL:           d.URL,
			B64JSON:       d.B64JSON,
			RevisedPrompt: d.RevisedPrompt,
		}
	}

	return result, nil
}

// EditImage returns not supported error.
// EditImage returns not supported error.
func (o *OpenAI) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/providers/adapters/openrouter/provider.go

```go
// provider.go implements the OpenRouter provider adapter.
// internal/features/providers/adapters/openrouter/provider.go
package openrouter

import (
	"context"
	"fmt"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/providerhttp"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey            = providercore.CredentialAPIKey
	CredentialOpenRouterReferer = providercore.CredentialOpenRouterReferer
	CredentialOpenRouterTitle   = providercore.CredentialOpenRouterTitle
)

// OpenRouter implements the Provider interface for OpenRouter.
type OpenRouter struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	referer     string
	title       string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*OpenRouter)(nil)

// New creates a new OpenRouter provider.
func New(config Config) *OpenRouter {

	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = "https://openrouter.ai/api/v1"
	}

	return &OpenRouter{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (o *OpenRouter) Name() string {

	return o.name
}

// DisplayName returns the human-readable provider name.
func (o *OpenRouter) DisplayName() string {

	return o.displayName
}

// Models returns the available models.
func (o *OpenRouter) Models() []Model {

	return o.models
}

// CredentialFields returns the expected credential inputs.
func (o *OpenRouter) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
		{
			Name:        CredentialOpenRouterReferer,
			Label:       "HTTP Referer (optional)",
			Required:    false,
			Secret:      false,
			Placeholder: "https://your-app.example",
			Help:        "Optional HTTP-Referer header used for OpenRouter analytics.",
		},
		{
			Name:        CredentialOpenRouterTitle,
			Label:       "App Title (optional)",
			Required:    false,
			Secret:      false,
			Placeholder: "Wails Chatbot",
			Help:        "Optional X-Title header used for OpenRouter analytics.",
		},
	}
}

// Configure updates the provider configuration.
func (o *OpenRouter) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			o.apiKey = strings.TrimSpace(value)
		}
		if value, ok := config.Credentials[CredentialOpenRouterReferer]; ok {
			o.referer = strings.TrimSpace(value)
		}
		if value, ok := config.Credentials[CredentialOpenRouterTitle]; ok {
			o.title = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		o.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		o.baseURL = config.BaseURL
	}
	if config.Models != nil {
		o.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (o *OpenRouter) SetHTTPClient(client HTTPClient) {

	if client != nil {
		o.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (o *OpenRouter) httpClient() HTTPClient {

	if o.client == nil {
		o.client = providerhttp.NewDefaultClient()
	}
	return o.client
}

// TestConnection verifies the API is reachable.
func (o *OpenRouter) TestConnection(ctx context.Context) error {

	headers := o.authHeaders()
	_, err := providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
	return err
}

// ListResources fetches the available models from OpenRouter.
func (o *OpenRouter) ListResources(ctx context.Context) ([]Model, error) {

	headers := o.authHeaders()
	return providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
}

// Chat implements streaming chat completion.
func (o *OpenRouter) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	headers := o.authHeaders()
	return providerhttp.ChatOpenAICompat(ctx, o.httpClient(), o.baseURL, headers, messages, opts)
}

func (o *OpenRouter) authHeaders() map[string]string {

	headers := make(map[string]string)
	if strings.TrimSpace(o.apiKey) != "" {
		headers["Authorization"] = "Bearer " + strings.TrimSpace(o.apiKey)
	}
	if strings.TrimSpace(o.referer) != "" {
		headers["HTTP-Referer"] = strings.TrimSpace(o.referer)
	}
	if strings.TrimSpace(o.title) != "" {
		headers["X-Title"] = strings.TrimSpace(o.title)
	}
	if len(headers) == 0 {
		return nil
	}
	return headers
}

// GenerateImage generates an image. OpenRouter does not support this capability.
func (o *OpenRouter) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("openrouter provider does not support image generation")
}

// EditImage returns not supported error.
func (o *OpenRouter) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/providers/core/cache/sqlite.go

```go
// sqlite.go persists provider resource caches in SQLite.
// internal/features/providers/core/cache/sqlite.go
package cache

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
)

const providerCacheSchema = `
CREATE TABLE IF NOT EXISTS provider_cache (
	id INTEGER PRIMARY KEY CHECK (id = 1),
	cache_json TEXT NOT NULL,
	updated_at INTEGER NOT NULL
);`

// SQLiteStore manages provider cache persistence in SQLite.
type SQLiteStore struct {
	db *sql.DB
}

// NewSQLiteStore creates a SQLite-backed cache store.
func NewSQLiteStore(db *sql.DB) (*SQLiteStore, error) {

	if db == nil {
		return nil, fmt.Errorf("provider cache: db required")
	}

	if _, err := db.Exec(providerCacheSchema); err != nil {
		return nil, fmt.Errorf("provider cache: ensure schema: %w", err)
	}

	return &SQLiteStore{db: db}, nil
}

var _ providercore.ProviderCache = (*SQLiteStore)(nil)

// Load retrieves the cached resources.
func (s *SQLiteStore) Load() (providercore.ProviderCacheSnapshot, error) {

	if s == nil || s.db == nil {
		return nil, fmt.Errorf("provider cache: db required")
	}

	row := s.db.QueryRow("SELECT cache_json FROM provider_cache WHERE id = 1")
	var data string
	if err := row.Scan(&data); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return make(providercore.ProviderCacheSnapshot), nil
		}
		return nil, fmt.Errorf("provider cache: load: %w", err)
	}

	var snapshot providercore.ProviderCacheSnapshot
	if err := json.Unmarshal([]byte(data), &snapshot); err != nil {
		return nil, fmt.Errorf("provider cache: decode: %w", err)
	}
	if snapshot == nil {
		snapshot = make(providercore.ProviderCacheSnapshot)
	}
	return snapshot, nil
}

// Save persists the resources to the cache store.
func (s *SQLiteStore) Save(snapshot providercore.ProviderCacheSnapshot) error {

	if s == nil || s.db == nil {
		return fmt.Errorf("provider cache: db required")
	}

	if snapshot == nil {
		snapshot = make(providercore.ProviderCacheSnapshot)
	}

	data, err := json.Marshal(snapshot)
	if err != nil {
		return fmt.Errorf("provider cache: encode: %w", err)
	}

	now := time.Now().UnixMilli()
	_, err = s.db.Exec(
		`INSERT INTO provider_cache (id, cache_json, updated_at)
		 VALUES (1, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		  cache_json = excluded.cache_json,
		  updated_at = excluded.updated_at`,
		string(data),
		now,
	)
	if err != nil {
		return fmt.Errorf("provider cache: save: %w", err)
	}

	return nil
}

```


--| internal/features/providers/core/configstore/sqlite.go

```go
// sqlite.go persists app configuration in SQLite.
// internal/features/providers/core/configstore/sqlite.go
package configstore

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/MadeByDoug/wls-chatbot/internal/features/settings/config"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
)

const appConfigSchema = `
CREATE TABLE IF NOT EXISTS app_config (
	id INTEGER PRIMARY KEY CHECK (id = 1),
	config_json TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL
);`

// SQLiteStore persists application configuration in SQLite.
type SQLiteStore struct {
	db *sql.DB
}

// NewSQLiteStore creates a SQLite-backed configuration store.
func NewSQLiteStore(db *sql.DB) (*SQLiteStore, error) {

	if db == nil {
		return nil, fmt.Errorf("config store: db required")
	}

	if _, err := db.Exec(appConfigSchema); err != nil {
		return nil, fmt.Errorf("config store: ensure schema: %w", err)
	}

	return &SQLiteStore{db: db}, nil
}

var _ config.Store = (*SQLiteStore)(nil)
var _ providercore.ProviderInputsStore = (*SQLiteStore)(nil)

// Load returns the stored application configuration.
func (s *SQLiteStore) Load() (config.AppConfig, error) {

	if s == nil || s.db == nil {
		return config.AppConfig{}, fmt.Errorf("config store: db required")
	}

	row := s.db.QueryRow("SELECT config_json FROM app_config WHERE id = 1")
	var data string
	if err := row.Scan(&data); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return config.AppConfig{}, config.ErrConfigNotFound
		}
		return config.AppConfig{}, fmt.Errorf("config store: load: %w", err)
	}

	var cfg config.AppConfig
	if err := json.Unmarshal([]byte(data), &cfg); err != nil {
		return config.AppConfig{}, fmt.Errorf("config store: decode: %w", err)
	}

	return cfg, nil
}

// Save writes the application configuration to the store.
func (s *SQLiteStore) Save(cfg config.AppConfig) error {

	if s == nil || s.db == nil {
		return fmt.Errorf("config store: db required")
	}

	data, err := json.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("config store: encode: %w", err)
	}

	now := time.Now().UnixMilli()
	_, err = s.db.Exec(
		`INSERT INTO app_config (id, config_json, created_at, updated_at)
		 VALUES (1, ?, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		  config_json = excluded.config_json,
		  updated_at = excluded.updated_at`,
		string(data),
		now,
		now,
	)
	if err != nil {
		return fmt.Errorf("config store: save: %w", err)
	}

	return nil
}

// LoadProviderInputs returns stored input values for a provider.
func (s *SQLiteStore) LoadProviderInputs(providerName string) (map[string]string, error) {

	cfg, err := s.Load()
	if err != nil {
		return nil, err
	}

	for i := range cfg.Providers {
		if cfg.Providers[i].Name == providerName {
			return cloneInputs(cfg.Providers[i].Inputs), nil
		}
	}

	return nil, fmt.Errorf("config store: provider not found: %s", providerName)
}

// SaveProviderInputs persists input values for a provider.
func (s *SQLiteStore) SaveProviderInputs(providerName string, inputs map[string]string) error {

	cfg, err := s.Load()
	if err != nil {
		return err
	}

	found := false
	for i := range cfg.Providers {
		if cfg.Providers[i].Name == providerName {
			cfg.Providers[i].Inputs = cloneInputs(inputs)
			found = true
			break
		}
	}

	if !found {
		return fmt.Errorf("config store: provider not found: %s", providerName)
	}

	return s.Save(cfg)
}

// cloneInputs copies provider input values into a new map.
func cloneInputs(inputs map[string]string) map[string]string {

	if len(inputs) == 0 {
		return nil
	}
	clone := make(map[string]string, len(inputs))
	for key, value := range inputs {
		clone[key] = value
	}
	return clone
}

```


--| internal/features/providers/core/providerhttp/api_error.go

```go
// api_error.go defines HTTP API error types for provider adapters.
// internal/features/providers/core/providerhttp/api_error.go
package providerhttp

import "fmt"

// APIError represents an HTTP API error with a status code.
type APIError struct {
	Code    int
	Message string
}

// Error formats the API error for display.
func (e *APIError) Error() string {

	if e == nil {
		return ""
	}
	if e.Message == "" {
		return fmt.Sprintf("API error: %d", e.Code)
	}
	return fmt.Sprintf("API error: %d - %s", e.Code, e.Message)
}

// StatusCode returns the HTTP status code for this error.
func (e *APIError) StatusCode() int {

	if e == nil {
		return 0
	}
	return e.Code
}

```


--| internal/features/providers/core/providerhttp/client.go

```go
// client.go defines HTTP client helpers for provider integrations.
// internal/features/providers/core/providerhttp/client.go
package providerhttp

import (
	"net/http"
	"time"
)

const defaultHTTPTimeout = 15 * time.Second

// Client defines the minimal HTTP client contract for providers.
type Client interface {
	Do(req *http.Request) (*http.Response, error)
}

// NewDefaultClient constructs the default HTTP client with timeouts.
func NewDefaultClient() *http.Client {

	return &http.Client{
		Timeout: defaultHTTPTimeout,
	}
}

```


--| internal/features/providers/core/providerhttp/openai_compat.go

```go
// openai_compat.go handles OpenAI-compatible HTTP flows shared by providers.
// internal/features/providers/core/providerhttp/openai_compat.go
package providerhttp

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strings"

	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

// ListOpenAICompatModels fetches models from an OpenAI-compatible API.
func ListOpenAICompatModels(ctx context.Context, client Client, baseURL string, headers map[string]string) ([]providercore.Model, error) {

	baseURL = normalizeCompatBaseURL(baseURL)
	if baseURL == "" {
		return nil, fmt.Errorf("base URL required")
	}

	req, err := http.NewRequestWithContext(ctx, "GET", baseURL+"/models", nil)
	if err != nil {
		return nil, err
	}
	setHeaders(req, headers)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{Code: resp.StatusCode, Message: string(body)}
	}

	var payload struct {
		Data []struct {
			ID string `json:"id"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		return nil, err
	}

	models := make([]providercore.Model, 0, len(payload.Data))
	for _, item := range payload.Data {
		if item.ID == "" {
			continue
		}
		models = append(models, providercore.Model{
			ID:   item.ID,
			Name: item.ID,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// ChatOpenAICompat executes OpenAI-compatible chat completion requests.
func ChatOpenAICompat(ctx context.Context, client Client, baseURL string, headers map[string]string, messages []providergateway.ProviderMessage, opts providergateway.ChatOptions) (<-chan providergateway.Chunk, error) {

	baseURL = normalizeCompatBaseURL(baseURL)
	if baseURL == "" {
		return nil, fmt.Errorf("base URL required")
	}

	body, err := MarshalOpenAICompatBody(opts.Model, messages, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", baseURL+"/chat/completions", bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	setHeaders(req, headers)

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		_ = resp.Body.Close()
		return nil, &APIError{Code: resp.StatusCode, Message: string(body)}
	}

	chunks := make(chan providergateway.Chunk, 100)

	go func() {
		defer close(chunks)
		defer func() { _ = resp.Body.Close() }()

		if opts.Stream {
			streamOpenAICompatResponse(resp.Body, chunks)
		} else {
			parseOpenAICompatResponse(resp.Body, chunks)
		}
	}()

	return chunks, nil
}

// MarshalOpenAICompatBody builds and marshals an OpenAI-compatible request body.
func MarshalOpenAICompatBody(model string, messages []providergateway.ProviderMessage, opts providergateway.ChatOptions) ([]byte, error) {

	reqBody := buildOpenAICompatBody(model, messages, opts)
	return json.Marshal(reqBody)
}

// buildOpenAICompatBody constructs an OpenAI-compatible request payload.
func buildOpenAICompatBody(model string, messages []providergateway.ProviderMessage, opts providergateway.ChatOptions) map[string]interface{} {

	apiMessages := make([]map[string]interface{}, 0, len(messages))
	for _, msg := range messages {
		content := msg.Content
		if strings.TrimSpace(content) == "" {
			continue
		}
		apiMessages = append(apiMessages, map[string]interface{}{
			"role":    string(msg.Role),
			"content": content,
		})
	}

	reqBody := map[string]interface{}{
		"model":    model,
		"messages": apiMessages,
		"stream":   opts.Stream,
	}

	if opts.Temperature > 0 {
		reqBody["temperature"] = opts.Temperature
	}
	if opts.MaxTokens > 0 {
		reqBody["max_tokens"] = opts.MaxTokens
	}

	return reqBody
}

// normalizeCompatBaseURL trims trailing slashes from OpenAI-compatible base URLs.
func normalizeCompatBaseURL(baseURL string) string {

	trimmed := strings.TrimSpace(baseURL)
	return strings.TrimRight(trimmed, "/")
}

// setHeaders adds configured headers when provided.
func setHeaders(req *http.Request, headers map[string]string) {

	if req == nil || len(headers) == 0 {
		return
	}
	for name, value := range headers {
		if strings.TrimSpace(name) == "" || strings.TrimSpace(value) == "" {
			continue
		}
		req.Header.Set(name, value)
	}
}

// streamOpenAICompatResponse parses SSE responses into chunks.
func streamOpenAICompatResponse(body io.Reader, chunks chan<- providergateway.Chunk) {

	scanner := bufio.NewScanner(body)
	scanner.Buffer(make([]byte, 0, 64*1024), 1024*1024)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "data: ") {
			continue
		}

		data := strings.TrimPrefix(line, "data: ")
		if data == "[DONE]" {
			chunks <- providergateway.Chunk{FinishReason: "stop"}
			return
		}

		var resp struct {
			Model   string `json:"model"`
			Choices []struct {
				Delta struct {
					Content string `json:"content"`
				} `json:"delta"`
				FinishReason string `json:"finish_reason"`
			} `json:"choices"`
			Usage *providergateway.UsageStats `json:"usage"`
		}

		if err := json.Unmarshal([]byte(data), &resp); err != nil {
			continue
		}

		if len(resp.Choices) > 0 {
			choice := resp.Choices[0]
			chunk := providergateway.Chunk{
				Content:      choice.Delta.Content,
				Model:        resp.Model,
				FinishReason: choice.FinishReason,
			}
			if resp.Usage != nil {
				chunk.Usage = resp.Usage
			}
			chunks <- chunk
		}
	}
	if err := scanner.Err(); err != nil {
		chunks <- providergateway.Chunk{Error: err}
	}
}

// parseOpenAICompatResponse parses a non-streaming response into a chunk.
func parseOpenAICompatResponse(body io.Reader, chunks chan<- providergateway.Chunk) {

	var resp struct {
		Choices []struct {
			Message struct {
				Content string `json:"content"`
			} `json:"message"`
			FinishReason string `json:"finish_reason"`
		} `json:"choices"`
		Usage *providergateway.UsageStats `json:"usage"`
	}

	if err := json.NewDecoder(body).Decode(&resp); err != nil {
		chunks <- providergateway.Chunk{Error: err}
		return
	}

	if len(resp.Choices) > 0 {
		choice := resp.Choices[0]
		chunks <- providergateway.Chunk{
			Content:      choice.Message.Content,
			FinishReason: choice.FinishReason,
			Usage:        resp.Usage,
		}
	}
}

```


--| internal/features/providers/core/registry/registry.go

```go
// registry.go registers and retrieves provider instances.
// internal/features/providers/core/registry/registry.go
package registry

import (
	"sync"

	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
)

// Registry manages available providers.
type Registry struct {
	mu        sync.RWMutex
	providers map[string]providercore.Provider
	active    string
	order     []string
}

// New creates a new provider registry.
func New() *Registry {

	return &Registry{
		providers: make(map[string]providercore.Provider),
	}
}

var _ providercore.ProviderRegistry = (*Registry)(nil)

// Register adds a provider to the registry.
func (r *Registry) Register(p providercore.Provider) {

	r.mu.Lock()
	defer r.mu.Unlock()
	if _, ok := r.providers[p.Name()]; !ok {
		r.order = append(r.order, p.Name())
	}
	r.providers[p.Name()] = p
}

// Get retrieves a provider by name.
func (r *Registry) Get(name string) providercore.Provider {

	r.mu.RLock()
	defer r.mu.RUnlock()
	return r.providers[name]
}

// GetActive returns the currently active provider.
func (r *Registry) GetActive() providercore.Provider {

	r.mu.RLock()
	defer r.mu.RUnlock()
	if r.active == "" {
		return nil
	}
	return r.providers[r.active]
}

// SetActive sets the active provider, or clears it when name is empty.
func (r *Registry) SetActive(name string) bool {

	r.mu.Lock()
	defer r.mu.Unlock()
	if name == "" {
		r.active = ""
		return true
	}
	if _, ok := r.providers[name]; ok {
		r.active = name
		return true
	}
	return false
}

// List returns all registered providers.
func (r *Registry) List() []providercore.Provider {

	r.mu.RLock()
	defer r.mu.RUnlock()

	providers := make([]providercore.Provider, 0, len(r.providers))
	for _, name := range r.order {
		if p, ok := r.providers[name]; ok {
			providers = append(providers, p)
		}
	}
	return providers
}

// ListConfigs returns configurations for all providers.
func (r *Registry) ListConfigs() []providercore.ProviderConfig {

	r.mu.RLock()
	defer r.mu.RUnlock()

	configs := make([]providercore.ProviderConfig, 0, len(r.providers))
	for _, name := range r.order {
		if p, ok := r.providers[name]; ok {
			configs = append(configs, providercore.ProviderConfig{
				Name:        p.Name(),
				DisplayName: p.DisplayName(),
				Models:      p.Models(),
			})
		}
	}
	return configs
}

```


--| internal/features/providers/core/securestore/keyring.go

```go
// keyring.go accesses OS keyring storage for provider secrets.
// internal/features/providers/core/securestore/keyring.go
package securestore

import (
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	"github.com/zalando/go-keyring"
)

// KeyringStore stores provider credentials in the OS keychain.
type KeyringStore struct {
	serviceName string
}

// NewKeyringStore creates a keyring-backed secret store scoped to a service name.
func NewKeyringStore(serviceName string) *KeyringStore {
	return &KeyringStore{serviceName: serviceName}
}

var _ providercore.SecretStore = (*KeyringStore)(nil)

// SaveProviderSecret stores a provider secret field in the OS keychain.
func (s *KeyringStore) SaveProviderSecret(providerName, fieldName, value string) error {
	return keyring.Set(s.serviceName, s.credentialKey(providerName, fieldName), value)
}

// GetProviderSecret retrieves a provider secret field from the OS keychain.
func (s *KeyringStore) GetProviderSecret(providerName, fieldName string) (string, error) {
	return keyring.Get(s.serviceName, s.credentialKey(providerName, fieldName))
}

// HasProviderSecret returns true when a provider secret field is stored.
func (s *KeyringStore) HasProviderSecret(providerName, fieldName string) bool {
	_, err := keyring.Get(s.serviceName, s.credentialKey(providerName, fieldName))
	return err == nil
}

// DeleteProviderSecret removes a stored provider secret field.
func (s *KeyringStore) DeleteProviderSecret(providerName, fieldName string) error {
	return keyring.Delete(s.serviceName, s.credentialKey(providerName, fieldName))
}

// credentialKey builds the keyring entry key for a provider secret field.
func (s *KeyringStore) credentialKey(providerName, fieldName string) string {

	return providerName + ":" + fieldName
}

```


--| internal/features/providers/interfaces/core/provider.go

```go
// provider.go defines provider identity and configuration contracts.
// internal/features/providers/interfaces/core/provider.go
package core

import (
	"context"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

// Model represents an AI model.
type Model struct {
	ID                string `json:"id"`
	Name              string `json:"name"`
	ContextWindow     int    `json:"contextWindow"`
	SupportsStreaming bool   `json:"supportsStreaming"`
	SupportsTools     bool   `json:"supportsTools"`
	SupportsVision    bool   `json:"supportsVision"`
}

// ProviderCredentials stores credential values by field name.
type ProviderCredentials map[string]string

// CredentialField describes an input required to configure a provider.
type CredentialField struct {
	Name        string `json:"name"`
	Label       string `json:"label"`
	Required    bool   `json:"required"`
	Secret      bool   `json:"secret"`
	Placeholder string `json:"placeholder,omitempty"`
	Help        string `json:"help,omitempty"`
}

const (
	CredentialAPIKey            = "api_key"
	CredentialAccountID         = "account_id"
	CredentialGatewayID         = "gateway_id"
	CredentialToken             = "token"
	CredentialCloudflareToken   = "cloudflare_api_token"
	CredentialOpenRouterReferer = "openrouter_referer"
	CredentialOpenRouterTitle   = "openrouter_title"
)

// ProviderConfig holds provider configuration.
type ProviderConfig struct {
	Name         string              `json:"name"`
	DisplayName  string              `json:"displayName"`
	APIKey       string              `json:"apiKey,omitempty"`
	BaseURL      string              `json:"baseUrl,omitempty"`
	DefaultModel string              `json:"defaultModel"`
	Models       []Model             `json:"models"`
	Credentials  ProviderCredentials `json:"credentials,omitempty"`
	Logger       coreports.Logger    `json:"-"`
}

// Provider describes the full provider contract used by app services.
type Provider interface {
	providergateway.Provider
	Name() string
	DisplayName() string
	Models() []Model
	ListResources(ctx context.Context) ([]Model, error)
	CredentialFields() []CredentialField
	Configure(config ProviderConfig) error
}

```


--| internal/features/providers/interfaces/core/provider_cache.go

```go
// provider_cache.go defines provider resource cache contracts.
// internal/features/providers/interfaces/core/provider_cache.go
package core

// ProviderCacheEntry represents cached resources for a provider.
type ProviderCacheEntry struct {
	UpdatedAt int64   `json:"updatedAt"`
	Models    []Model `json:"models"`
}

// ProviderCacheSnapshot contains cached resources by provider name.
type ProviderCacheSnapshot map[string]ProviderCacheEntry

// ProviderCache manages persistence of provider resources.
type ProviderCache interface {
	Load() (ProviderCacheSnapshot, error)
	Save(snapshot ProviderCacheSnapshot) error
}

```


--| internal/features/providers/interfaces/core/provider_inputs_store.go

```go
// provider_inputs_store.go manages provider input persistence for non-secret fields.
// internal/features/providers/interfaces/core/provider_inputs_store.go
package core

// ProviderInputsStore persists non-secret provider input values.
type ProviderInputsStore interface {
	LoadProviderInputs(providerName string) (map[string]string, error)
	SaveProviderInputs(providerName string, inputs map[string]string) error
}

```


--| internal/features/providers/interfaces/core/provider_registry.go

```go
// provider_registry.go defines provider registry contracts.
// internal/features/providers/interfaces/core/provider_registry.go
package core

// ProviderRegistry manages provider instances and active selection.
type ProviderRegistry interface {
	Register(p Provider)
	Get(name string) Provider
	GetActive() Provider
	SetActive(name string) bool
	List() []Provider
	ListConfigs() []ProviderConfig
}

```


--| internal/features/providers/interfaces/core/secret_store.go

```go
// secret_store.go defines secret storage contracts for provider credentials.
// internal/features/providers/interfaces/core/secret_store.go
package core

// SecretStore manages provider secret storage.
type SecretStore interface {
	SaveProviderSecret(providerName, fieldName, value string) error
	GetProviderSecret(providerName, fieldName string) (string, error)
	HasProviderSecret(providerName, fieldName string) bool
	DeleteProviderSecret(providerName, fieldName string) error
}

```


--| internal/features/providers/interfaces/gateway/capabilities.go

```go
// capabilities.go defines gateway semantic capability descriptors.
// internal/features/providers/interfaces/gateway/capabilities.go
package gateway

// CapabilityID identifies a semantic gateway capability.
type CapabilityID string

const (
	CapabilityChatText                     CapabilityID = "chat.text"
	CapabilityChatMultimodalToText         CapabilityID = "chat.multimodal_to_text"
	CapabilityGenerateImage                CapabilityID = "gen.image"
	CapabilityGenerateVideo                CapabilityID = "gen.video"
	CapabilitySpeechASR                    CapabilityID = "speech.asr"
	CapabilitySpeechTTS                    CapabilityID = "speech.tts"
	CapabilityRealtimeDuplexAudio          CapabilityID = "realtime.duplex_audio"
	CapabilityVisionSegmentationImage      CapabilityID = "vision.segmentation.promptable_image"
	CapabilityVisionSegmentationVideo      CapabilityID = "vision.segmentation.promptable_video"
	CapabilityRetrievalEmbedText           CapabilityID = "retrieval.embed.text"
	CapabilityRetrievalEmbedMultimodal     CapabilityID = "retrieval.embed.multimodal"
	CapabilityRankRerank                   CapabilityID = "rank.rerank"
	CapabilitySafetyModeration             CapabilityID = "safety.moderation"
	CapabilityAgentToolUse                 CapabilityID = "agent.tool_use"
)

// ControlDescriptor describes a provider-specific control exposed for a capability.
type ControlDescriptor struct {
	Name        string `json:"name"`
	Type        string `json:"type"`
	Required    bool   `json:"required"`
	Description string `json:"description,omitempty"`
}

// CapabilityDescriptor describes one semantic capability and its I/O contract.
type CapabilityDescriptor struct {
	ID          CapabilityID        `json:"id"`
	Inputs      []InputType         `json:"inputs"`
	Outputs     []OutputType        `json:"outputs"`
	Interaction InteractionType     `json:"interaction"`
	Controls    []ControlDescriptor `json:"controls,omitempty"`
}

// CapabilityAdvertiser is implemented by providers that expose capability metadata.
type CapabilityAdvertiser interface {
	GatewayCapabilities() []CapabilityDescriptor
}

```


--| internal/features/providers/interfaces/gateway/chat_options.go

```go
// chat_options.go defines chat request configuration contracts.
// internal/features/providers/interfaces/gateway/chat_options.go
package gateway

// ChatOptions configures a chat completion request.
type ChatOptions struct {
	Model       string   `json:"model"`
	Temperature float64  `json:"temperature,omitempty"`
	MaxTokens   int      `json:"maxTokens,omitempty"`
	Stream      bool     `json:"stream"`
	Tools       []Tool   `json:"tools,omitempty"`
	StopWords   []string `json:"stopWords,omitempty"`
}

```


--| internal/features/providers/interfaces/gateway/chunk.go

```go
// chunk.go defines streaming chunk response contracts.
// internal/features/providers/interfaces/gateway/chunk.go
package gateway

// Chunk represents a piece of a streaming response.
type Chunk struct {
	Content      string      `json:"content,omitempty"`
	Model        string      `json:"model,omitempty"`
	ToolCalls    []ToolCall  `json:"toolCalls,omitempty"`
	FinishReason string      `json:"finishReason,omitempty"`
	Usage        *UsageStats `json:"usage,omitempty"`
	Error        error       `json:"-"`
}

```


--| internal/features/providers/interfaces/gateway/image_types.go

```go
// image_types.go defines types related to image generation.
// internal/features/providers/interfaces/gateway/image_types.go
package gateway

// ImageGenerationOptions defines parameters for image generation requests.
type ImageGenerationOptions struct {
	Model          string `json:"model"`
	Prompt         string `json:"prompt"`
	N              int    `json:"n,omitempty"`              // Number of images to generate
	Size           string `json:"size,omitempty"`           // 256x256, 512x512, 1024x1024
	Quality        string `json:"quality,omitempty"`        // standard, hd
	Style          string `json:"style,omitempty"`          // vivid, natural
	ResponseFormat string `json:"response_format,omitempty"` // url, b64_json
	User           string `json:"user,omitempty"`
}

// ImageEditOptions defines parameters for image editing requests.
type ImageEditOptions struct {
	Model  string `json:"model"`
	Image  string `json:"image"`           // Path or Base64
	Mask   string `json:"mask,omitempty"`  // Path or Base64 (optional)
	Prompt string `json:"prompt"`
	N      int    `json:"n,omitempty"`
	Size   string `json:"size,omitempty"`
}

// ImageResult represents the result of an image generation request.
type ImageResult struct {
	Created int64         `json:"created"`
	Data    []ImageData   `json:"data"`
}

// ImageData contains the generated image info.
type ImageData struct {
	URL           string `json:"url,omitempty"`
	B64JSON       string `json:"b64_json,omitempty"`
	RevisedPrompt string `json:"revised_prompt,omitempty"`
}

```


--| internal/features/providers/interfaces/gateway/messages.go

```go
// messages.go defines provider message role and payload contracts.
// internal/features/providers/interfaces/gateway/messages.go
package gateway

// Role represents the sender of a provider message.
type Role string

const (
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleTool      Role = "tool"
)

// ProviderMessage represents a provider-ready chat message.
type ProviderMessage struct {
	Role    Role   `json:"role"`
	Content string `json:"content"`
}

```


--| internal/features/providers/interfaces/gateway/modality_types.go

```go
// modality_types.go defines gateway modality and interaction classification types.
// internal/features/providers/interfaces/gateway/modality_types.go
package gateway

// InputType identifies normalized gateway input wire types.
type InputType string

const (
	InputText             InputType = "text"
	InputImage            InputType = "image"
	InputAudio            InputType = "audio"
	InputVideo            InputType = "video"
	InputDocument         InputType = "document"
	InputStructuredPrompt InputType = "structured_prompt"
)

// OutputType identifies normalized gateway output wire types.
type OutputType string

const (
	OutputText              OutputType = "text"
	OutputEmbedding         OutputType = "embedding"
	OutputImage             OutputType = "image"
	OutputAudio             OutputType = "audio"
	OutputVideo             OutputType = "video"
	OutputMasks             OutputType = "masks"
	OutputBoxes             OutputType = "boxes"
	OutputKeypoints         OutputType = "keypoints"
	OutputTracks            OutputType = "tracks"
	OutputSafetyLabels      OutputType = "safety_labels"
	OutputToolCalls         OutputType = "tool_calls"
	OutputRankingScores     OutputType = "ranking_scores"
	OutputActionInvocations OutputType = "action_invocations"
)

// InteractionType identifies the runtime interaction pattern for a gateway capability.
type InteractionType string

const (
	InteractionSingle    InteractionType = "single"
	InteractionStreaming InteractionType = "streaming"
	InteractionDuplex    InteractionType = "duplex"
	InteractionBatch     InteractionType = "batch"
)

```


--| internal/features/providers/interfaces/gateway/provider.go

```go
// provider.go defines the base gateway provider network contract.
// internal/features/providers/interfaces/gateway/provider.go
package gateway

import "context"

// Provider defines baseline network calls for model providers.
type Provider interface {
	Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error)
	GenerateImage(ctx context.Context, opts ImageGenerationOptions) (*ImageResult, error)
	EditImage(ctx context.Context, opts ImageEditOptions) (*ImageResult, error)
	TestConnection(ctx context.Context) error
}

```


--| internal/features/providers/interfaces/gateway/tools.go

```go
// tools.go defines gateway tool schema and invocation contracts.
// internal/features/providers/interfaces/gateway/tools.go
package gateway

// Tool represents a function the AI can call.
type Tool struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Parameters  map[string]interface{} `json:"parameters"`
}

// ToolCall represents an AI request to execute a tool.
type ToolCall struct {
	ID        string                 `json:"id"`
	Name      string                 `json:"name"`
	Arguments map[string]interface{} `json:"arguments"`
}

```


--| internal/features/providers/interfaces/gateway/usage.go

```go
// usage.go defines gateway token usage contracts.
// internal/features/providers/interfaces/gateway/usage.go
package gateway

// UsageStats contains token usage information.
type UsageStats struct {
	PromptTokens     int `json:"promptTokens"`
	CompletionTokens int `json:"completionTokens"`
	TotalTokens      int `json:"totalTokens"`
}

```


--| internal/features/settings/config/config.go

```go
// config.go defines application configuration types and helpers.
// internal/features/settings/config/config.go
package config

import (
	"errors"
	"fmt"
	"time"
)

// AppConfig represents the root application configuration.
type AppConfig struct {
	Providers []ProviderConfig `json:"providers"`
}

// UpdateFrequency describes how often provider resources are refreshed.
type UpdateFrequency string

const (
	UpdateFrequencyManual UpdateFrequency = "manual"
	UpdateFrequencyHourly UpdateFrequency = "hourly"
	UpdateFrequencyDaily  UpdateFrequency = "daily"
	UpdateFrequencyWeekly UpdateFrequency = "weekly"
)

// ProviderConfig describes a configured provider.
type ProviderConfig struct {
	Type            string          `json:"type"`
	Name            string          `json:"name"`
	DisplayName     string          `json:"displayName"`
	BaseURL         string          `json:"baseUrl"`
	DefaultModel    string          `json:"defaultModel"`
	UpdateFrequency UpdateFrequency `json:"updateFrequency"`
	Models          []ModelConfig   `json:"models"`
	Inputs          map[string]string `json:"inputs,omitempty"`
}

// ModelConfig describes a provider model toggle in configuration.
type ModelConfig struct {
	ID      string `json:"id"`
	Enabled bool   `json:"enabled"`
}

// LoadConfig loads configuration from the provided store.
func LoadConfig(store Store) (AppConfig, error) {

	if store == nil {
		return AppConfig{}, fmt.Errorf("load config: store required")
	}

	cfg, err := store.Load()
	if err == nil {
		return cfg, nil
	}
	if errors.Is(err, ErrConfigNotFound) {
		cfg = DefaultConfig()
		if saveErr := store.Save(cfg); saveErr != nil {
			return AppConfig{}, fmt.Errorf("load config: save default: %w", saveErr)
		}
		return cfg, nil
	}

	return AppConfig{}, fmt.Errorf("load config: %w", err)
}

// ResolveUpdateFrequencies parses provider update frequencies from configuration.
func ResolveUpdateFrequencies(cfg AppConfig) (map[string]time.Duration, error) {

	frequencies := make(map[string]time.Duration)
	for _, providerConfig := range cfg.Providers {
		if providerConfig.UpdateFrequency == "" {
			continue
		}
		frequency, err := parseUpdateFrequency(providerConfig.UpdateFrequency)
		if err != nil {
			return nil, fmt.Errorf("provider %s updateFrequency: %w", providerConfig.Name, err)
		}
		if frequency <= 0 {
			continue
		}
		frequencies[providerConfig.Name] = frequency
	}

	if len(frequencies) == 0 {
		return nil, nil
	}

	return frequencies, nil
}

// parseUpdateFrequency converts enum values into durations.
func parseUpdateFrequency(value UpdateFrequency) (time.Duration, error) {

	switch value {
	case UpdateFrequencyManual:
		return 0, nil
	case UpdateFrequencyHourly:
		return time.Hour, nil
	case UpdateFrequencyDaily:
		return 24 * time.Hour, nil
	case UpdateFrequencyWeekly:
		return 7 * 24 * time.Hour, nil
	default:
		return 0, fmt.Errorf("unknown update frequency: %s", value)
	}
}

```


--| internal/features/settings/config/defaults.go

```go
// define default application configuration values.
// internal/features/settings/config/defaults.go
package config

// DefaultConfig returns the baseline application configuration.
func DefaultConfig() AppConfig {

	return AppConfig{
		Providers: []ProviderConfig{
			{
				Type:            "openai",
				Name:            "openai",
				DisplayName:     "OpenAI",
				BaseURL:         "https://api.openai.com/v1",
				UpdateFrequency: UpdateFrequencyManual,
				Models:          nil,
			},
			{
				Type:            "openai",
				Name:            "grok",
				DisplayName:     "Grok (xAI)",
				BaseURL:         "https://api.x.ai/v1",
				UpdateFrequency: UpdateFrequencyManual,
				Models:          nil,
			},
			{
				Type:            "openai",
				Name:            "mistral",
				DisplayName:     "Mistral",
				BaseURL:         "https://api.mistral.ai/v1",
				UpdateFrequency: UpdateFrequencyManual,
				Models:          nil,
			},
			{
				Type:            "anthropic",
				Name:            "anthropic",
				DisplayName:     "Anthropic",
				BaseURL:         "https://api.anthropic.com",
				UpdateFrequency: UpdateFrequencyManual,
				Models:          nil,
			},
			{
				Type:            "gemini",
				Name:            "gemini",
				DisplayName:     "Google Gemini",
				BaseURL:         "https://generativelanguage.googleapis.com/v1beta",
				UpdateFrequency: UpdateFrequencyManual,
				Models:          nil,
			},
			{
				Type:            "cloudflare",
				Name:            "cloudflare",
				DisplayName:     "Cloudflare AI Gateway",
				BaseURL:         "",
				UpdateFrequency: UpdateFrequencyManual,
				Models:          nil,
			},
			{
				Type:            "openrouter",
				Name:            "openrouter",
				DisplayName:     "OpenRouter",
				BaseURL:         "https://openrouter.ai/api/v1",
				UpdateFrequency: UpdateFrequencyManual,
				Models:          nil,
			},
		},
	}
}

```


--| internal/features/settings/config/paths.go

```go
// paths.go resolves OS-specific application paths.
// internal/features/settings/config/paths.go
package config

import (
	"fmt"
	"os"
	"path/filepath"
)

// ResolveAppDataDir resolves and creates the OS config directory for the app.
func ResolveAppDataDir(appName string) (string, error) {

	if appName == "" {
		return "", fmt.Errorf("resolve app data dir: app name required")
	}

	configDir, err := os.UserConfigDir()
	if err != nil || configDir == "" {
		return "", fmt.Errorf("resolve user config dir: %w", err)
	}

	appDir := filepath.Join(configDir, appName)
	if err := os.MkdirAll(appDir, 0o755); err != nil {
		return "", fmt.Errorf("create app data dir: %w", err)
	}

	return appDir, nil
}

```


--| internal/features/settings/config/store.go

```go
// store.go defines configuration persistence contracts.
// internal/features/settings/config/store.go
package config

import "errors"

// ErrConfigNotFound signals the configuration has not been stored yet.
var ErrConfigNotFound = errors.New("config not found")

// Store persists application configuration.
type Store interface {
	Load() (AppConfig, error)
	Save(AppConfig) error
}

```


--| internal/features/settings/usecase/orchestration.go

```go
// orchestrate provider workflows and event emission.
// internal/features/settings/usecase/orchestration.go
package provider

import (
	"context"
	"fmt"
	"strings"
	"sync"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
)

// Orchestrator orchestrates provider workflows and event emission.
type Orchestrator struct {
	providers *Service
	secrets   SecretStore
	emitter   coreports.Emitter
	activeMu  sync.Mutex
	activeRun bool
}

// NewOrchestrator creates a provider orchestrator with required dependencies.
func NewOrchestrator(service *Service, secrets SecretStore, emitter coreports.Emitter) *Orchestrator {

	return &Orchestrator{providers: service, secrets: secrets, emitter: emitter}
}

// GetProviders returns all available providers with their status.
func (o *Orchestrator) GetProviders() []Info {

	o.ensureActiveProviderAsync()
	return o.providers.List()
}

// ConnectProvider connects and configures a provider with the given credentials.
func (o *Orchestrator) ConnectProvider(ctx context.Context, name string, credentials ProviderCredentials) (Info, error) {

	info, err := o.providers.Connect(ctx, name, credentials)
	if err == nil {
		o.emitProvidersUpdated()
	}
	return info, err
}

// ConfigureProvider updates a provider's credentials without full connection flow.
func (o *Orchestrator) ConfigureProvider(name string, credentials ProviderCredentials) error {

	return o.providers.Configure(name, credentials)
}

// DisconnectProvider removes a provider's credentials and resets its state.
func (o *Orchestrator) DisconnectProvider(name string) error {

	previousActive := o.providers.GetActiveProvider()
	previousActiveName := ""
	if previousActive != nil {
		previousActiveName = previousActive.Name()
	}

	err := o.providers.Disconnect(name)
	if err != nil {
		return err
	}

	currentActive := o.providers.GetActiveProvider()
	if previousActiveName == name && currentActive != nil && currentActive.Name() != name {
		o.emitProviderSwitchToast(previousActive, currentActive)
	}

	o.emitProvidersUpdated()
	return nil
}

// SetActiveProvider sets the active provider by name.
func (o *Orchestrator) SetActiveProvider(name string) bool {

	ok := o.providers.SetActive(name)
	if ok {
		o.emitProvidersUpdated()
	}
	return ok
}

// TestProvider tests the connection to a provider.
func (o *Orchestrator) TestProvider(ctx context.Context, name string) error {

	return o.providers.TestConnection(ctx, name)
}

// RefreshProviderResources fetches the latest resources from a provider.
func (o *Orchestrator) RefreshProviderResources(ctx context.Context, name string) error {

	err := o.providers.RefreshResources(ctx, name)
	if err == nil {
		o.emitProvidersUpdated()
	}
	return err
}

// GetActiveProvider returns the currently active provider, if any.
func (o *Orchestrator) GetActiveProvider() *Info {

	o.ensureActiveProvider()
	infos := o.providers.List()
	for i := range infos {
		if infos[i].IsActive {
			info := infos[i]
			return &info
		}
	}
	return nil
}

// emitProvidersUpdated publishes a provider update event.
func (o *Orchestrator) emitProvidersUpdated() {

	if o.emitter == nil {
		return
	}
	o.emitter.EmitProvidersUpdated()
}

// emitProviderSwitchToast notifies the frontend about an automatic provider switch.
func (o *Orchestrator) emitProviderSwitchToast(previousActive, currentActive Provider) {

	if o.emitter == nil || currentActive == nil {
		return
	}

	previousName := ""
	if previousActive != nil {
		previousName = previousActive.DisplayName()
	}

	message := fmt.Sprintf("Active provider switched to %s.", currentActive.DisplayName())
	if previousName != "" {
		message = fmt.Sprintf("Active provider switched from %s to %s.", previousName, currentActive.DisplayName())
	}

	o.emitter.EmitToast(coreports.ToastPayload{
		Type:    "info",
		Title:   "Provider switched",
		Message: message,
	})
}

// ensureActiveProvider selects an active provider with valid credentials.
func (o *Orchestrator) ensureActiveProvider() {

	infos := o.providers.List()
	active := o.providers.GetActiveProvider()
	if active != nil {
		for _, info := range infos {
			if info.Name != active.Name() || !info.IsConnected {
				continue
			}
			if prov := o.providers.GetProvider(info.Name); prov != nil {
				if err := o.applyProviderSecrets(info.Name, prov); err == nil {
					return
				}
			}
			break
		}
	}
	for _, info := range infos {
		if !info.IsConnected {
			continue
		}
		prov := o.providers.GetProvider(info.Name)
		if prov == nil {
			continue
		}
		if err := o.applyProviderSecrets(info.Name, prov); err != nil {
			continue
		}
		if o.providers.SetActive(info.Name) {
			return
		}
	}
}

// ensureActiveProviderAsync de-duplicates background active-provider checks.
func (o *Orchestrator) ensureActiveProviderAsync() {

	o.activeMu.Lock()
	if o.activeRun {
		o.activeMu.Unlock()
		return
	}
	o.activeRun = true
	o.activeMu.Unlock()

	go func() {
		defer func() {
			o.activeMu.Lock()
			o.activeRun = false
			o.activeMu.Unlock()
		}()
		o.ensureActiveProvider()
	}()
}

// applyProviderSecrets loads stored secrets into the provider instance.
func (o *Orchestrator) applyProviderSecrets(name string, prov Provider) error {

	if o.secrets == nil {
		return fmt.Errorf("secret store not configured")
	}
	fields := prov.CredentialFields()
	credentials := make(ProviderCredentials)
	for _, field := range fields {
		if !field.Secret {
			continue
		}
		value, err := o.secrets.GetProviderSecret(name, field.Name)
		if err != nil || strings.TrimSpace(value) == "" {
			if field.Required {
				return fmt.Errorf("missing required credential: %s", field.Name)
			}
			continue
		}
		credentials[field.Name] = value
	}
	if len(credentials) > 0 {
		_ = prov.Configure(Config{Credentials: credentials})
	}
	return nil
}

```


--| internal/features/settings/usecase/service.go

```go
// manage provider connections, caches, and status.
// internal/features/settings/usecase/service.go
package provider

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"
)

// Info represents provider information for the frontend.
type Info struct {
	Name             string            `json:"name"`
	DisplayName      string            `json:"displayName"`
	CredentialFields []CredentialField `json:"credentialFields,omitempty"`
	CredentialValues map[string]string `json:"credentialValues,omitempty"`
	Models           []Model           `json:"models"`
	Resources        []Model           `json:"resources"`
	IsConnected      bool              `json:"isConnected"`
	IsActive         bool              `json:"isActive"`
	Status           *Status           `json:"status,omitempty"`
}

// Status represents the last known health check for a provider.
type Status struct {
	OK        bool   `json:"ok"`
	Message   string `json:"message,omitempty"`
	CheckedAt int64  `json:"checkedAt"`
}

// resourceLister is implemented by providers that can list resources.
type resourceLister interface {
	ListResources(ctx context.Context) ([]Model, error)
}

var errNoResources = errors.New("no resources returned from provider")

// Service handles provider management logic.
type Service struct {
	registry          Registry
	resources         map[string][]Model
	resourceUpdatedAt map[string]int64
	cache             Cache
	enabledModelIDs   map[string][]string
	updateFrequency   map[string]time.Duration
	status            map[string]Status
	refreshing        map[string]bool
	mu                sync.RWMutex
	inputsStore       InputsStore
	secrets           SecretStore
	logger            Logger
}

// validateProvider tests connectivity and updates resources when supported.
func (s *Service) validateProvider(ctx context.Context, name string, p Provider) (bool, error) {

	if lister, ok := p.(resourceLister); ok {
		resources, err := lister.ListResources(ctx)
		if err != nil {
			return true, err
		}
		if len(resources) == 0 {
			return true, errNoResources
		}
		s.SetResources(name, resources)
		return true, nil
	}
	if err := p.TestConnection(ctx); err != nil {
		return false, err
	}
	return false, nil
}

// NewService creates a new provider service.
func NewService(registry Registry, cache Cache, secrets SecretStore, inputs InputsStore, updateFrequency map[string]time.Duration, logger Logger) *Service {

	s := &Service{
		registry:          registry,
		resources:         make(map[string][]Model),
		resourceUpdatedAt: make(map[string]int64),
		cache:             cache,
		enabledModelIDs:   captureEnabledModelIDs(registry),
		updateFrequency:   copyUpdateFrequency(updateFrequency),
		status:            make(map[string]Status),
		refreshing:        make(map[string]bool),
		inputsStore:       inputs,
		secrets:           secrets,
		logger:            logger,
	}
	s.loadCache()
	s.applyEnabledModelsFromCache()
	return s
}

// loadCache loads cached provider resources from disk.
func (s *Service) loadCache() {

	if s.cache == nil {
		return
	}
	snapshot, err := s.cache.Load()
	if err != nil {
		return
	}

	for name, entry := range snapshot {
		if entry.Models != nil {
			s.resources[name] = entry.Models
		}
		if entry.UpdatedAt > 0 {
			s.resourceUpdatedAt[name] = entry.UpdatedAt
		}
	}
}

// applyEnabledModelsFromCache applies cached resources to enabled model lists.
func (s *Service) applyEnabledModelsFromCache() {

	if s.registry == nil {
		return
	}
	for _, prov := range s.registry.List() {
		name := prov.Name()
		resources := s.GetResources(name)
		s.applyEnabledModels(name, resources)
	}
}

// applyEnabledModels updates provider models using enabled IDs and available resources.
func (s *Service) applyEnabledModels(name string, resources []Model) {

	enabledIDs := s.enabledModelIDs[name]
	if p := s.registry.Get(name); p != nil {
		if len(resources) == 0 {
			_ = p.Configure(Config{Models: buildFallbackModels(enabledIDs)})
			return
		}
		if len(enabledIDs) == 0 {
			_ = p.Configure(Config{Models: resources})
			return
		}
		available := indexModelsByID(resources)
		_ = p.Configure(Config{Models: selectModelsByID(enabledIDs, available)})
	}
}

// captureEnabledModelIDs extracts enabled model IDs from configured providers.
func captureEnabledModelIDs(registry Registry) map[string][]string {

	result := make(map[string][]string)
	if registry == nil {
		return result
	}
	for _, prov := range registry.List() {
		result[prov.Name()] = extractModelIDs(prov.Models())
	}
	return result
}

// extractModelIDs normalizes model IDs from configured models.
func extractModelIDs(models []Model) []string {

	seen := make(map[string]struct{}, len(models))
	ids := make([]string, 0, len(models))
	for _, model := range models {
		trimmed := strings.TrimSpace(model.ID)
		if trimmed == "" {
			continue
		}
		if _, ok := seen[trimmed]; ok {
			continue
		}
		seen[trimmed] = struct{}{}
		ids = append(ids, trimmed)
	}
	return ids
}

// providerCredentialFields returns the credential schema for a provider.
func (s *Service) providerCredentialFields(p Provider) []CredentialField {

	if p == nil {
		return nil
	}
	return p.CredentialFields()
}

// loadProviderInputs returns stored non-secret inputs for a provider.
func (s *Service) loadProviderInputs(name string) ProviderCredentials {

	if s.inputsStore == nil {
		return nil
	}
	inputs, err := s.inputsStore.LoadProviderInputs(name)
	if err != nil {
		s.logWarn("Failed to load provider inputs", err, LogField{Key: "provider", Value: name})
		return nil
	}
	return inputs
}

// loadProviderSecrets returns stored secret values for a provider.
func (s *Service) loadProviderSecrets(name string, fields []CredentialField) ProviderCredentials {

	if s.secrets == nil {
		return nil
	}

	credentials := make(ProviderCredentials)
	for _, field := range fields {
		if !field.Secret {
			continue
		}
		value, err := s.secrets.GetProviderSecret(name, field.Name)
		if err != nil || strings.TrimSpace(value) == "" {
			continue
		}
		credentials[field.Name] = value
	}

	if len(credentials) == 0 {
		return nil
	}
	return credentials
}

// mergeCredentialValues combines stored and incoming credential values.
func mergeCredentialValues(base, override ProviderCredentials) ProviderCredentials {

	if len(base) == 0 && len(override) == 0 {
		return nil
	}

	merged := make(ProviderCredentials)
	for key, value := range base {
		trimmed := strings.TrimSpace(value)
		if trimmed == "" {
			continue
		}
		merged[key] = trimmed
	}
	for key, value := range override {
		trimmed := strings.TrimSpace(value)
		if trimmed == "" {
			continue
		}
		merged[key] = trimmed
	}

	if len(merged) == 0 {
		return nil
	}
	return merged
}

// validateRequiredCredentials verifies all required fields are present.
func validateRequiredCredentials(fields []CredentialField, credentials ProviderCredentials) error {

	for _, field := range fields {
		if !field.Required {
			continue
		}
		if strings.TrimSpace(credentials[field.Name]) == "" {
			label := field.Label
			if label == "" {
				label = field.Name
			}
			return fmt.Errorf("missing required credential: %s", label)
		}
	}
	return nil
}

// filterCredentialValues returns credential values matching the secret flag.
func filterCredentialValues(fields []CredentialField, credentials ProviderCredentials, secret bool) ProviderCredentials {

	if len(credentials) == 0 {
		return nil
	}

	filtered := make(ProviderCredentials)
	for _, field := range fields {
		if field.Secret != secret {
			continue
		}
		value := strings.TrimSpace(credentials[field.Name])
		if value == "" {
			continue
		}
		filtered[field.Name] = value
	}

	if len(filtered) == 0 {
		return nil
	}
	return filtered
}

// resolveCredentials merges stored and incoming credentials with validation.
func (s *Service) resolveCredentials(name string, fields []CredentialField, input ProviderCredentials) (ProviderCredentials, error) {

	stored := mergeCredentialValues(s.loadProviderInputs(name), s.loadProviderSecrets(name, fields))
	merged := mergeCredentialValues(stored, input)
	if err := validateRequiredCredentials(fields, merged); err != nil {
		return nil, err
	}
	return merged, nil
}

// persistCredentials saves provided credential values to storage.
func (s *Service) persistCredentials(name string, fields []CredentialField, input ProviderCredentials) error {

	if len(input) == 0 {
		return nil
	}

	var secretUpdates ProviderCredentials
	var inputUpdates ProviderCredentials

	for _, field := range fields {
		value, ok := input[field.Name]
		if !ok {
			continue
		}
		trimmed := strings.TrimSpace(value)
		if trimmed == "" {
			continue
		}
		if field.Secret {
			if secretUpdates == nil {
				secretUpdates = make(ProviderCredentials)
			}
			secretUpdates[field.Name] = trimmed
		} else {
			if inputUpdates == nil {
				inputUpdates = make(ProviderCredentials)
			}
			inputUpdates[field.Name] = trimmed
		}
	}

	if len(secretUpdates) > 0 {
		if s.secrets == nil {
			return fmt.Errorf("secret store not configured")
		}
		for fieldName, value := range secretUpdates {
			if err := s.secrets.SaveProviderSecret(name, fieldName, value); err != nil {
				return err
			}
		}
	}

	if len(inputUpdates) > 0 {
		if s.inputsStore == nil {
			return fmt.Errorf("config store not configured")
		}
		mergedInputs := mergeCredentialValues(s.loadProviderInputs(name), inputUpdates)
		if err := s.inputsStore.SaveProviderInputs(name, mergedInputs); err != nil {
			return err
		}
	}

	return nil
}

// clearStoredCredentials removes stored inputs and secrets for a provider.
func (s *Service) clearStoredCredentials(name string, fields []CredentialField) error {

	if s.inputsStore != nil {
		if err := s.inputsStore.SaveProviderInputs(name, nil); err != nil {
			return err
		}
	}
	if s.secrets == nil {
		return nil
	}
	for _, field := range fields {
		if !field.Secret {
			continue
		}
		_ = s.secrets.DeleteProviderSecret(name, field.Name)
	}
	return nil
}

// isProviderConfigured returns true when required credential fields are present.
func (s *Service) isProviderConfigured(name string, fields []CredentialField) bool {

	credentials := mergeCredentialValues(s.loadProviderInputs(name), s.loadProviderSecrets(name, fields))
	return validateRequiredCredentials(fields, credentials) == nil
}

// applyStoredCredentials updates a provider with stored credentials.
func (s *Service) applyStoredCredentials(name string, p Provider) {

	fields := s.providerCredentialFields(p)
	credentials := mergeCredentialValues(s.loadProviderInputs(name), s.loadProviderSecrets(name, fields))
	if len(credentials) == 0 {
		return
	}
	_ = p.Configure(Config{Credentials: credentials})
}

// refreshResourcesIfStale launches a background refresh when cache is outdated.
func (s *Service) refreshResourcesIfStale(name string) {

	if !s.shouldRefreshResources(name) {
		return
	}
	if s.registry == nil {
		return
	}
	if !s.isProviderConfigured(name, s.providerCredentialFields(s.registry.Get(name))) {
		return
	}
	if !s.markRefreshing(name) {
		return
	}

	go func() {
		defer s.clearRefreshing(name)
		ctx, cancel := context.WithTimeout(context.Background(), 12*time.Second)
		defer cancel()
		if err := s.RefreshResources(ctx, name); err != nil {
			s.logWarn("Failed to refresh stale resources", err, LogField{Key: "provider", Value: name})
		}
	}()
}

// shouldRefreshResources determines if cached resources are stale.
func (s *Service) shouldRefreshResources(name string) bool {

	frequency := s.getUpdateFrequency(name)
	if frequency <= 0 {
		return false
	}
	lastUpdated := s.getResourceUpdatedAt(name)
	if lastUpdated == 0 {
		return true
	}
	lastUpdateTime := time.UnixMilli(lastUpdated)
	return time.Since(lastUpdateTime) >= frequency
}

// getUpdateFrequency returns the configured update cadence for a provider.
func (s *Service) getUpdateFrequency(name string) time.Duration {

	if s.updateFrequency == nil {
		return 0
	}
	return s.updateFrequency[name]
}

// getResourceUpdatedAt returns the last update timestamp for cached resources.
func (s *Service) getResourceUpdatedAt(name string) int64 {

	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.resourceUpdatedAt[name]
}

// markRefreshing marks a provider as having an in-flight refresh.
func (s *Service) markRefreshing(name string) bool {

	s.mu.Lock()
	defer s.mu.Unlock()
	if s.refreshing[name] {
		return false
	}
	s.refreshing[name] = true
	return true
}

// clearRefreshing clears the in-flight refresh marker.
func (s *Service) clearRefreshing(name string) {

	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.refreshing, name)
}

// ensureProviderConfigured applies stored credentials to a provider.
func (s *Service) ensureProviderConfigured(name string) {

	if s.registry == nil {
		return
	}
	if p := s.registry.Get(name); p != nil {
		s.applyStoredCredentials(name, p)
	}
}

// List returns all available providers with their status.
func (s *Service) List() []Info {

	if s.registry == nil {
		return nil
	}
	providers := s.registry.List()
	active := s.registry.GetActive()

	info := make([]Info, len(providers))
	for i, p := range providers {
		// Trigger stale-check; method schedules background refresh only when needed.
		s.refreshResourcesIfStale(p.Name())
		fields := s.providerCredentialFields(p)
		isConfigured := s.isProviderConfigured(p.Name(), fields)
		hasHealthyStatus := s.hasSuccessfulStatus(p.Name())
		// Skip loading inputs during list to avoid blocking - credentials are only needed on connect/configure
		info[i] = Info{
			Name:             p.Name(),
			DisplayName:      p.DisplayName(),
			CredentialFields: fields,
			CredentialValues: nil, // Load on demand, not during list
			Models:           p.Models(),
			Resources:        s.GetResources(p.Name()),
			IsConnected:      isConfigured || hasHealthyStatus,
			IsActive:         active != nil && active.Name() == p.Name(),
			Status:           s.GetStatus(p.Name()),
		}
	}
	return info
}

// Connect configures, validates, and persists a provider connection.
func (s *Service) Connect(ctx context.Context, name string, credentials ProviderCredentials) (Info, error) {

	s.logInfo("Connecting provider", LogField{Key: "provider", Value: name})
	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		s.logWarn("Provider not found during connect", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, credentials)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		s.logWarn("Missing required credentials", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to configure provider", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	// Use a timeout for the connection test/list
	ctx, cancel := context.WithTimeout(ctx, 12*time.Second)
	defer cancel()

	usedLister, err := s.validateProvider(ctx, name, p)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		if usedLister {
			if errors.Is(err, errNoResources) {
				s.logWarn("No resources returned", err, LogField{Key: "provider", Value: name})
			} else {
				s.logError("Failed to list resources", err, LogField{Key: "provider", Value: name})
			}
		} else {
			s.logError("Connection test failed", err, LogField{Key: "provider", Value: name})
		}
		return Info{}, err
	}

	if err := s.persistCredentials(name, fields, credentials); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to save credentials", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	s.registry.SetActive(name)
	s.logInfo("Provider connected successfully", LogField{Key: "provider", Value: name})

	active := s.registry.GetActive()
	s.SetStatus(name, true, "")
	inputs := s.loadProviderInputs(p.Name())
	return Info{
		Name:             p.Name(),
		DisplayName:      p.DisplayName(),
		CredentialFields: fields,
		CredentialValues: filterCredentialValues(fields, inputs, false),
		Models:           p.Models(),
		Resources:        s.GetResources(p.Name()),
		IsConnected:      s.isProviderConfigured(p.Name(), fields),
		IsActive:         active != nil && active.Name() == p.Name(),
		Status:           s.GetStatus(p.Name()),
	}, nil
}

// Disconnect removes a provider's credentials and resets its state.
func (s *Service) Disconnect(name string) error {

	s.logInfo("Disconnecting provider", LogField{Key: "provider", Value: name})
	fields := s.providerCredentialFields(s.registry.Get(name))
	if err := s.clearStoredCredentials(name, fields); err != nil {
		s.logError("Failed to remove credentials", err, LogField{Key: "provider", Value: name})
		return fmt.Errorf("failed to remove credentials: %w", err)
	}

	// 2. Clear from registry/memory
	p := s.registry.Get(name)
	if p != nil {
		clear := make(ProviderCredentials)
		for _, field := range fields {
			clear[field.Name] = ""
		}
		_ = p.Configure(Config{Credentials: clear})
	}

	// 3. Clear cached resources
	s.SetResources(name, nil)
	s.ClearStatus(name)

	// 4. Update active provider if needed
	active := s.registry.GetActive()
	if active != nil && active.Name() == name {
		nextActive := s.selectNextActiveProvider(name)
		if nextActive == "" {
			_ = s.registry.SetActive("")
		} else if s.registry.SetActive(nextActive) {
			s.ensureProviderConfigured(nextActive)
		} else {
			_ = s.registry.SetActive("")
		}
	}

	return nil
}

// selectNextActiveProvider finds the next connected provider after the given name.
func (s *Service) selectNextActiveProvider(disconnected string) string {

	if s.registry == nil {
		return ""
	}

	providers := s.registry.List()
	if len(providers) == 0 {
		return ""
	}

	startIndex := 0
	for i, p := range providers {
		if p != nil && p.Name() == disconnected {
			startIndex = i + 1
			break
		}
	}

	for offset := 0; offset < len(providers); offset++ {
		index := (startIndex + offset) % len(providers)
		candidate := providers[index]
		if candidate == nil {
			continue
		}
		name := candidate.Name()
		if name == "" || name == disconnected {
			continue
		}
		if s.isProviderConfigured(name, s.providerCredentialFields(candidate)) {
			return name
		}
	}

	return ""
}

// Configure updates and persists provider credentials while refreshing status.
func (s *Service) Configure(name string, credentials ProviderCredentials) error {

	s.logInfo("Configuring provider", LogField{Key: "provider", Value: name})
	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		s.logWarn("Provider not found during configure", err, LogField{Key: "provider", Value: name})
		return err
	}
	trimmedInput := mergeCredentialValues(nil, credentials)
	if len(trimmedInput) == 0 {
		err := fmt.Errorf("credentials required for provider: %s", name)
		s.SetStatus(name, false, err.Error())
		s.logWarn("Empty credentials during configure", err, LogField{Key: "provider", Value: name})
		return err
	}
	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, credentials)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		s.logWarn("Missing required credentials", err, LogField{Key: "provider", Value: name})
		return err
	}
	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to configure provider", err, LogField{Key: "provider", Value: name})
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 12*time.Second)
	defer cancel()

	usedLister, err := s.validateProvider(ctx, name, p)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		if usedLister {
			if errors.Is(err, errNoResources) {
				s.logWarn("No resources returned", err, LogField{Key: "provider", Value: name})
			} else {
				s.logError("Failed to list resources", err, LogField{Key: "provider", Value: name})
			}
		} else {
			s.logError("Connection test failed", err, LogField{Key: "provider", Value: name})
		}
		return err
	}

	if err := s.persistCredentials(name, fields, credentials); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to save credentials", err, LogField{Key: "provider", Value: name})
		return err
	}

	s.SetStatus(name, true, "")
	return nil
}

// SetActive sets the active provider.
func (s *Service) SetActive(name string) bool {

	s.logInfo("Setting active provider", LogField{Key: "provider", Value: name})
	return s.registry.SetActive(name)
}

// TestConnection tests the connection to a provider.
func (s *Service) TestConnection(ctx context.Context, name string) error {

	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		return err
	}
	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, nil)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	if err := p.TestConnection(ctx); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logWarn("Test connection failed", err, LogField{Key: "provider", Value: name})
		return err
	}
	s.SetStatus(name, true, "")
	return nil
}

// RefreshResources fetches the latest resources from the provider.
func (s *Service) RefreshResources(ctx context.Context, name string) error {

	s.logDebug("Refreshing resources", LogField{Key: "provider", Value: name})
	if ctx == nil {
		ctx = context.Background()
	}
	if _, hasDeadline := ctx.Deadline(); !hasDeadline {
		timeoutCtx, cancel := context.WithTimeout(ctx, 12*time.Second)
		defer cancel()
		ctx = timeoutCtx
	}
	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		return err
	}

	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, nil)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	if lister, ok := p.(resourceLister); ok {
		resources, err := lister.ListResources(ctx)
		if err != nil {
			s.SetStatus(name, false, err.Error())
			s.logError("Failed to refresh resources", err, LogField{Key: "provider", Value: name})
			return err
		}
		if len(resources) == 0 {
			err := fmt.Errorf("no resources returned from provider")
			s.SetStatus(name, false, err.Error())
			return err
		}
		s.SetResources(name, resources)
		s.SetStatus(name, true, "")
		return nil
	}
	if err := s.TestConnection(ctx, name); err != nil {
		return err
	}
	return nil
}

// GetResources returns a copy of cached resources for a provider.
func (s *Service) GetResources(name string) []Model {

	s.mu.RLock()
	resources := s.resources[name]
	s.mu.RUnlock()

	if resources == nil {
		return nil
	}

	cloned := make([]Model, len(resources))
	copy(cloned, resources)
	return cloned
}

// SetResources updates cached resources for a provider.
func (s *Service) SetResources(name string, resources []Model) {

	s.mu.Lock()
	if resources == nil {
		delete(s.resources, name)
		delete(s.resourceUpdatedAt, name)
	} else {
		s.resources[name] = resources
		s.resourceUpdatedAt[name] = time.Now().UnixMilli()
	}
	snapshot := s.buildCacheSnapshotLocked()
	s.mu.Unlock()

	if s.cache != nil {
		_ = s.cache.Save(snapshot)
	}
	s.applyEnabledModels(name, resources)
}

// buildCacheSnapshotLocked generates the cache snapshot from locked state.
func (s *Service) buildCacheSnapshotLocked() CacheSnapshot {

	snapshot := make(CacheSnapshot, len(s.resources))
	for name, resources := range s.resources {
		snapshot[name] = CacheEntry{
			UpdatedAt: s.resourceUpdatedAt[name],
			Models:    resources,
		}
	}
	return snapshot
}

// indexModelsByID builds a lookup map for models.
func indexModelsByID(models []Model) map[string]Model {

	index := make(map[string]Model, len(models))
	for _, model := range models {
		if model.ID == "" {
			continue
		}
		index[model.ID] = model
	}
	return index
}

// selectModelsByID returns models in the order of provided IDs.
func selectModelsByID(ids []string, available map[string]Model) []Model {

	selected := make([]Model, 0, len(ids))
	for _, id := range ids {
		if model, ok := available[id]; ok {
			selected = append(selected, model)
		}
	}
	return selected
}

// buildFallbackModels constructs model structs from IDs.
func buildFallbackModels(ids []string) []Model {

	models := make([]Model, 0, len(ids))
	for _, id := range ids {
		models = append(models, Model{
			ID:   id,
			Name: id,
		})
	}
	return models
}

// copyUpdateFrequency clones the update frequency map.
func copyUpdateFrequency(input map[string]time.Duration) map[string]time.Duration {

	if input == nil {
		return nil
	}
	result := make(map[string]time.Duration, len(input))
	for name, value := range input {
		result[name] = value
	}
	return result
}

// GetStatus returns the last recorded status for a provider.
func (s *Service) GetStatus(name string) *Status {

	s.mu.RLock()
	defer s.mu.RUnlock()
	status, ok := s.status[name]
	if !ok {
		return nil
	}
	result := status
	return &result
}

// hasSuccessfulStatus returns true if the provider has a cached successful status.
func (s *Service) hasSuccessfulStatus(name string) bool {

	s.mu.RLock()
	defer s.mu.RUnlock()
	status, ok := s.status[name]
	return ok && status.OK
}


// SetStatus records a provider status check result.
func (s *Service) SetStatus(name string, ok bool, message string) {

	s.mu.Lock()
	defer s.mu.Unlock()
	s.status[name] = Status{
		OK:        ok,
		Message:   message,
		CheckedAt: time.Now().UnixMilli(),
	}
}

// ClearStatus removes any stored status for a provider.
func (s *Service) ClearStatus(name string) {

	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.status, name)
}

// GetActiveProvider returns the currently active provider.
func (s *Service) GetActiveProvider() Provider {

	if s.registry == nil {
		return nil
	}
	return s.registry.GetActive()
}

// GetProvider returns a provider by name.
func (s *Service) GetProvider(name string) Provider {

	if s.registry == nil {
		return nil
	}
	return s.registry.Get(name)
}

func (s *Service) logDebug(message string, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Debug(message, fields...)
}

func (s *Service) logInfo(message string, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Info(message, fields...)
}

func (s *Service) logWarn(message string, err error, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Warn(message, err, fields...)
}

func (s *Service) logError(message string, err error, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Error(message, err, fields...)
}

```


--| internal/features/settings/usecase/types.go

```go
// types.go re-exports provider interface types for the provider use case.
// internal/features/settings/usecase/types.go
package provider

import (
	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

type Provider = providercore.Provider
type Config = providercore.ProviderConfig
type ProviderMessage = providergateway.ProviderMessage
type ChatOptions = providergateway.ChatOptions
type Role = providergateway.Role
type Model = providercore.Model
type Tool = providergateway.Tool
type Chunk = providergateway.Chunk
type UsageStats = providergateway.UsageStats
type CredentialField = providercore.CredentialField
type ProviderCredentials = providercore.ProviderCredentials

type Registry = providercore.ProviderRegistry
type Cache = providercore.ProviderCache
type CacheSnapshot = providercore.ProviderCacheSnapshot
type CacheEntry = providercore.ProviderCacheEntry
type SecretStore = providercore.SecretStore
type InputsStore = providercore.ProviderInputsStore
type Logger = coreports.Logger
type LogField = coreports.LogField

```


--| internal/features/settings/wiring/model_access.go

```go
// reconcile enabled model selections from configuration.
// internal/features/settings/wiring/model_access.go
package wiring

import (
	"strings"

	"github.com/MadeByDoug/wls-chatbot/internal/features/settings/config"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
)

// ResolveEnabledModelsFromConfig returns enabled models from configuration only.
func ResolveEnabledModelsFromConfig(cfg config.AppConfig, providerName string, defaultModel string) []providercore.Model {
	providerConfig := findProviderConfig(&cfg, providerName)
	enabledIDs := []string{}
	if providerConfig != nil {
		enabledIDs = normalizeModelIDs(enabledModelIDs(providerConfig.Models))
	}
	trimmedDefault := strings.TrimSpace(defaultModel)
	if trimmedDefault != "" && !containsString(enabledIDs, trimmedDefault) {
		enabledIDs = append(enabledIDs, trimmedDefault)
	}
	return buildFallbackModels(enabledIDs)
}

// findProviderConfig returns the provider config entry for a name.
func findProviderConfig(cfg *config.AppConfig, providerName string) *config.ProviderConfig {
	for i := range cfg.Providers {
		if cfg.Providers[i].Name == providerName {
			return &cfg.Providers[i]
		}
	}
	return nil
}

// enabledModelIDs extracts enabled model IDs from config.
func enabledModelIDs(models []config.ModelConfig) []string {
	enabled := make([]string, 0, len(models))
	for _, model := range models {
		if !model.Enabled {
			continue
		}
		enabled = append(enabled, model.ID)
	}
	return enabled
}

// normalizeModelIDs trims and deduplicates model IDs.
func normalizeModelIDs(ids []string) []string {
	seen := make(map[string]struct{}, len(ids))
	normalized := make([]string, 0, len(ids))
	for _, id := range ids {
		trimmed := strings.TrimSpace(id)
		if trimmed == "" {
			continue
		}
		if _, ok := seen[trimmed]; ok {
			continue
		}
		seen[trimmed] = struct{}{}
		normalized = append(normalized, trimmed)
	}
	return normalized
}

// buildFallbackModels constructs model structs from IDs.
func buildFallbackModels(ids []string) []providercore.Model {
	models := make([]providercore.Model, 0, len(ids))
	for _, id := range ids {
		models = append(models, providercore.Model{
			ID:   id,
			Name: id,
		})
	}
	return models
}

// containsString checks whether a slice contains a value.
func containsString(values []string, target string) bool {
	for _, value := range values {
		if value == target {
			return true
		}
	}
	return false
}

```


--| internal/features/settings/wiring/providers.go

```go
// providers.go builds provider instances from application configuration.
// internal/features/settings/wiring/providers.go
package wiring

import (
	"fmt"
	"strings"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/ports"
	anthropicadapter "github.com/MadeByDoug/wls-chatbot/internal/features/providers/adapters/anthropic"
	cloudflareadapter "github.com/MadeByDoug/wls-chatbot/internal/features/providers/adapters/cloudflare"
	geminiadapter "github.com/MadeByDoug/wls-chatbot/internal/features/providers/adapters/gemini"
	grokadapter "github.com/MadeByDoug/wls-chatbot/internal/features/providers/adapters/grok"
	openaiadapter "github.com/MadeByDoug/wls-chatbot/internal/features/providers/adapters/openai"
	openrouteradapter "github.com/MadeByDoug/wls-chatbot/internal/features/providers/adapters/openrouter"
	providerregistry "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/registry"
	"github.com/MadeByDoug/wls-chatbot/internal/features/settings/config"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/core"
	providerusecase "github.com/MadeByDoug/wls-chatbot/internal/features/settings/usecase"
)

// LoadProvidersFromStore loads providers from configuration storage.
func LoadProvidersFromStore(store config.Store, secrets providercore.SecretStore) ([]providercore.Provider, error) {

	cfg, err := config.LoadConfig(store)
	if err != nil {
		return nil, err
	}
	return ProvidersFromConfig(cfg, secrets, nil)
}

// ProvidersFromConfig constructs providers from configuration.
func ProvidersFromConfig(cfg config.AppConfig, secrets providercore.SecretStore, logger coreports.Logger) ([]providercore.Provider, error) {

	providers := make([]providercore.Provider, 0, len(cfg.Providers))
	for _, p := range cfg.Providers {
		credentials := buildProviderCredentials(p, secrets)
		apiKey := strings.TrimSpace(credentials[providercore.CredentialAPIKey])
		enabledModels := ResolveEnabledModelsFromConfig(cfg, p.Name, p.DefaultModel)
		providerConfig := providercore.ProviderConfig{
			Name:         p.Name,
			DisplayName:  p.DisplayName,
			APIKey:       apiKey,
			BaseURL:      p.BaseURL,
			DefaultModel: p.DefaultModel,
			Models:       enabledModels,
			Credentials:  credentials,
			Logger:       logger,
		}
		switch p.Type {
		case "openai":
			providers = append(providers, openaiadapter.New(providerConfig))
		case "anthropic":
			providers = append(providers, anthropicadapter.New(providerConfig))
		case "gemini":
			providers = append(providers, geminiadapter.New(providerConfig))
		case "grok":
			providers = append(providers, grokadapter.New(providerConfig))
		case "cloudflare":
			providers = append(providers, cloudflareadapter.New(providerConfig))
		case "openrouter":
			providers = append(providers, openrouteradapter.New(providerConfig))
		default:
			return nil, fmt.Errorf("unknown provider type: %s", p.Type)
		}
	}
	return providers, nil
}

// buildProviderCredentials merges config inputs with stored secrets.
func buildProviderCredentials(cfg config.ProviderConfig, secrets providercore.SecretStore) providercore.ProviderCredentials {

	credentials := make(providercore.ProviderCredentials)
	for key, value := range cfg.Inputs {
		if strings.TrimSpace(value) == "" {
			continue
		}
		credentials[key] = value
	}

	secretFields := providerSecretFields(cfg.Type)
	if secrets != nil && len(secretFields) > 0 {
		for _, field := range secretFields {
			if value, err := secrets.GetProviderSecret(cfg.Name, field); err == nil && strings.TrimSpace(value) != "" {
				credentials[field] = value
			}
		}
	}

	if len(credentials) == 0 {
		return nil
	}
	return credentials
}

// providerSecretFields returns secret credential field names for a provider type.
func providerSecretFields(providerType string) []string {

	switch providerType {
	case "openai", "anthropic", "gemini", "grok":
		return []string{providercore.CredentialAPIKey}
	case "openrouter":
		return []string{providercore.CredentialAPIKey}
	case "cloudflare":
		return []string{
			providercore.CredentialCloudflareToken,
			providercore.CredentialAPIKey,
			providercore.CredentialToken,
		}
	default:
		return nil
	}
}

// BuildProviderService wires provider adapters into the provider use case.
func BuildProviderService(cfg config.AppConfig, cache providercore.ProviderCache, secrets providercore.SecretStore, inputs providercore.ProviderInputsStore, logger coreports.Logger) (*providerusecase.Service, providercore.ProviderRegistry, error) {

	registry := providerregistry.New()
	providerConfigs, providerErr := ProvidersFromConfig(cfg, secrets, logger)
	if providerErr == nil {
		for _, p := range providerConfigs {
			registry.Register(p)
		}
	}

	updateFrequency, frequencyErr := config.ResolveUpdateFrequencies(cfg)
	service := providerusecase.NewService(registry, cache, secrets, inputs, updateFrequency, logger)
	if providerErr != nil {
		return service, registry, providerErr
	}
	if frequencyErr != nil {
		return service, registry, frequencyErr
	}
	return service, registry, nil
}

```


--| main.go

```go
// bootstrap the Wails application and wire dependencies.
// main.go
package main

import (
	"context"
	"database/sql"
	"embed"
	"path/filepath"
	"strings"

	"github.com/MadeByDoug/wls-chatbot/internal/core/adapters/datastore"
	"github.com/MadeByDoug/wls-chatbot/internal/core/adapters/logger"
	wailsadapter "github.com/MadeByDoug/wls-chatbot/internal/core/adapters/wails"
	"github.com/MadeByDoug/wls-chatbot/internal/features/catalog/adapters/catalogrepo"
	catalogusecase "github.com/MadeByDoug/wls-chatbot/internal/features/catalog/usecase"
	"github.com/MadeByDoug/wls-chatbot/internal/features/chat/adapters/chatrepo"
	chatusecase "github.com/MadeByDoug/wls-chatbot/internal/features/chat/usecase"
	"github.com/MadeByDoug/wls-chatbot/internal/features/notifications/adapters/notificationrepo"
	notificationusecase "github.com/MadeByDoug/wls-chatbot/internal/features/notifications/usecase"
	"github.com/MadeByDoug/wls-chatbot/internal/features/settings/config"
	providercache "github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/cache"
	"github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/configstore"
	"github.com/MadeByDoug/wls-chatbot/internal/features/providers/core/securestore"
	providerusecase "github.com/MadeByDoug/wls-chatbot/internal/features/settings/usecase"
	"github.com/MadeByDoug/wls-chatbot/internal/features/settings/wiring"

	"github.com/rs/zerolog"
	"github.com/spf13/cobra"
	"github.com/wailsapp/wails/v2"
	"github.com/wailsapp/wails/v2/pkg/options"
	"github.com/wailsapp/wails/v2/pkg/options/assetserver"

	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"os"

	"github.com/MadeByDoug/wls-chatbot/internal/features/providers/interfaces/gateway"
)

//go:embed all:frontend/dist
var assets embed.FS

const AppName = "wls-chatbot"
const KeyringServiceName = "github.com/MadeByDoug/wls-chatbot"

// main is the application entry point.
func main() {

	// 0. Initialize Logger
	log := logger.New("info")
	cmd := newRootCommand(log)

	// Add commands
	cmd.AddCommand(newGenerateCommand(log))
	cmd.AddCommand(newModelCommand(log))
	cmd.AddCommand(newProviderCommand(log))

	if err := cmd.Execute(); err != nil {
		os.Exit(1)
	}

}

// newRootCommand builds the CLI entrypoint.
func newRootCommand(log zerolog.Logger) *cobra.Command {

	var dbPath string
	var logLevel string
	cmd := &cobra.Command{
		Use:          AppName,
		Short:        "Wails Lit Starter ChatBot",
		SilenceUsage: true,
		RunE: func(cmd *cobra.Command, _ []string) error {
			if logLevel != "" {
				log = logger.New(logLevel)
			} else {
				log = logger.New("info")
			}
			log.Info().Msg("Starting Wails Lit Starter ChatBot...")
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			defer func() {
				_ = db.Close()
			}()
			store, err := configstore.NewSQLiteStore(db)
			if err != nil {
				return err
			}
			cfg, err := config.LoadConfig(store)
			if err != nil {
				return err
			}
			return runUI(log, cfg, db)
		},
	}

	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")
	cmd.Flags().StringVar(&logLevel, "log-level", "debug", "Log level (debug, info, warn, error)")
	return cmd
}

// runUI wires dependencies and launches the app.
func runUI(log zerolog.Logger, cfg config.AppConfig, db *sql.DB) error {

	bridgeService, logBridge, err := setupApp(log, cfg, db)
	if err != nil {
		if bridgeService == nil || logBridge == nil {
			return err
		}
		log.Warn().Err(err).Msg("Failed to initialize app services; continuing with defaults")
	}

	// Create application with options
	if err := wails.Run(&options.App{
		Title:  "Wails Lit Starter ChatBot",
		Width:  1024,
		Height: 768,
		Logger: logger.NewWailsLogger(log),
		AssetServer: &assetserver.Options{
			Assets: assets,
		},
		BackgroundColour: &options.RGBA{R: 27, G: 38, B: 54, A: 255},
		OnStartup:        bridgeService.Startup,
		OnShutdown:       bridgeService.Shutdown,
		Bind: []interface{}{
			bridgeService,
			logBridge,
		},
	}); err != nil {
		return err
	}

	return nil
}

// setupApp wires application services and adapters.
func setupApp(log zerolog.Logger, cfg config.AppConfig, db *sql.DB) (*wailsadapter.Bridge, *logger.Logger, error) {

	coreLogger := logger.NewAdapter(log)
	secrets := securestore.NewKeyringStore(KeyringServiceName)
	cache, cacheErr := providercache.NewSQLiteStore(db)
	if cacheErr != nil {
		return nil, nil, cacheErr
	}
	catalogRepository, catalogErr := catalogrepo.NewRepository(db)
	if catalogErr != nil {
		return nil, nil, catalogErr
	}
	for _, providerConfig := range cfg.Providers {
		if _, err := catalogRepository.EnsureProvider(context.Background(), catalogrepo.ProviderRecord{
			Name:        providerConfig.Name,
			DisplayName: providerConfig.DisplayName,
			AdapterType: providerConfig.Type,
			TrustMode:   "user_managed",
			BaseURL:     providerConfig.BaseURL,
		}); err != nil {
			return nil, nil, err
		}
	}

	providerService, registry, err := wiring.BuildProviderService(cfg, cache, secrets, catalogRepository, coreLogger)

	chatRepo, repoErr := chatrepo.NewRepository(db)
	if repoErr != nil {
		return nil, nil, repoErr
	}
	chatService := chatusecase.NewService(chatRepo)

	notificationRepo, notificationErr := notificationrepo.NewRepository(db)
	if notificationErr != nil {
		return nil, nil, notificationErr
	}
	notificationService := notificationusecase.NewService(notificationRepo)

	emitter := &wailsadapter.Emitter{}
	catalogService := catalogusecase.NewService(catalogRepository, providerService, cfg, coreLogger)
	catalogOrchestrator := catalogusecase.NewOrchestrator(catalogService, emitter)
	bridgeService := wailsadapter.New(
		chatusecase.NewOrchestrator(chatService, registry, secrets, emitter),
		providerusecase.NewOrchestrator(providerService, secrets, emitter),
		catalogOrchestrator,
		notificationusecase.NewOrchestrator(notificationService),
		emitter,
	)
	logBridge := logger.NewLogBridge(log)

	return bridgeService, logBridge, err
}

// resolveDatabasePath resolves the SQLite database path to use.
func resolveDatabasePath(override string) (string, error) {

	if strings.TrimSpace(override) != "" {
		return override, nil
	}

	appDataDir, err := config.ResolveAppDataDir(AppName)
	if err != nil {
		return "", err
	}

	return filepath.Join(appDataDir, "appdata.db"), nil
}

// newGenerateCommand creates the parent 'generate' command.
func newGenerateCommand(log zerolog.Logger) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "generate",
		Short: "Generate content using AI providers",
	}
	cmd.AddCommand(newGenerateImageCommand(log))
	cmd.AddCommand(newGenerateImageEditCommand(log))
	return cmd
}

// newGenerateImageCommand creates the 'generate image' command.
func newGenerateImageCommand(log zerolog.Logger) *cobra.Command {
	var providerName string
	var modelName string
	var prompt string
	var outputPath string
	var dbPath string

	cmd := &cobra.Command{
		Use:   "image",
		Short: "Generate an image",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			// 1. Initialize dependencies
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			defer func() { _ = db.Close() }()

			store, err := configstore.NewSQLiteStore(db)
			if err != nil {
				return err
			}
			cfg, err := config.LoadConfig(store)
			if err != nil {
				return err
			}

			// 2. Initialize Secrets & Providers
			secrets := securestore.NewKeyringStore(KeyringServiceName)
			coreLogger := logger.NewAdapter(log)
			providers, err := wiring.ProvidersFromConfig(cfg, secrets, coreLogger)
			if err != nil {
				return err
			}

			// 3. Find requested provider
			var provider gateway.Provider
			for _, p := range providers {
				if strings.EqualFold(p.Name(), providerName) {
					provider = p
					break
				}
			}
			if provider == nil {
				return fmt.Errorf("provider '%s' not found or not configured", providerName)
			}

			// 4. Generate Image
			log.Info().Str("provider", providerName).Str("model", modelName).Msg("Generating image...")
			
			// Default n=1; provider adapters apply provider-specific defaults.
			opts := gateway.ImageGenerationOptions{
				Model:  modelName,
				Prompt: prompt,
				N:      1,
			}

			result, err := provider.GenerateImage(context.Background(), opts)
			if err != nil {
				return fmt.Errorf("generation failed: %w", err)
			}

			if len(result.Data) == 0 {
				return fmt.Errorf("no image data returned")
			}

			imageData := result.Data[0]
			var imageBytes []byte

			if imageData.B64JSON != "" {
				imageBytes, err = base64.StdEncoding.DecodeString(imageData.B64JSON)
				if err != nil {
					return fmt.Errorf("failed to decode base64 image: %w", err)
				}
			} else if imageData.URL != "" {
				// Download URL
				resp, err := http.Get(imageData.URL)
				if err != nil {
					return fmt.Errorf("failed to download image from URL: %w", err)
				}
				defer func() { _ = resp.Body.Close() }()
				if resp.StatusCode != http.StatusOK {
					return fmt.Errorf("failed to download image, status: %d", resp.StatusCode)
				}
				imageBytes, err = io.ReadAll(resp.Body)
				if err != nil {
					return fmt.Errorf("failed to read image body: %w", err)
				}
			} else {
				return fmt.Errorf("provider returned neither Base64 nor URL for image")
			}

			// 5. Output
			if outputPath != "" {
				if err := os.WriteFile(outputPath, imageBytes, 0644); err != nil {
					return fmt.Errorf("failed to write output file: %w", err)
				}
				log.Info().Str("path", outputPath).Msg("Image saved")
			} else {
				log.Info().Int("bytes", len(imageBytes)).Msg("Image generated (use --output to save)")
				// potentially print to stdout if requested, but binary might mess up terminal
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&providerName, "provider", "", "Provider name (e.g. gemini, openai)")
	_ = cmd.MarkFlagRequired("provider")
	cmd.Flags().StringVar(&modelName, "model", "", "Model name (optional)")
	cmd.Flags().StringVar(&prompt, "prompt", "", "Image prompt")
	_ = cmd.MarkFlagRequired("prompt")
	cmd.Flags().StringVar(&outputPath, "output", "", "Output path for the generated image")
	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")

	return cmd
}

// newGenerateImageEditCommand creates the 'generate image-edit' command.
func newGenerateImageEditCommand(log zerolog.Logger) *cobra.Command {
	var providerName string
	var modelName string
	var prompt string
	var outputPath string
	var imagePath string
	var maskPath string
	var dbPath string

	cmd := &cobra.Command{
		Use:   "image-edit",
		Short: "Edit an image",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			// 1. Initialize dependencies
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			defer func() { _ = db.Close() }()

			store, err := configstore.NewSQLiteStore(db)
			if err != nil {
				return err
			}
			cfg, err := config.LoadConfig(store)
			if err != nil {
				return err
			}

			// 2. Initialize Secrets & Providers
			secrets := securestore.NewKeyringStore(KeyringServiceName)
			coreLogger := logger.NewAdapter(log)
			providers, err := wiring.ProvidersFromConfig(cfg, secrets, coreLogger)
			if err != nil {
				return err
			}

			// 3. Find requested provider
			var provider gateway.Provider
			for _, p := range providers {
				if strings.EqualFold(p.Name(), providerName) {
					provider = p
					break
				}
			}
			if provider == nil {
				return fmt.Errorf("provider '%s' not found or not configured", providerName)
			}

			// 4. Edit Image
			log.Info().Str("provider", providerName).Str("model", modelName).Msg("Editing image...")
			
			opts := gateway.ImageEditOptions{
				Model:  modelName,
				Prompt: prompt,
				Image:  imagePath,
				Mask:   maskPath,
				N:      1,
			}

			result, err := provider.EditImage(context.Background(), opts)
			if err != nil {
				return fmt.Errorf("editing failed: %w", err)
			}

			if len(result.Data) == 0 {
				return fmt.Errorf("no image data returned")
			}

			imageData := result.Data[0]
			var imageBytes []byte

			if imageData.B64JSON != "" {
				imageBytes, err = base64.StdEncoding.DecodeString(imageData.B64JSON)
				if err != nil {
					return fmt.Errorf("failed to decode base64 image: %w", err)
				}
			} else if imageData.URL != "" {
				// Download URL
				resp, err := http.Get(imageData.URL)
				if err != nil {
					return fmt.Errorf("failed to download image from URL: %w", err)
				}
				defer func() { _ = resp.Body.Close() }()
				if resp.StatusCode != http.StatusOK {
					return fmt.Errorf("failed to download image, status: %d", resp.StatusCode)
				}
				imageBytes, err = io.ReadAll(resp.Body)
				if err != nil {
					return fmt.Errorf("failed to read image body: %w", err)
				}
			} else {
				return fmt.Errorf("provider returned neither Base64 nor URL for image")
			}

			// 5. Output
			if outputPath != "" {
				if err := os.WriteFile(outputPath, imageBytes, 0644); err != nil {
					return fmt.Errorf("failed to write output file: %w", err)
				}
				log.Info().Str("path", outputPath).Msg("Image saved")
			} else {
				log.Info().Int("bytes", len(imageBytes)).Msg("Image generated (use --output to save)")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&providerName, "provider", "", "Provider name (e.g. gemini, openai)")
	_ = cmd.MarkFlagRequired("provider")
	cmd.Flags().StringVar(&modelName, "model", "", "Model name (optional)")
	cmd.Flags().StringVar(&prompt, "prompt", "", "Image prompt")
	_ = cmd.MarkFlagRequired("prompt")
	cmd.Flags().StringVar(&imagePath, "image", "", "Input image path")
	_ = cmd.MarkFlagRequired("image")
	cmd.Flags().StringVar(&maskPath, "mask", "", "Input mask path (optional)")
	cmd.Flags().StringVar(&outputPath, "output", "", "Output path for the generated image")
	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")

	return cmd
}

// newModelCommand creates the 'model' command with subcommands.
func newModelCommand(log zerolog.Logger) *cobra.Command {
	cmd := &cobra.Command{
		Use:     "model",
		Aliases: []string{"models"},
		Short:   "Manage model catalog",
	}
	cmd.AddCommand(newModelListCommand(log))
	cmd.AddCommand(newModelImportCommand(log))
	cmd.AddCommand(newModelSyncCommand(log))
	return cmd
}

// newModelListCommand lists models in the catalog.
func newModelListCommand(log zerolog.Logger) *cobra.Command {
	var dbPath string
	var source string

	cmd := &cobra.Command{
		Use:   "list",
		Short: "List models in the catalog",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			fmt.Println("DEBUG: model list starting...")
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			fmt.Printf("DEBUG: using database path: %s\n", databasePath)
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			fmt.Println("DEBUG: database opened")
			defer func() { _ = db.Close() }()

			repo, err := catalogrepo.NewRepository(db)
			if err != nil {
				return err
			}
			fmt.Println("DEBUG: repository initialized")

			summaries, err := repo.ListModelSummaries(context.Background())
			if err != nil {
				return err
			}

			fmt.Printf("%-40s %-15s %-12s %-10s\n", "MODEL ID", "PROVIDER", "SOURCE", "APPROVED")
			fmt.Println(strings.Repeat("-", 80))
			for _, s := range summaries {
				if source != "" && s.Source != source {
					continue
				}
				approved := "no"
				if s.Approved {
					approved = "yes"
				}
				// Extract provider from endpoint
				provider := s.EndpointID
				if idx := strings.Index(provider, "_"); idx > 0 {
					provider = provider[idx+1:]
					if idx2 := strings.Index(provider, "_"); idx2 > 0 {
						provider = provider[:idx2]
					}
				}
				fmt.Printf("%-40s %-15s %-12s %-10s\n", s.ModelID, provider, s.Source, approved)
			}
			return nil
		},
	}
	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")
	cmd.Flags().StringVar(&source, "source", "", "Filter by source (seed, user, discovered)")
	return cmd
}

// newModelImportCommand imports custom models from a YAML file.
func newModelImportCommand(log zerolog.Logger) *cobra.Command {
	var dbPath string
	var filePath string

	cmd := &cobra.Command{
		Use:   "import",
		Short: "Import custom models from a YAML file",
		Long:  "Import custom models from a YAML file. Format matches models.yaml structure.",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			defer func() { _ = db.Close() }()

			data, err := os.ReadFile(filePath)
			if err != nil {
				return fmt.Errorf("read custom models file: %w", err)
			}

			if err := datastore.SeedModels(db, data); err != nil {
				return fmt.Errorf("import custom models: %w", err)
			}

			fmt.Println("Custom models imported successfully.")
			return nil
		},
	}
	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")
	cmd.Flags().StringVar(&filePath, "file", "", "Path to the custom models YAML file")
	_ = cmd.MarkFlagRequired("file")
	return cmd
}

// newModelSyncCommand re-syncs custom models from the default location.
func newModelSyncCommand(log zerolog.Logger) *cobra.Command {
	var dbPath string

	cmd := &cobra.Command{
		Use:   "sync",
		Short: "Sync custom models from ~/.wls-chatbot/custom-models.yaml",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			defer func() { _ = db.Close() }()

			appDataDir, err := config.ResolveAppDataDir(AppName)
			if err != nil {
				return err
			}
			customPath := filepath.Join(appDataDir, "custom-models.yaml")

			data, err := os.ReadFile(customPath)
			if err != nil {
				if os.IsNotExist(err) {
					fmt.Printf("No custom models file found at %s\n", customPath)
					return nil
				}
				return fmt.Errorf("read custom models file: %w", err)
			}

			if err := datastore.SeedModels(db, data); err != nil {
				return fmt.Errorf("sync custom models: %w", err)
			}

			fmt.Printf("Custom models synced from %s\n", customPath)
			return nil
		},
	}
	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")
	return cmd
}

// newProviderCommand creates the parent 'provider' command.
func newProviderCommand(log zerolog.Logger) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "provider",
		Short: "Manage AI providers",
	}
	cmd.AddCommand(newProviderListCommand(log))
	cmd.AddCommand(newProviderTestCommand(log))
	return cmd
}

// newProviderListCommand lists configured providers.
func newProviderListCommand(log zerolog.Logger) *cobra.Command {
	var dbPath string

	cmd := &cobra.Command{
		Use:   "list",
		Short: "List configured providers",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			defer func() { _ = db.Close() }()

			store, err := configstore.NewSQLiteStore(db)
			if err != nil {
				return err
			}
			cfg, err := config.LoadConfig(store)
			if err != nil {
				return err
			}

			fmt.Printf("%-15s %-20s %-10s\n", "NAME", "TYPE", "CONFIGURED")
			fmt.Println(strings.Repeat("-", 50))
			secrets := securestore.NewKeyringStore(KeyringServiceName)
			for _, p := range cfg.Providers {
				configured := "no"
				// Check if API key is configured
				if secrets.HasProviderSecret(p.Name, "apiKey") {
					configured = "yes"
				}
				fmt.Printf("%-15s %-20s %-10s\n", p.Name, p.Type, configured)
			}
			return nil
		},
	}
	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")
	return cmd
}

// newProviderTestCommand tests a provider connection.
func newProviderTestCommand(log zerolog.Logger) *cobra.Command {
	var dbPath string
	var providerName string

	cmd := &cobra.Command{
		Use:   "test",
		Short: "Test a provider connection",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, args []string) error {
			databasePath, err := resolveDatabasePath(dbPath)
			if err != nil {
				return err
			}
			db, err := datastore.OpenSQLite(databasePath)
			if err != nil {
				return err
			}
			defer func() { _ = db.Close() }()

			store, err := configstore.NewSQLiteStore(db)
			if err != nil {
				return err
			}
			cfg, err := config.LoadConfig(store)
			if err != nil {
				return err
			}

			// Initialize Secrets & Providers
			secrets := securestore.NewKeyringStore(KeyringServiceName)
			coreLogger := logger.NewAdapter(log)
			providers, err := wiring.ProvidersFromConfig(cfg, secrets, coreLogger)
			if err != nil {
				return err
			}

			// Find requested provider
			var provider gateway.Provider
			for _, p := range providers {
				if strings.EqualFold(p.Name(), providerName) {
					provider = p
					break
				}
			}
			if provider == nil {
				return fmt.Errorf("provider '%s' not found or not configured", providerName)
			}

			// Test connection
			fmt.Printf("Testing connection to %s...\n", providerName)
			err = provider.TestConnection(context.Background())
			if err != nil {
				fmt.Printf(" Connection failed: %v\n", err)
				return err
			}
			fmt.Printf(" Connection successful!\n")
			return nil
		},
	}
	cmd.Flags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")
	cmd.Flags().StringVar(&providerName, "name", "", "Provider name to test")
	_ = cmd.MarkFlagRequired("name")
	return cmd
}

```


--| pkg/zerologtest/assertions.go

```go
// assertions.go provides matcher utilities and test diagnostics for captured entries.
// pkg/zerologtest/assertions.go
package zerologtest

import (
	"fmt"
	"strings"
	"testing"
)

// AssertionOption configures assertion diagnostics behavior.
type AssertionOption func(config *assertionConfig)

// assertionConfig defines assertion rendering defaults.
type assertionConfig struct {
	lastNEntries int
	focusFields  []string
}

var defaultFocusFields = []string{
	FieldEventCode,
	FieldLevel,
	FieldComponent,
	FieldOp,
	FieldStatus,
	FieldMessage,
}

// WithLastNEntries limits diagnostic output to the last N entries.
func WithLastNEntries(lastNEntries int) AssertionOption {

	return func(config *assertionConfig) {
		if lastNEntries > 0 {
			config.lastNEntries = lastNEntries
		}
	}
}

// WithFocusFields appends additional fields to diagnostic output.
func WithFocusFields(fields ...string) AssertionOption {

	return func(config *assertionConfig) {
		for _, field := range fields {
			if strings.TrimSpace(field) != "" {
				config.focusFields = append(config.focusFields, field)
			}
		}
	}
}

// Contains returns whether any entry matches the predicate.
func Contains(entries []Entry, predicate Predicate) bool {

	if predicate == nil {
		return false
	}

	for _, entry := range entries {
		if predicate.Match(entry) {
			return true
		}
	}
	return false
}

// InOrder returns whether predicates match in the same order as entries.
func InOrder(entries []Entry, predicates ...Predicate) bool {

	normalizedPredicates := normalizePredicates(predicates)
	if len(normalizedPredicates) == 0 {
		return true
	}

	predicateIndex := 0
	for _, entry := range entries {
		if normalizedPredicates[predicateIndex].Match(entry) {
			predicateIndex++
			if predicateIndex == len(normalizedPredicates) {
				return true
			}
		}
	}

	return false
}

// AssertContains fails the test when no entry matches.
func AssertContains(t testing.TB, entries []Entry, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	if Contains(entries, predicate) {
		return
	}

	config := buildAssertionConfig(options...)
	t.Fatalf(
		"expected at least one entry matching %s, but none matched.\nRecent entries:\n%s",
		describePredicate(predicate),
		renderEntries(lastNEntries(entries, config.lastNEntries), config.focusFields),
	)
}

// AssertNotContains fails the test when any entry matches.
func AssertNotContains(t testing.TB, entries []Entry, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	if !Contains(entries, predicate) {
		return
	}

	config := buildAssertionConfig(options...)
	matchingEntries := filterEntries(entries, predicate)
	t.Fatalf(
		"expected no entries matching %s, but found %d matching entries.\nMatching entries:\n%s",
		describePredicate(predicate),
		len(matchingEntries),
		renderEntries(lastNEntries(matchingEntries, config.lastNEntries), config.focusFields),
	)
}

// AssertInOrder fails the test when predicates do not match in order.
func AssertInOrder(t testing.TB, entries []Entry, predicates []Predicate, options ...AssertionOption) {

	t.Helper()

	if InOrder(entries, predicates...) {
		return
	}

	config := buildAssertionConfig(options...)
	t.Fatalf(
		"expected entries to match predicates in order (%s), but order check failed.\nRecent entries:\n%s",
		joinPredicateDescriptions(normalizePredicates(predicates)),
		renderEntries(lastNEntries(entries, config.lastNEntries), config.focusFields),
	)
}

// AssertRecorderContains fails when recorder entries do not contain a match.
func AssertRecorderContains(t testing.TB, recorder *Recorder, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	entries := recorder.Entries()
	AssertContains(t, entries, predicate, options...)
}

// AssertRecorderNotContains fails when recorder entries contain a match.
func AssertRecorderNotContains(t testing.TB, recorder *Recorder, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	entries := recorder.Entries()
	AssertNotContains(t, entries, predicate, options...)
}

// AssertRecorderInOrder fails when recorder entries do not match predicate order.
func AssertRecorderInOrder(t testing.TB, recorder *Recorder, predicates []Predicate, options ...AssertionOption) {

	t.Helper()

	entries := recorder.Entries()
	AssertInOrder(t, entries, predicates, options...)
}

// buildAssertionConfig constructs diagnostics defaults.
func buildAssertionConfig(options ...AssertionOption) assertionConfig {

	config := assertionConfig{
		lastNEntries: 10,
		focusFields:  append([]string{}, defaultFocusFields...),
	}
	for _, option := range options {
		if option != nil {
			option(&config)
		}
	}
	config.focusFields = dedupe(config.focusFields)
	return config
}

// renderEntries renders entries with selected fields for failure diagnostics.
func renderEntries(entries []Entry, focusFields []string) string {

	if len(entries) == 0 {
		return "<no entries captured>"
	}

	var builder strings.Builder
	for index, entry := range entries {
		if index > 0 {
			builder.WriteByte('\n')
		}
		builder.WriteString(fmt.Sprintf("[%d]", index))
		for _, field := range focusFields {
			value, ok := entry.Field(field)
			if !ok {
				continue
			}
			builder.WriteString(fmt.Sprintf(" %s=%q", field, fmt.Sprint(value)))
		}
	}
	return builder.String()
}

// filterEntries returns entries that match a predicate.
func filterEntries(entries []Entry, predicate Predicate) []Entry {

	if predicate == nil {
		return nil
	}

	filtered := make([]Entry, 0, len(entries))
	for _, entry := range entries {
		if predicate.Match(entry) {
			filtered = append(filtered, copyEntry(entry))
		}
	}
	return filtered
}

// lastNEntries returns the last N entries from a slice.
func lastNEntries(entries []Entry, lastNEntries int) []Entry {

	if lastNEntries <= 0 || len(entries) <= lastNEntries {
		copied := make([]Entry, len(entries))
		for index, entry := range entries {
			copied[index] = copyEntry(entry)
		}
		return copied
	}

	start := len(entries) - lastNEntries
	copied := make([]Entry, len(entries[start:]))
	for index, entry := range entries[start:] {
		copied[index] = copyEntry(entry)
	}
	return copied
}

// dedupe removes duplicated field names while preserving order.
func dedupe(items []string) []string {

	seen := map[string]struct{}{}
	deduplicated := make([]string, 0, len(items))
	for _, item := range items {
		if _, exists := seen[item]; exists {
			continue
		}
		seen[item] = struct{}{}
		deduplicated = append(deduplicated, item)
	}
	return deduplicated
}

```


--| pkg/zerologtest/doc.go

```go
// Package zerologtest captures and asserts structured zerolog events in tests.
// pkg/zerologtest/doc.go
package zerologtest

```


--| pkg/zerologtest/entry.go

```go
// entry.go models a single structured log entry for test assertions.
// pkg/zerologtest/entry.go
package zerologtest

// Contract field names for structured log assertions.
const (
	FieldTime      = "time"
	FieldCaller    = "caller"
	FieldLevel     = "level"
	FieldMessage   = "message"
	FieldEventCode = "event_code"
	FieldComponent = "component"
	FieldOp        = "op"
	FieldStatus    = "status"
	FieldErrKind   = "err_kind"
)

// EventCodeDecodeFailed flags invalid JSON writes to the recorder.
const EventCodeDecodeFailed = "LOG_DECODE_FAILED"

// PresenceOnlyValue marks fields that were intentionally normalized to presence-only.
const PresenceOnlyValue = "<present>"

// Entry stores one captured structured log event.
type Entry struct {
	Fields map[string]any
}

// Field returns the value for a field key.
func (entry Entry) Field(key string) (any, bool) {

	value, ok := entry.Fields[key]
	return value, ok
}

// StringField returns a string field value when present.
func (entry Entry) StringField(key string) (string, bool) {

	value, ok := entry.Field(key)
	if !ok {
		return "", false
	}
	str, ok := value.(string)
	if !ok {
		return "", false
	}
	return str, true
}

// EventCode returns the contracted event code.
func (entry Entry) EventCode() string {

	value, _ := entry.StringField(FieldEventCode)
	return value
}

// Level returns the zerolog level field.
func (entry Entry) Level() string {

	value, _ := entry.StringField(FieldLevel)
	return value
}

// Message returns the log message field.
func (entry Entry) Message() string {

	value, _ := entry.StringField(FieldMessage)
	return value
}

// copyEntry clones an entry to keep snapshots immutable.
func copyEntry(entry Entry) Entry {

	return Entry{Fields: copyFields(entry.Fields)}
}

// copyFields clones field maps to avoid shared mutable references.
func copyFields(fields map[string]any) map[string]any {

	if len(fields) == 0 {
		return map[string]any{}
	}

	cloned := make(map[string]any, len(fields))
	for key, value := range fields {
		cloned[key] = value
	}
	return cloned
}

```


--| pkg/zerologtest/logger.go

```go
// logger.go builds zerolog test loggers with contract-friendly defaults.
// pkg/zerologtest/logger.go
package zerologtest

import (
	"io"

	"github.com/rs/zerolog"
)

// NewLogger creates a zerolog logger with timestamp and caller fields.
func NewLogger(writer io.Writer) zerolog.Logger {

	return zerolog.New(writer).Level(zerolog.TraceLevel).With().Timestamp().Caller().Logger()
}

```


--| pkg/zerologtest/predicate.go

```go
// predicate.go defines reusable log predicates and combinators.
// pkg/zerologtest/predicate.go
package zerologtest

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"
	"strings"
)

// Predicate matches a captured log entry.
type Predicate interface {
	// Match returns whether an entry satisfies this predicate.
	Match(entry Entry) bool
	// String describes the predicate for diagnostics.
	String() string
}

// predicateFunc adapts a function into a named Predicate.
type predicateFunc struct {
	description string
	match       func(entry Entry) bool
}

// Match runs the underlying predicate function.
func (predicate predicateFunc) Match(entry Entry) bool {

	if predicate.match == nil {
		return false
	}
	return predicate.match(entry)
}

// String returns a stable predicate description.
func (predicate predicateFunc) String() string {

	return predicate.description
}

// Match defines a custom predicate with a stable description.
func Match(description string, match func(entry Entry) bool) Predicate {

	desc := strings.TrimSpace(description)
	if desc == "" {
		desc = "custom predicate"
	}
	return predicateFunc{
		description: desc,
		match:       match,
	}
}

// HasEventCode matches entries with the provided event code.
func HasEventCode(eventCode string) Predicate {

	return Match(fmt.Sprintf("event_code == %q", eventCode), func(entry Entry) bool {
		return FieldEq(FieldEventCode, eventCode).Match(entry)
	})
}

// HasLevel matches entries with the provided level.
func HasLevel(level string) Predicate {

	return Match(fmt.Sprintf("level == %q", level), func(entry Entry) bool {
		return FieldEq(FieldLevel, level).Match(entry)
	})
}

// HasField matches entries that contain the field key.
func HasField(key string) Predicate {

	return Match(fmt.Sprintf("has field %q", key), func(entry Entry) bool {
		_, ok := entry.Field(key)
		return ok
	})
}

// FieldEq matches entries where the field value equals expected.
func FieldEq(key string, expected any) Predicate {

	return Match(fmt.Sprintf("%s == %v", key, expected), func(entry Entry) bool {
		value, ok := entry.Field(key)
		if !ok {
			return false
		}
		return valuesEqual(value, expected)
	})
}

// FieldContains matches entries where a string field includes a substring.
func FieldContains(key string, substring string) Predicate {

	return Match(fmt.Sprintf("%s contains %q", key, substring), func(entry Entry) bool {
		value, ok := entry.Field(key)
		if !ok {
			return false
		}

		switch typed := value.(type) {
		case string:
			return strings.Contains(typed, substring)
		case []string:
			for _, item := range typed {
				if strings.Contains(item, substring) {
					return true
				}
			}
		case []any:
			for _, item := range typed {
				text, ok := item.(string)
				if ok && strings.Contains(text, substring) {
					return true
				}
			}
		}

		return false
	})
}

// And matches when all predicates are true.
func And(predicates ...Predicate) Predicate {

	normalized := normalizePredicates(predicates)
	return Match("and("+joinPredicateDescriptions(normalized)+")", func(entry Entry) bool {
		for _, predicate := range normalized {
			if !predicate.Match(entry) {
				return false
			}
		}
		return true
	})
}

// Or matches when at least one predicate is true.
func Or(predicates ...Predicate) Predicate {

	normalized := normalizePredicates(predicates)
	return Match("or("+joinPredicateDescriptions(normalized)+")", func(entry Entry) bool {
		for _, predicate := range normalized {
			if predicate.Match(entry) {
				return true
			}
		}
		return false
	})
}

// Not negates a predicate.
func Not(predicate Predicate) Predicate {

	description := "not(<nil>)"
	if predicate != nil {
		description = "not(" + predicate.String() + ")"
	}
	return Match(description, func(entry Entry) bool {
		if predicate == nil {
			return true
		}
		return !predicate.Match(entry)
	})
}

// describePredicate returns a stable fallback-safe predicate description.
func describePredicate(predicate Predicate) string {

	if predicate == nil {
		return "<nil predicate>"
	}
	description := strings.TrimSpace(predicate.String())
	if description == "" {
		return "<unnamed predicate>"
	}
	return description
}

// normalizePredicates filters nil predicates for combinator safety.
func normalizePredicates(predicates []Predicate) []Predicate {

	normalized := make([]Predicate, 0, len(predicates))
	for _, predicate := range predicates {
		if predicate != nil {
			normalized = append(normalized, predicate)
		}
	}
	return normalized
}

// joinPredicateDescriptions concatenates predicate descriptions.
func joinPredicateDescriptions(predicates []Predicate) string {

	if len(predicates) == 0 {
		return ""
	}

	descriptions := make([]string, 0, len(predicates))
	for _, predicate := range predicates {
		descriptions = append(descriptions, describePredicate(predicate))
	}
	return strings.Join(descriptions, ", ")
}

// valuesEqual compares JSON-decoded values and expected values with numeric tolerance.
func valuesEqual(actual any, expected any) bool {

	if reflect.DeepEqual(actual, expected) {
		return true
	}

	actualNumber, actualIsNumber := asFloat64(actual)
	expectedNumber, expectedIsNumber := asFloat64(expected)
	if actualIsNumber && expectedIsNumber {
		return actualNumber == expectedNumber
	}

	return false
}

// asFloat64 converts common numeric JSON value types for robust equality checks.
func asFloat64(value any) (float64, bool) {

	switch typed := value.(type) {
	case float64:
		return typed, true
	case float32:
		return float64(typed), true
	case int:
		return float64(typed), true
	case int8:
		return float64(typed), true
	case int16:
		return float64(typed), true
	case int32:
		return float64(typed), true
	case int64:
		return float64(typed), true
	case uint:
		return float64(typed), true
	case uint8:
		return float64(typed), true
	case uint16:
		return float64(typed), true
	case uint32:
		return float64(typed), true
	case uint64:
		return float64(typed), true
	case json.Number:
		parsed, err := typed.Float64()
		if err != nil {
			return 0, false
		}
		return parsed, true
	case string:
		parsed, err := strconv.ParseFloat(typed, 64)
		if err != nil {
			return 0, false
		}
		return parsed, true
	default:
		return 0, false
	}
}

```


--| pkg/zerologtest/recorder.go

```go
// recorder.go captures zerolog JSON output into concurrency-safe test entries.
// pkg/zerologtest/recorder.go
package zerologtest

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"sync"
)

// Transform scrubs or normalizes decoded entry fields before storage.
type Transform func(fields map[string]any) map[string]any

// Option configures Recorder behavior.
type Option func(recorder *Recorder)

// Recorder captures newline-delimited JSON log entries from zerolog.
type Recorder struct {
	mu                 sync.RWMutex
	pending            []byte
	entries            []Entry
	ignoreFields       map[string]struct{}
	presenceOnlyFields map[string]struct{}
	transform          Transform
	notifyCh           chan struct{}
}

// NewRecorder creates a new structured log recorder.
func NewRecorder(options ...Option) *Recorder {

	recorder := &Recorder{
		ignoreFields:       map[string]struct{}{},
		presenceOnlyFields: map[string]struct{}{},
		notifyCh:           make(chan struct{}, 1),
	}

	for _, option := range options {
		if option != nil {
			option(recorder)
		}
	}

	return recorder
}

// WithIgnoredFields removes configured fields before entries are stored.
func WithIgnoredFields(fields ...string) Option {

	return func(recorder *Recorder) {
		for _, field := range fields {
			if field != "" {
				recorder.ignoreFields[field] = struct{}{}
			}
		}
	}
}

// WithPresenceOnlyFields replaces configured field values with PresenceOnlyValue.
func WithPresenceOnlyFields(fields ...string) Option {

	return func(recorder *Recorder) {
		for _, field := range fields {
			if field != "" {
				recorder.presenceOnlyFields[field] = struct{}{}
			}
		}
	}
}

// WithTransform applies a normalization transform before entry storage.
func WithTransform(transform Transform) Option {

	return func(recorder *Recorder) {
		recorder.transform = transform
	}
}

// Write buffers log bytes and records complete newline-delimited JSON entries.
func (recorder *Recorder) Write(payload []byte) (int, error) {

	if recorder == nil {
		return 0, errors.New("recorder is nil")
	}

	recorder.mu.Lock()
	defer recorder.mu.Unlock()

	recorder.pending = append(recorder.pending, payload...)

	for {
		newlineIndex := bytes.IndexByte(recorder.pending, '\n')
		if newlineIndex < 0 {
			break
		}

		line := make([]byte, newlineIndex)
		copy(line, recorder.pending[:newlineIndex])
		recorder.pending = recorder.pending[newlineIndex+1:]
		recorder.captureLine(line)
	}

	return len(payload), nil
}

// Entries returns a snapshot copy of captured entries.
func (recorder *Recorder) Entries() []Entry {

	if recorder == nil {
		return nil
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	copied := make([]Entry, len(recorder.entries))
	for index, entry := range recorder.entries {
		copied[index] = copyEntry(entry)
	}
	return copied
}

// Last returns the most recent captured entry.
func (recorder *Recorder) Last() (Entry, bool) {

	if recorder == nil {
		return Entry{}, false
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	if len(recorder.entries) == 0 {
		return Entry{}, false
	}
	return copyEntry(recorder.entries[len(recorder.entries)-1]), true
}

// Filter returns entries that match the predicate.
func (recorder *Recorder) Filter(predicate Predicate) []Entry {

	if recorder == nil || predicate == nil {
		return nil
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	filtered := make([]Entry, 0, len(recorder.entries))
	for _, entry := range recorder.entries {
		if predicate.Match(entry) {
			filtered = append(filtered, copyEntry(entry))
		}
	}
	return filtered
}

// Contains returns whether at least one entry matches.
func (recorder *Recorder) Contains(predicate Predicate) bool {

	if recorder == nil || predicate == nil {
		return false
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	for _, entry := range recorder.entries {
		if predicate.Match(entry) {
			return true
		}
	}
	return false
}

// WaitFor blocks until an entry matches or context cancellation occurs.
func (recorder *Recorder) WaitFor(ctx context.Context, predicate Predicate) (Entry, error) {

	if recorder == nil {
		return Entry{}, errors.New("recorder is nil")
	}
	if predicate == nil {
		return Entry{}, errors.New("predicate is nil")
	}

	for {
		if entry, ok := recorder.firstMatch(predicate); ok {
			return entry, nil
		}

		select {
		case <-ctx.Done():
			return Entry{}, ctx.Err()
		case <-recorder.notifyCh:
		}
	}
}

// firstMatch returns the first matching entry snapshot.
func (recorder *Recorder) firstMatch(predicate Predicate) (Entry, bool) {

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	for _, entry := range recorder.entries {
		if predicate.Match(entry) {
			return copyEntry(entry), true
		}
	}
	return Entry{}, false
}

// captureLine decodes and stores one complete log line.
func (recorder *Recorder) captureLine(line []byte) {

	trimmed := strings.TrimSpace(strings.TrimSuffix(string(line), "\r"))
	if trimmed == "" {
		return
	}

	entryFields := map[string]any{}
	if err := json.Unmarshal([]byte(trimmed), &entryFields); err != nil {
		entryFields = map[string]any{
			FieldLevel:     "error",
			FieldEventCode: EventCodeDecodeFailed,
			FieldComponent: "zerologtest.recorder",
			FieldOp:        "decode",
			FieldStatus:    "failed",
			FieldErrKind:   "json_decode",
			FieldMessage:   "failed to decode log line",
			"decode_error": err.Error(),
			"raw_line":     trimmed,
		}
	}

	normalized := recorder.normalizeFields(entryFields)
	recorder.entries = append(recorder.entries, Entry{Fields: normalized})
	recorder.signalWaiters()
}

// normalizeFields applies transform, ignore, and presence-only behavior.
func (recorder *Recorder) normalizeFields(fields map[string]any) map[string]any {

	normalized := copyFields(fields)
	if recorder.transform != nil {
		transformed := recorder.transform(copyFields(normalized))
		if transformed != nil {
			normalized = transformed
		}
	}

	if normalized == nil {
		normalized = map[string]any{}
	}

	for ignoredField := range recorder.ignoreFields {
		delete(normalized, ignoredField)
	}
	for presenceOnlyField := range recorder.presenceOnlyFields {
		if _, ok := normalized[presenceOnlyField]; ok {
			normalized[presenceOnlyField] = PresenceOnlyValue
		}
	}

	return normalized
}

// signalWaiters notifies async waiters that new entries were captured.
func (recorder *Recorder) signalWaiters() {

	select {
	case recorder.notifyCh <- struct{}{}:
	default:
	}
}

// String returns a concise snapshot count for quick diagnostics.
func (recorder *Recorder) String() string {

	if recorder == nil {
		return "Recorder(<nil>)"
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	return fmt.Sprintf("Recorder(entries=%d)", len(recorder.entries))
}

```


--| wails.json

```json
{
  "$schema": "https://wails.io/schemas/config.v2.json",
  "name": "wls-chatbot",
  "outputfilename": "wls-chatbot",
  "frontend:install": "npm install",
  "frontend:build": "npm run build",
  "frontend:dev:watcher": "npm run dev",
  "frontend:dev:serverUrl": "auto"
}

```

