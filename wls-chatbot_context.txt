

# === Go Source ===


--| cmd/modeltest/main.go

```go
// Package main provides a standalone CLI for LLM model testing.
// This binary can be distributed independently for community model validation.
// cmd/modeltest/main.go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/MadeByDoug/wls-chatbot/pkg/models/modeltest"
	"github.com/spf13/cobra"
)

func main() {
	if err := newRootCommand().Execute(); err != nil {
		os.Exit(1)
	}
}

func newRootCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "modeltest",
		Short: "LLM model capability testing tool",
		Long: `A standalone tool for testing LLM provider capabilities and generating golden files.

Golden files capture request/response pairs for mock-based regression testing.
This tool can run in two modes:
  - live:  Make real API calls and update golden files
  - mock:  Replay golden files without API calls`,
	}

	cmd.AddCommand(newRunCommand())
	cmd.AddCommand(newValidateCommand())
	return cmd
}

func newRunCommand() *cobra.Command {
	var config modeltest.RunnerConfig
	var providersStr string
	var capsStr string

	cmd := &cobra.Command{
		Use:   "run",
		Short: "Run capability tests",
		RunE: func(cmd *cobra.Command, args []string) error {
			if providersStr != "" {
				config.Providers = strings.Split(providersStr, ",")
			}
			if capsStr != "" {
				for _, c := range strings.Split(capsStr, ",") {
					config.Capabilities = append(config.Capabilities, modeltest.Capability(c))
				}
			}

			runner := modeltest.NewRunner(config)
			if err := runner.LoadEmbeddedCatalogPlan(); err != nil {
				return fmt.Errorf("load embedded catalog plan: %w", err)
			}

			ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
			defer cancel()

			fmt.Printf("Running tests in %s mode...\n", config.Mode)
			results, err := runner.Run(ctx)
			if err != nil {
				return err
			}

			report := modeltest.GenerateReport(results)
			printReport(report)

			if report.Failed > 0 {
				return fmt.Errorf("%d tests failed", report.Failed)
			}
			return nil
		},
	}

	cmd.Flags().StringVar(&config.Mode, "mode", "mock", "Test mode: live or mock")
	cmd.Flags().StringVar(&config.OutputDir, "output", "testdata/golden", "Golden file output directory")
	cmd.Flags().StringVar(&providersStr, "providers", "", "Comma-separated list of providers to test")
	cmd.Flags().StringVar(&capsStr, "capabilities", "", "Comma-separated list of capabilities to test")
	cmd.Flags().IntVar(&config.Parallel, "parallel", 1, "Number of parallel tests")
	cmd.Flags().DurationVar(&config.Timeout, "timeout", 30*time.Second, "Timeout per test")

	return cmd
}

func newValidateCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "validate [file]",
		Short: "Validate a test plan or golden file",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			path := args[0]

			// Try loading as golden file first
			if strings.HasSuffix(path, ".json") {
				golden, err := modeltest.LoadGoldenFile(path)
				if err != nil {
					return fmt.Errorf("invalid golden file: %w", err)
				}
				fmt.Printf("✓ Valid golden file\n")
				fmt.Printf("  Provider:   %s\n", golden.Metadata.Provider)
				fmt.Printf("  Capability: %s\n", golden.Metadata.Capability)
				fmt.Printf("  Model:      %s\n", golden.Metadata.Model)
				fmt.Printf("  Timestamp:  %s\n", golden.Metadata.Timestamp.Format(time.RFC3339))
				return nil
			}

			// Try loading as plan file
			runner := modeltest.NewRunner(modeltest.DefaultRunnerConfig())
			if err := runner.LoadPlan(path); err != nil {
				return fmt.Errorf("invalid plan file: %w", err)
			}
			fmt.Printf("✓ Valid test plan\n")
			return nil
		},
	}
	return cmd
}

func printReport(report modeltest.Report) {
	fmt.Printf("\n=== Test Report ===\n")
	fmt.Printf("Timestamp: %s\n", report.Timestamp.Format(time.RFC3339))
	fmt.Printf("Total: %d  Passed: %d  Failed: %d\n\n", report.TotalTests, report.Passed, report.Failed)

	for _, r := range report.Results {
		status := "✓"
		if !r.Success {
			status = "✗"
		}
		fmt.Printf("%s %s/%s/%s\n", status, r.Provider, r.Capability, r.Model)
		if r.Error != "" {
			fmt.Printf("    Error: %s\n", r.Error)
		}
	}
}

// Export report as JSON if needed
func exportReportJSON(report modeltest.Report, path string) error {
	data, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

```


--| frontend/frontend/package-lock.json

```json
{
  "name": "frontend",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {}
}

```


--| frontend/package-lock.json

```json
{
  "name": "frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "frontend",
      "version": "0.0.0",
      "dependencies": {
        "@lit-labs/preact-signals": "^1.0.3",
        "@preact/signals-core": "^1.12.2",
        "lit": "^3.3.2"
      },
      "devDependencies": {
        "@eslint/js": "^9.20.0",
        "eslint": "^9.20.0",
        "eslint-config-prettier": "^10.0.1",
        "prettier": "^3.5.2",
        "typescript": "^5.4.5",
        "typescript-eslint": "^8.24.1",
        "vite": "^3.0.7",
        "vitest": "^1.6.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.15.18.tgz",
      "integrity": "sha512-5GT+kcs2WVGjVs7+boataCkO5Fg0y4kCjzkB5bAip7H4jfnOS3dA6KPiww9W1OEKTKeAcUVhdZGvgI65OXmUnw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.15.18.tgz",
      "integrity": "sha512-L4jVKS82XVhw2nvzLg/19ClLWg0y27ulRwuP7lcyL6AbUWB5aPglXY3M21mauDQMDfRLs8cQmeT03r/+X3cZYQ==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.1.tgz",
      "integrity": "sha512-phrYmNiYppR7znFEdqgfWHXR6NCkZEK7hwWDHZUjit/2/U0r6XvkDl0SYnoM51Hq7FhCGdLDT6zxCCOY1hexsQ==",
      "dev": true,
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.2",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
      "dev": true,
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
      "dev": true,
      "dependencies": {
        "@eslint/object-schema": "^2.1.7",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
      "dev": true,
      "dependencies": {
        "@eslint/core": "^0.17.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
      "dev": true,
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.3.tgz",
      "integrity": "sha512-Kr+LPIUVKz2qkx1HAMH8q1q6azbqBAsXJUxBl/ODDuVPX45Z9DfwB8tPjTi6nNZ8BuM3nbJxC5zCAg5elnBUTQ==",
      "dev": true,
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.1",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.2.tgz",
      "integrity": "sha512-q1mjIoW1VX4IvSocvM/vbTiveKC4k9eLrajNEuSsmjymSDEbpGddtpfOoN7YGAqBK3NG+uqo8ia4PDTt8buCYA==",
      "dev": true,
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
      "dev": true,
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
      "dev": true,
      "dependencies": {
        "@eslint/core": "^0.17.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.7",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.7.tgz",
      "integrity": "sha512-/zUx+yOsIrG4Y43Eh2peDeKCxlRt/gET6aHfaKpuq267qXdYDFViVHfMaLyygZOnl0kGWxFIgsBy8QFuTLUXEQ==",
      "dev": true,
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.4.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
      "dev": true,
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@jest/schemas": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/@jest/schemas/-/schemas-29.6.3.tgz",
      "integrity": "sha512-mo5j5X+jIZmJQveBKeS/clAueipV7KgiX1vMgCxam1RNYiqE1w62n0/tJJnHtjW8ZHcQco5gY85jA3mi0L+nSA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@sinclair/typebox": "^0.27.8"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@lit-labs/preact-signals": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@lit-labs/preact-signals/-/preact-signals-1.0.3.tgz",
      "integrity": "sha512-aZDNZUgEpYPB+zfApIZpChSyKlLoqvILYt0nTm0KAXTU8FZsht6I6QZRvdKItD3EI8w0FHsqk9CpzIdd3gFXCA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@preact/signals-core": "^1.3.0",
        "lit": "^3.1.2"
      }
    },
    "node_modules/@lit-labs/ssr-dom-shim": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/@lit-labs/ssr-dom-shim/-/ssr-dom-shim-1.5.1.tgz",
      "integrity": "sha512-Aou5UdlSpr5whQe8AA/bZG0jMj96CoJIWbGfZ91qieWu5AWUMKw8VR/pAkQkJYvBNhmCcWnZlyyk5oze8JIqYA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/@lit/reactive-element": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/@lit/reactive-element/-/reactive-element-2.1.2.tgz",
      "integrity": "sha512-pbCDiVMnne1lYUIaYNN5wrwQXDtHaYtg7YEFPeW+hws6U47WeFvISGUWekPGKWOP1ygrs0ef0o1VJMk1exos5A==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.5.0"
      }
    },
    "node_modules/@preact/signals-core": {
      "version": "1.12.2",
      "resolved": "https://registry.npmjs.org/@preact/signals-core/-/signals-core-1.12.2.tgz",
      "integrity": "sha512-5Yf8h1Ke3SMHr15xl630KtwPTW4sYDFkkxS0vQ8UiQLWwZQnrF9IKaVG1mN5VcJz52EcWs2acsc/Npjha/7ysA==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/preact"
      }
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.57.1.tgz",
      "integrity": "sha512-A6ehUVSiSaaliTxai040ZpZ2zTevHYbvu/lDoeAteHI8QnaosIzm4qwtezfRg1jOYaUmnzLX1AOD6Z+UJjtifg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.57.1.tgz",
      "integrity": "sha512-dQaAddCY9YgkFHZcFNS/606Exo8vcLHwArFZ7vxXq4rigo2bb494/xKMMwRRQW6ug7Js6yXmBZhSBRuBvCCQ3w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.57.1.tgz",
      "integrity": "sha512-crNPrwJOrRxagUYeMn/DZwqN88SDmwaJ8Cvi/TN1HnWBU7GwknckyosC2gd0IqYRsHDEnXf328o9/HC6OkPgOg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.57.1.tgz",
      "integrity": "sha512-Ji8g8ChVbKrhFtig5QBV7iMaJrGtpHelkB3lsaKzadFBe58gmjfGXAOfI5FV0lYMH8wiqsxKQ1C9B0YTRXVy4w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.57.1.tgz",
      "integrity": "sha512-R+/WwhsjmwodAcz65guCGFRkMb4gKWTcIeLy60JJQbXrJ97BOXHxnkPFrP+YwFlaS0m+uWJTstrUA9o+UchFug==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.57.1.tgz",
      "integrity": "sha512-IEQTCHeiTOnAUC3IDQdzRAGj3jOAYNr9kBguI7MQAAZK3caezRrg0GxAb6Hchg4lxdZEI5Oq3iov/w/hnFWY9Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.57.1.tgz",
      "integrity": "sha512-F8sWbhZ7tyuEfsmOxwc2giKDQzN3+kuBLPwwZGyVkLlKGdV1nvnNwYD0fKQ8+XS6hp9nY7B+ZeK01EBUE7aHaw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.57.1.tgz",
      "integrity": "sha512-rGfNUfn0GIeXtBP1wL5MnzSj98+PZe/AXaGBCRmT0ts80lU5CATYGxXukeTX39XBKsxzFpEeK+Mrp9faXOlmrw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.57.1.tgz",
      "integrity": "sha512-MMtej3YHWeg/0klK2Qodf3yrNzz6CGjo2UntLvk2RSPlhzgLvYEB3frRvbEF2wRKh1Z2fDIg9KRPe1fawv7C+g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.57.1.tgz",
      "integrity": "sha512-1a/qhaaOXhqXGpMFMET9VqwZakkljWHLmZOX48R0I/YLbhdxr1m4gtG1Hq7++VhVUmf+L3sTAf9op4JlhQ5u1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.57.1.tgz",
      "integrity": "sha512-QWO6RQTZ/cqYtJMtxhkRkidoNGXc7ERPbZN7dVW5SdURuLeVU7lwKMpo18XdcmpWYd0qsP1bwKPf7DNSUinhvA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-musl/-/rollup-linux-loong64-musl-4.57.1.tgz",
      "integrity": "sha512-xpObYIf+8gprgWaPP32xiN5RVTi/s5FCR+XMXSKmhfoJjrpRAjCuuqQXyxUa/eJTdAE6eJ+KDKaoEqjZQxh3Gw==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.57.1.tgz",
      "integrity": "sha512-4BrCgrpZo4hvzMDKRqEaW1zeecScDCR+2nZ86ATLhAoJ5FQ+lbHVD3ttKe74/c7tNT9c6F2viwB3ufwp01Oh2w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-musl/-/rollup-linux-ppc64-musl-4.57.1.tgz",
      "integrity": "sha512-NOlUuzesGauESAyEYFSe3QTUguL+lvrN1HtwEEsU2rOwdUDeTMJdO5dUYl/2hKf9jWydJrO9OL/XSSf65R5+Xw==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.57.1.tgz",
      "integrity": "sha512-ptA88htVp0AwUUqhVghwDIKlvJMD/fmL/wrQj99PRHFRAG6Z5nbWoWG4o81Nt9FT+IuqUQi+L31ZKAFeJ5Is+A==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.57.1.tgz",
      "integrity": "sha512-S51t7aMMTNdmAMPpBg7OOsTdn4tySRQvklmL3RpDRyknk87+Sp3xaumlatU+ppQ+5raY7sSTcC2beGgvhENfuw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.57.1.tgz",
      "integrity": "sha512-Bl00OFnVFkL82FHbEqy3k5CUCKH6OEJL54KCyx2oqsmZnFTR8IoNqBF+mjQVcRCT5sB6yOvK8A37LNm/kPJiZg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-ABca4ceT4N+Tv/GtotnWAeXZUZuM/9AQyCyKYyKnpk4yoA7QIAuBt6Hkgpw8kActYlew2mvckXkvx0FfoInnLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.57.1.tgz",
      "integrity": "sha512-HFps0JeGtuOR2convgRRkHCekD7j+gdAuXM+/i6kGzQtFhlCtQkpwtNzkNj6QhCDp7DRJ7+qC/1Vg2jt5iSOFw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openbsd-x64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openbsd-x64/-/rollup-openbsd-x64-4.57.1.tgz",
      "integrity": "sha512-H+hXEv9gdVQuDTgnqD+SQffoWoc0Of59AStSzTEj/feWTBAnSfSD3+Dql1ZruJQxmykT/JVY0dE8Ka7z0DH1hw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.57.1.tgz",
      "integrity": "sha512-4wYoDpNg6o/oPximyc/NG+mYUejZrCU2q+2w6YZqrAs2UcNUChIZXjtafAiiZSUc7On8v5NyNj34Kzj/Ltk6dQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.57.1.tgz",
      "integrity": "sha512-O54mtsV/6LW3P8qdTcamQmuC990HDfR71lo44oZMZlXU4tzLrbvTii87Ni9opq60ds0YzuAlEr/GNwuNluZyMQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.57.1.tgz",
      "integrity": "sha512-P3dLS+IerxCT/7D2q2FYcRdWRl22dNbrbBEtxdWhXrfIMPP9lQhb5h4Du04mdl5Woq05jVCDPCMF7Ub0NAjIew==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.57.1.tgz",
      "integrity": "sha512-VMBH2eOOaKGtIJYleXsi2B8CPVADrh+TyNxJ4mWPnKfLB/DBUmzW+5m1xUrcwWoMfSLagIRpjUFeW5CO5hyciQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.57.1.tgz",
      "integrity": "sha512-mxRFDdHIWRxg3UfIIAwCm6NzvxG0jDX/wBN6KsQFTvKFqqg9vTrWUE68qEjHt19A5wwx5X5aUi2zuZT7YR0jrA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@sinclair/typebox": {
      "version": "0.27.8",
      "resolved": "https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.27.8.tgz",
      "integrity": "sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true
    },
    "node_modules/@types/trusted-types": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.7.tgz",
      "integrity": "sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw==",
      "license": "MIT"
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.54.0.tgz",
      "integrity": "sha512-hAAP5io/7csFStuOmR782YmTthKBJ9ND3WVL60hcOjvtGFb+HJxH4O5huAcmcZ9v9G8P+JETiZ/G1B8MALnWZQ==",
      "dev": true,
      "dependencies": {
        "@eslint-community/regexpp": "^4.12.2",
        "@typescript-eslint/scope-manager": "8.54.0",
        "@typescript-eslint/type-utils": "8.54.0",
        "@typescript-eslint/utils": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0",
        "ignore": "^7.0.5",
        "natural-compare": "^1.4.0",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^8.54.0",
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/ignore": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-7.0.5.tgz",
      "integrity": "sha512-Hs59xBNfUIunMFgWAbGX5cq6893IbWg4KnrjbYwX3tx0ztorVgTDA6B2sxf8ejHJ4wz8BqGUMYlnzNBer5NvGg==",
      "dev": true,
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.54.0.tgz",
      "integrity": "sha512-BtE0k6cjwjLZoZixN0t5AKP0kSzlGu7FctRXYuPAm//aaiZhmfq1JwdYpYr1brzEspYyFeF+8XF5j2VK6oalrA==",
      "dev": true,
      "peer": true,
      "dependencies": {
        "@typescript-eslint/scope-manager": "8.54.0",
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/project-service": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/project-service/-/project-service-8.54.0.tgz",
      "integrity": "sha512-YPf+rvJ1s7MyiWM4uTRhE4DvBXrEV+d8oC3P9Y2eT7S+HBS0clybdMIPnhiATi9vZOYDc7OQ1L/i6ga6NFYK/g==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/tsconfig-utils": "^8.54.0",
        "@typescript-eslint/types": "^8.54.0",
        "debug": "^4.4.3"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.54.0.tgz",
      "integrity": "sha512-27rYVQku26j/PbHYcVfRPonmOlVI6gihHtXFbTdB5sb6qA0wdAQAbyXFVarQ5t4HRojIz64IV90YtsjQSSGlQg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/tsconfig-utils": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/tsconfig-utils/-/tsconfig-utils-8.54.0.tgz",
      "integrity": "sha512-dRgOyT2hPk/JwxNMZDsIXDgyl9axdJI3ogZ2XWhBPsnZUv+hPesa5iuhdYt2gzwA9t8RE5ytOJ6xB0moV0Ujvw==",
      "dev": true,
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.54.0.tgz",
      "integrity": "sha512-hiLguxJWHjjwL6xMBwD903ciAwd7DmK30Y9Axs/etOkftC3ZNN9K44IuRD/EB08amu+Zw6W37x9RecLkOo3pMA==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0",
        "@typescript-eslint/utils": "8.54.0",
        "debug": "^4.4.3",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.54.0.tgz",
      "integrity": "sha512-PDUI9R1BVjqu7AUDsRBbKMtwmjWcn4J3le+5LpcFgWULN3LvHC5rkc9gCVxbrsrGmO1jfPybN5s6h4Jy+OnkAA==",
      "dev": true,
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.54.0.tgz",
      "integrity": "sha512-BUwcskRaPvTk6fzVWgDPdUndLjB87KYDrN5EYGetnktoeAvPtO4ONHlAZDnj5VFnUANg0Sjm7j4usBlnoVMHwA==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/project-service": "8.54.0",
        "@typescript-eslint/tsconfig-utils": "8.54.0",
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/visitor-keys": "8.54.0",
        "debug": "^4.4.3",
        "minimatch": "^9.0.5",
        "semver": "^7.7.3",
        "tinyglobby": "^0.2.15",
        "ts-api-utils": "^2.4.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.54.0.tgz",
      "integrity": "sha512-9Cnda8GS57AQakvRyG0PTejJNlA2xhvyNtEVIMlDWOOeEyBkYWhGPnfrIAnqxLMTSTo6q8g12XVjjev5l1NvMA==",
      "dev": true,
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.9.1",
        "@typescript-eslint/scope-manager": "8.54.0",
        "@typescript-eslint/types": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.54.0.tgz",
      "integrity": "sha512-VFlhGSl4opC0bprJiItPQ1RfUhGDIBokcPwaFH4yiBCaNPeld/9VeXbiPO1cLyorQi1G1vL+ecBk1x8o1axORA==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "8.54.0",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@vitest/expect": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-1.6.1.tgz",
      "integrity": "sha512-jXL+9+ZNIJKruofqXuuTClf44eSpcHlgj3CiuNihUF3Ioujtmc0zIa3UJOW5RjDK1YLBJZnWBlPuqhYycLioog==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "1.6.1",
        "@vitest/utils": "1.6.1",
        "chai": "^4.3.10"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/runner": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@vitest/runner/-/runner-1.6.1.tgz",
      "integrity": "sha512-3nSnYXkVkf3mXFfE7vVyPmi3Sazhb/2cfZGGs0JRzFsPFvAMBEcrweV1V1GsrstdXeKCTXlJbvnQwGWgEIHmOA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/utils": "1.6.1",
        "p-limit": "^5.0.0",
        "pathe": "^1.1.1"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@vitest/snapshot/-/snapshot-1.6.1.tgz",
      "integrity": "sha512-WvidQuWAzU2p95u8GAKlRMqMyN1yOJkGHnx3M1PL9Raf7AQ1kwLKg04ADlCa3+OXUZE7BceOhVZiuWAbzCKcUQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "magic-string": "^0.30.5",
        "pathe": "^1.1.1",
        "pretty-format": "^29.7.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/spy": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@vitest/spy/-/spy-1.6.1.tgz",
      "integrity": "sha512-MGcMmpGkZebsMZhbQKkAf9CX5zGvjkBTqf8Zx3ApYWXr3wG+QvEu2eXWfnIIWYSJExIp4V9FCKDEeygzkYrXMw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyspy": "^2.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/utils": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/@vitest/utils/-/utils-1.6.1.tgz",
      "integrity": "sha512-jOrrUvXM4Av9ZWiG1EajNto0u96kWAhJ1LmPmJhXXQx/32MecEKd10pOLYgS2BQx1TgkGhloPU1ArDW2vvaY6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "diff-sequences": "^29.6.3",
        "estree-walker": "^3.0.3",
        "loupe": "^2.3.7",
        "pretty-format": "^29.7.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.4",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz",
      "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-styles": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz",
      "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true
    },
    "node_modules/assertion-error": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz",
      "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/cac": {
      "version": "6.7.14",
      "resolved": "https://registry.npmjs.org/cac/-/cac-6.7.14.tgz",
      "integrity": "sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/chai": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/chai/-/chai-4.5.0.tgz",
      "integrity": "sha512-RITGBfijLkBddZvnn8jdqoTypxvqbOLYQkGGxXzeFjVHvudaPw0HNFD9x928/eUwYWd2dPCugVqspGALTZZQKw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "assertion-error": "^1.1.0",
        "check-error": "^1.0.3",
        "deep-eql": "^4.1.3",
        "get-func-name": "^2.0.2",
        "loupe": "^2.3.6",
        "pathval": "^1.1.1",
        "type-detect": "^4.1.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chalk/node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/check-error": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/check-error/-/check-error-1.0.3.tgz",
      "integrity": "sha512-iKEoDYaRmd1mxM90a2OEfWhjsjPpYPuQ+lMYsoxB126+t8fw7ySEO48nmDg5COTjxDI65/Y2OWpeEHk3ZOe8zg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "get-func-name": "^2.0.2"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true
    },
    "node_modules/confbox": {
      "version": "0.1.8",
      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.1.8.tgz",
      "integrity": "sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-eql": {
      "version": "4.1.4",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-4.1.4.tgz",
      "integrity": "sha512-SUwdGfqdKOwxCPeVYjwSyRpJ7Z+fhpwIAtmCUdZIWZ/YP5R9WAsyuSgpLVDi9bjWoN2LXHNss/dk3urXtdQxGg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "type-detect": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true
    },
    "node_modules/diff-sequences": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/diff-sequences/-/diff-sequences-29.6.3.tgz",
      "integrity": "sha512-EjePK1srD3P08o2j4f0ExnylqRs5B9tJjcp9t1krH2qRi8CCdsYfwe9JgSLurFBWwq4uOlipzfk5fHNvwFKr8Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/esbuild": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.15.18.tgz",
      "integrity": "sha512-x/R72SmW3sSFRm5zrrIjAhCeQSAWoni3CmHEqfQrZIQTM3lVCdehdwuIqaOtfC2slvpdlLa62GYoN8SxT23m6Q==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/android-arm": "0.15.18",
        "@esbuild/linux-loong64": "0.15.18",
        "esbuild-android-64": "0.15.18",
        "esbuild-android-arm64": "0.15.18",
        "esbuild-darwin-64": "0.15.18",
        "esbuild-darwin-arm64": "0.15.18",
        "esbuild-freebsd-64": "0.15.18",
        "esbuild-freebsd-arm64": "0.15.18",
        "esbuild-linux-32": "0.15.18",
        "esbuild-linux-64": "0.15.18",
        "esbuild-linux-arm": "0.15.18",
        "esbuild-linux-arm64": "0.15.18",
        "esbuild-linux-mips64le": "0.15.18",
        "esbuild-linux-ppc64le": "0.15.18",
        "esbuild-linux-riscv64": "0.15.18",
        "esbuild-linux-s390x": "0.15.18",
        "esbuild-netbsd-64": "0.15.18",
        "esbuild-openbsd-64": "0.15.18",
        "esbuild-sunos-64": "0.15.18",
        "esbuild-windows-32": "0.15.18",
        "esbuild-windows-64": "0.15.18",
        "esbuild-windows-arm64": "0.15.18"
      }
    },
    "node_modules/esbuild-android-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-android-64/-/esbuild-android-64-0.15.18.tgz",
      "integrity": "sha512-wnpt3OXRhcjfIDSZu9bnzT4/TNTDsOUvip0foZOUBG7QbSt//w3QV4FInVJxNhKc/ErhUxc5z4QjHtMi7/TbgA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-android-arm64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-android-arm64/-/esbuild-android-arm64-0.15.18.tgz",
      "integrity": "sha512-G4xu89B8FCzav9XU8EjsXacCKSG2FT7wW9J6hOc18soEHJdtWu03L3TQDGf0geNxfLTtxENKBzMSq9LlbjS8OQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-darwin-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-darwin-64/-/esbuild-darwin-64-0.15.18.tgz",
      "integrity": "sha512-2WAvs95uPnVJPuYKP0Eqx+Dl/jaYseZEUUT1sjg97TJa4oBtbAKnPnl3b5M9l51/nbx7+QAEtuummJZW0sBEmg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-darwin-arm64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-darwin-arm64/-/esbuild-darwin-arm64-0.15.18.tgz",
      "integrity": "sha512-tKPSxcTJ5OmNb1btVikATJ8NftlyNlc8BVNtyT/UAr62JFOhwHlnoPrhYWz09akBLHI9nElFVfWSTSRsrZiDUA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-freebsd-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-freebsd-64/-/esbuild-freebsd-64-0.15.18.tgz",
      "integrity": "sha512-TT3uBUxkteAjR1QbsmvSsjpKjOX6UkCstr8nMr+q7zi3NuZ1oIpa8U41Y8I8dJH2fJgdC3Dj3CXO5biLQpfdZA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-freebsd-arm64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-freebsd-arm64/-/esbuild-freebsd-arm64-0.15.18.tgz",
      "integrity": "sha512-R/oVr+X3Tkh+S0+tL41wRMbdWtpWB8hEAMsOXDumSSa6qJR89U0S/PpLXrGF7Wk/JykfpWNokERUpCeHDl47wA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-32": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-32/-/esbuild-linux-32-0.15.18.tgz",
      "integrity": "sha512-lphF3HiCSYtaa9p1DtXndiQEeQDKPl9eN/XNoBf2amEghugNuqXNZA/ZovthNE2aa4EN43WroO0B85xVSjYkbg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-64/-/esbuild-linux-64-0.15.18.tgz",
      "integrity": "sha512-hNSeP97IviD7oxLKFuii5sDPJ+QHeiFTFLoLm7NZQligur8poNOWGIgpQ7Qf8Balb69hptMZzyOBIPtY09GZYw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-arm": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-arm/-/esbuild-linux-arm-0.15.18.tgz",
      "integrity": "sha512-UH779gstRblS4aoS2qpMl3wjg7U0j+ygu3GjIeTonCcN79ZvpPee12Qun3vcdxX+37O5LFxz39XeW2I9bybMVA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-arm64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-arm64/-/esbuild-linux-arm64-0.15.18.tgz",
      "integrity": "sha512-54qr8kg/6ilcxd+0V3h9rjT4qmjc0CccMVWrjOEM/pEcUzt8X62HfBSeZfT2ECpM7104mk4yfQXkosY8Quptug==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-mips64le": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-mips64le/-/esbuild-linux-mips64le-0.15.18.tgz",
      "integrity": "sha512-Mk6Ppwzzz3YbMl/ZZL2P0q1tnYqh/trYZ1VfNP47C31yT0K8t9s7Z077QrDA/guU60tGNp2GOwCQnp+DYv7bxQ==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-ppc64le": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-ppc64le/-/esbuild-linux-ppc64le-0.15.18.tgz",
      "integrity": "sha512-b0XkN4pL9WUulPTa/VKHx2wLCgvIAbgwABGnKMY19WhKZPT+8BxhZdqz6EgkqCLld7X5qiCY2F/bfpUUlnFZ9w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-riscv64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-riscv64/-/esbuild-linux-riscv64-0.15.18.tgz",
      "integrity": "sha512-ba2COaoF5wL6VLZWn04k+ACZjZ6NYniMSQStodFKH/Pu6RxzQqzsmjR1t9QC89VYJxBeyVPTaHuBMCejl3O/xg==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-linux-s390x": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-linux-s390x/-/esbuild-linux-s390x-0.15.18.tgz",
      "integrity": "sha512-VbpGuXEl5FCs1wDVp93O8UIzl3ZrglgnSQ+Hu79g7hZu6te6/YHgVJxCM2SqfIila0J3k0csfnf8VD2W7u2kzQ==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-netbsd-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-netbsd-64/-/esbuild-netbsd-64-0.15.18.tgz",
      "integrity": "sha512-98ukeCdvdX7wr1vUYQzKo4kQ0N2p27H7I11maINv73fVEXt2kyh4K4m9f35U1K43Xc2QGXlzAw0K9yoU7JUjOg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-openbsd-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-openbsd-64/-/esbuild-openbsd-64-0.15.18.tgz",
      "integrity": "sha512-yK5NCcH31Uae076AyQAXeJzt/vxIo9+omZRKj1pauhk3ITuADzuOx5N2fdHrAKPxN+zH3w96uFKlY7yIn490xQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-sunos-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-sunos-64/-/esbuild-sunos-64-0.15.18.tgz",
      "integrity": "sha512-On22LLFlBeLNj/YF3FT+cXcyKPEI263nflYlAhz5crxtp3yRG1Ugfr7ITyxmCmjm4vbN/dGrb/B7w7U8yJR9yw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-windows-32": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-windows-32/-/esbuild-windows-32-0.15.18.tgz",
      "integrity": "sha512-o+eyLu2MjVny/nt+E0uPnBxYuJHBvho8vWsC2lV61A7wwTWC3jkN2w36jtA+yv1UgYkHRihPuQsL23hsCYGcOQ==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-windows-64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-windows-64/-/esbuild-windows-64-0.15.18.tgz",
      "integrity": "sha512-qinug1iTTaIIrCorAUjR0fcBk24fjzEedFYhhispP8Oc7SFvs+XeW3YpAKiKp8dRpizl4YYAhxMjlftAMJiaUw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/esbuild-windows-arm64": {
      "version": "0.15.18",
      "resolved": "https://registry.npmjs.org/esbuild-windows-arm64/-/esbuild-windows-arm64-0.15.18.tgz",
      "integrity": "sha512-q9bsYzegpZcLziq0zgUi5KqGVtfhjxGbnksaBFYmWLxeV/S1fK4OLdq2DFYnXcLMjlZw2L0jLsk1eGoB522WXQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.39.2",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.2.tgz",
      "integrity": "sha512-LEyamqS7W5HB3ujJyvi0HQK/dtVINZvd5mAAp9eT5S/ujByGjiZLCzPcHVzuXbpJDJF/cxwHlfceVUDZ2lnSTw==",
      "dev": true,
      "peer": true,
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.8.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.1",
        "@eslint/config-helpers": "^0.4.2",
        "@eslint/core": "^0.17.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.39.2",
        "@eslint/plugin-kit": "^0.4.1",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-config-prettier": {
      "version": "10.1.8",
      "resolved": "https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-10.1.8.tgz",
      "integrity": "sha512-82GZUjRS0p/jganf6q1rEO25VSoHH0hKPCTrgillPjdI/3bgBhAE1QzHrHTizjpRvy6pGAvKjDJtk2pF9NDq8w==",
      "dev": true,
      "bin": {
        "eslint-config-prettier": "bin/cli.js"
      },
      "funding": {
        "url": "https://opencollective.com/eslint-config-prettier"
      },
      "peerDependencies": {
        "eslint": ">=7.0.0"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.7.0.tgz",
      "integrity": "sha512-Ap6G0WQwcU/LHsvLwON1fAQX9Zp0A2Y6Y/cJBl9r/JbW90Zyg4/zbG6zzKa2OTALELarYHmKu0GhpM5EO+7T0g==",
      "dev": true,
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estree-walker": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-3.0.3.tgz",
      "integrity": "sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/execa": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/execa/-/execa-8.0.1.tgz",
      "integrity": "sha512-VyhnebXciFV2DESc+p6B+y0LjSm0krU4OgJN44qFAhBY0TJ+1V61tYD2+wHusZ6F9n5K+vl8k0sTy7PEfV4qpg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^8.0.1",
        "human-signals": "^5.0.0",
        "is-stream": "^3.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^5.1.0",
        "onetime": "^6.0.0",
        "signal-exit": "^4.1.0",
        "strip-final-newline": "^3.0.0"
      },
      "engines": {
        "node": ">=16.17"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/execa?sponsor=1"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true
    },
    "node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-func-name": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.2.tgz",
      "integrity": "sha512-8vXOvuE167CtIc3OyItco7N/dpRtBbYOsPsXCz7X/PMnlGjYjSGuZJgM1Y7mmew7BKf9BqvLX2tnOVy1BBUsxQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/get-stream": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-8.0.1.tgz",
      "integrity": "sha512-VaUJspBffn/LMCJVoMvSAdmscJyS1auj5Zulnn5UoYcY531UWmdwhRWkcGKnGU93m5HSXP9LP2usOryrBtQowA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=16"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/human-signals": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-5.0.0.tgz",
      "integrity": "sha512-AXcZb6vzzrFAUE61HnN4mpLqd/cSIwNQjtNWR0euPm6y0iqx3G4gOXaIDdtdDwZmhwe82LA6+zinmW4UBWVePQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=16.17.0"
      }
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-stream": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-3.0.0.tgz",
      "integrity": "sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/js-tokens": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz",
      "integrity": "sha512-mxa9E9ITFOt0ban3j6L5MpjwegGz6lBQmM1IJkWeBZGcMxto50+eWdjC/52xDbS2vy0k7vIMK0Fe2wfL9OQSpQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "dev": true,
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lit": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/lit/-/lit-3.3.2.tgz",
      "integrity": "sha512-NF9zbsP79l4ao2SNrH3NkfmFgN/hBYSQo90saIVI1o5GpjAdCPVstVzO1MrLOakHoEhYkrtRjPK6Ob521aoYWQ==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit/reactive-element": "^2.1.0",
        "lit-element": "^4.2.0",
        "lit-html": "^3.3.0"
      }
    },
    "node_modules/lit-element": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/lit-element/-/lit-element-4.2.2.tgz",
      "integrity": "sha512-aFKhNToWxoyhkNDmWZwEva2SlQia+jfG0fjIWV//YeTaWrVnOxD89dPKfigCUspXFmjzOEUQpOkejH5Ly6sG0w==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.5.0",
        "@lit/reactive-element": "^2.1.0",
        "lit-html": "^3.3.0"
      }
    },
    "node_modules/lit-html": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/lit-html/-/lit-html-3.3.2.tgz",
      "integrity": "sha512-Qy9hU88zcmaxBXcc10ZpdK7cOLXvXpRoBxERdtqV9QOrfpMZZ6pSYP91LhpPtap3sFMUiL7Tw2RImbe0Al2/kw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@types/trusted-types": "^2.0.2"
      }
    },
    "node_modules/local-pkg": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/local-pkg/-/local-pkg-0.5.1.tgz",
      "integrity": "sha512-9rrA30MRRP3gBD3HTGnC6cDFpaE1kVDWxWgqWJUN0RvDNAo+Nz/9GxB+nHOH0ifbVFy0hSA1V6vFDvnx54lTEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mlly": "^1.7.3",
        "pkg-types": "^1.2.1"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      }
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true
    },
    "node_modules/loupe": {
      "version": "2.3.7",
      "resolved": "https://registry.npmjs.org/loupe/-/loupe-2.3.7.tgz",
      "integrity": "sha512-zSMINGVYkdpYSOBmLi0D1Uo7JU9nVdQKrHxC8eYlV+9YKK9WePqAlL7lSlorG/U2Fw1w0hTBmaa/jrQ3UbPHtA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "get-func-name": "^2.0.1"
      }
    },
    "node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/merge-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/mimic-fn": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-4.0.0.tgz",
      "integrity": "sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/mlly": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/mlly/-/mlly-1.8.0.tgz",
      "integrity": "sha512-l8D9ODSRWLe2KHJSifWGwBqpTZXIXTeo8mlKjY+E2HAakaTeNpqAyBZ8GSqLzHgw4XmHmC8whvpjJNMbFZN7/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "acorn": "^8.15.0",
        "pathe": "^2.0.3",
        "pkg-types": "^1.3.1",
        "ufo": "^1.6.1"
      }
    },
    "node_modules/mlly/node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true
    },
    "node_modules/npm-run-path": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-5.3.0.tgz",
      "integrity": "sha512-ppwTtiJZq0O/ai0z7yfudtBpWIoxM8yE6nHi1X47eFR2EWORqfbu6CnPlNsjeN683eT0qG6H/Pyf9fCcvjnnnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^4.0.0"
      },
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/npm-run-path/node_modules/path-key": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-4.0.0.tgz",
      "integrity": "sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/onetime": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-6.0.0.tgz",
      "integrity": "sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mimic-fn": "^4.0.0"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-5.0.0.tgz",
      "integrity": "sha512-/Eaoq+QyLSiXQ4lyYV23f14mZRQcXnxfHrN0vCai+ak9G0pp9iEQukIIZq5NccEvwRB8PUnZT0KsOoDCINS1qQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^1.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate/node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate/node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathe": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-1.1.2.tgz",
      "integrity": "sha512-whLdWMYL2TwI08hn8/ZqAbrVemu0LNaNNJZX73O6qaIdCTfXutsLhMkjdENX0qhsQ9uIimo4/aQOmXkoon2nDQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathval": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.1.tgz",
      "integrity": "sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "peer": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pkg-types": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-1.3.1.tgz",
      "integrity": "sha512-/Jm5M4RvtBFVkKWRu2BLUTNP8/M2a+UwuAX+ae4770q1qVGtfjG+WTCupoZixokjmHiry8uI+dlY8KXYV5HVVQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "confbox": "^0.1.8",
        "mlly": "^1.7.4",
        "pathe": "^2.0.1"
      }
    },
    "node_modules/pkg-types/node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/prettier": {
      "version": "3.8.1",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-3.8.1.tgz",
      "integrity": "sha512-UOnG6LftzbdaHZcKoPFtOcCKztrQ57WkHDeRD9t/PTQtmT0NHSeWWepj6pS0z/N7+08BHFDQVUrfmfMRcZwbMg==",
      "dev": true,
      "bin": {
        "prettier": "bin/prettier.cjs"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/prettier/prettier?sponsor=1"
      }
    },
    "node_modules/pretty-format": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-29.7.0.tgz",
      "integrity": "sha512-Pdlw/oPxN+aXdmM9R00JVC9WVFoCLTKJvDVLgmJ+qAffBMxsV85l/Lu7sNx4zSzPyoL2euImuEwHhOXdEgNFZQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/schemas": "^29.6.3",
        "ansi-styles": "^5.0.0",
        "react-is": "^18.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/react-is": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz",
      "integrity": "sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/rollup": {
      "version": "2.79.2",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-2.79.2.tgz",
      "integrity": "sha512-fS6iqSPZDs3dr/y7Od6y5nha8dW1YnbgtsyotCVvoFGKbERG++CVRFv1meyGDE1SNItQA8BrnCw7ScdAhRJ3XQ==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=10.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/semver": {
      "version": "7.7.4",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.4.tgz",
      "integrity": "sha512-vFKC2IEtQnVhpT78h1Yp8wzwrf8CM+MzKMHGJZfBtzhZNycRFnXsHk6E5TxIkkMsgNS7mdX3AGB7x2QM2di4lA==",
      "dev": true,
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/siginfo": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/siginfo/-/siginfo-2.0.0.tgz",
      "integrity": "sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/signal-exit": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/stackback": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/stackback/-/stackback-0.0.2.tgz",
      "integrity": "sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/std-env": {
      "version": "3.10.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.10.0.tgz",
      "integrity": "sha512-5GS12FdOZNliM5mAOxFRg7Ir0pWz8MdpYm6AY6VPkGpbA7ZzmbzNcBJQ0GPvvyWgcY7QAhCgf9Uy89I03faLkg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/strip-final-newline": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-3.0.0.tgz",
      "integrity": "sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/strip-literal": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/strip-literal/-/strip-literal-2.1.1.tgz",
      "integrity": "sha512-631UJ6O00eNGfMiWG78ck80dfBab8X6IVFB51jZK5Icd7XAs60Z5y7QdSd/wGIklnWvRbUNloVzhOKKmutxQ6Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^9.0.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tinybench": {
      "version": "2.9.0",
      "resolved": "https://registry.npmjs.org/tinybench/-/tinybench-2.9.0.tgz",
      "integrity": "sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "dev": true,
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinypool": {
      "version": "0.8.4",
      "resolved": "https://registry.npmjs.org/tinypool/-/tinypool-0.8.4.tgz",
      "integrity": "sha512-i11VH5gS6IFeLY3gMBQ00/MmLncVP7JLXOw1vlgkytLmJK7QnEr7NXf0LBdxfmNPAeyetukOk0bOYrJrFGjYJQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tinyspy": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/tinyspy/-/tinyspy-2.2.1.tgz",
      "integrity": "sha512-KYad6Vy5VDWV4GH3fjpseMQ/XU2BhIYP7Vzd0LG44qRWm/Yt2WCOTicFdvmgo6gWaqooMQCawTtILVQJupKu7A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-2.4.0.tgz",
      "integrity": "sha512-3TaVTaAv2gTiMB35i3FiGJaRfwb3Pyn/j3m/bfAvGe8FB7CF6u+LMYqYlDh7reQf7UNvoTvdfAqHGmPGOSsPmA==",
      "dev": true,
      "engines": {
        "node": ">=18.12"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4"
      }
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/type-detect": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.1.0.tgz",
      "integrity": "sha512-Acylog8/luQ8L7il+geoSxhEkazvkslg7PSNKOX59mbB9cOveP5aq9h74Y7YU8yDpJwetzQQrfIwtf4Wp4LKcw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "dev": true,
      "license": "Apache-2.0",
      "peer": true,
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/typescript-eslint": {
      "version": "8.54.0",
      "resolved": "https://registry.npmjs.org/typescript-eslint/-/typescript-eslint-8.54.0.tgz",
      "integrity": "sha512-CKsJ+g53QpsNPqbzUsfKVgd3Lny4yKZ1pP4qN3jdMOg/sisIDLGyDMezycquXLE5JsEU0wp3dGNdzig0/fmSVQ==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/eslint-plugin": "8.54.0",
        "@typescript-eslint/parser": "8.54.0",
        "@typescript-eslint/typescript-estree": "8.54.0",
        "@typescript-eslint/utils": "8.54.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/ufo": {
      "version": "1.6.3",
      "resolved": "https://registry.npmjs.org/ufo/-/ufo-1.6.3.tgz",
      "integrity": "sha512-yDJTmhydvl5lJzBmy/hyOAA0d+aqCBuwl818haVdYCRrWV84o7YyeVm4QlVHStqNrrJSTb6jKuFAVqAFsr+K3Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/vite": {
      "version": "3.2.11",
      "resolved": "https://registry.npmjs.org/vite/-/vite-3.2.11.tgz",
      "integrity": "sha512-K/jGKL/PgbIgKCiJo5QbASQhFiV02X9Jh+Qq0AKCRCRKZtOTVi4t6wh75FDpGf2N9rYOnzH87OEFQNaFy6pdxQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.15.9",
        "postcss": "^8.4.18",
        "resolve": "^1.22.1",
        "rollup": "^2.79.1"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^14.18.0 || >=16.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      },
      "peerDependencies": {
        "@types/node": ">= 14",
        "less": "*",
        "sass": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite-node": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/vite-node/-/vite-node-1.6.1.tgz",
      "integrity": "sha512-YAXkfvGtuTzwWbDSACdJSg4A4DZiAqckWe90Zapc/sEX3XvHcw1NdurM/6od8J207tSDqNbSsgdCacBgvJKFuA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cac": "^6.7.14",
        "debug": "^4.3.4",
        "pathe": "^1.1.1",
        "picocolors": "^1.0.0",
        "vite": "^5.0.0"
      },
      "bin": {
        "vite-node": "vite-node.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/vite-node/node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite-node/node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite-node/node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/vite-node/node_modules/rollup": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.57.1.tgz",
      "integrity": "sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.57.1",
        "@rollup/rollup-android-arm64": "4.57.1",
        "@rollup/rollup-darwin-arm64": "4.57.1",
        "@rollup/rollup-darwin-x64": "4.57.1",
        "@rollup/rollup-freebsd-arm64": "4.57.1",
        "@rollup/rollup-freebsd-x64": "4.57.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.57.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.57.1",
        "@rollup/rollup-linux-arm64-gnu": "4.57.1",
        "@rollup/rollup-linux-arm64-musl": "4.57.1",
        "@rollup/rollup-linux-loong64-gnu": "4.57.1",
        "@rollup/rollup-linux-loong64-musl": "4.57.1",
        "@rollup/rollup-linux-ppc64-gnu": "4.57.1",
        "@rollup/rollup-linux-ppc64-musl": "4.57.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.57.1",
        "@rollup/rollup-linux-riscv64-musl": "4.57.1",
        "@rollup/rollup-linux-s390x-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-musl": "4.57.1",
        "@rollup/rollup-openbsd-x64": "4.57.1",
        "@rollup/rollup-openharmony-arm64": "4.57.1",
        "@rollup/rollup-win32-arm64-msvc": "4.57.1",
        "@rollup/rollup-win32-ia32-msvc": "4.57.1",
        "@rollup/rollup-win32-x64-gnu": "4.57.1",
        "@rollup/rollup-win32-x64-msvc": "4.57.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/vite-node/node_modules/vite": {
      "version": "5.4.21",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.21.tgz",
      "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vitest": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/vitest/-/vitest-1.6.1.tgz",
      "integrity": "sha512-Ljb1cnSJSivGN0LqXd/zmDbWEM0RNNg2t1QW/XUhYl/qPqyu7CsqeWtqQXHVaJsecLPuDoak2oJcZN2QoRIOag==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/expect": "1.6.1",
        "@vitest/runner": "1.6.1",
        "@vitest/snapshot": "1.6.1",
        "@vitest/spy": "1.6.1",
        "@vitest/utils": "1.6.1",
        "acorn-walk": "^8.3.2",
        "chai": "^4.3.10",
        "debug": "^4.3.4",
        "execa": "^8.0.1",
        "local-pkg": "^0.5.0",
        "magic-string": "^0.30.5",
        "pathe": "^1.1.1",
        "picocolors": "^1.0.0",
        "std-env": "^3.5.0",
        "strip-literal": "^2.0.0",
        "tinybench": "^2.5.1",
        "tinypool": "^0.8.3",
        "vite": "^5.0.0",
        "vite-node": "1.6.1",
        "why-is-node-running": "^2.2.2"
      },
      "bin": {
        "vitest": "vitest.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@edge-runtime/vm": "*",
        "@types/node": "^18.0.0 || >=20.0.0",
        "@vitest/browser": "1.6.1",
        "@vitest/ui": "1.6.1",
        "happy-dom": "*",
        "jsdom": "*"
      },
      "peerDependenciesMeta": {
        "@edge-runtime/vm": {
          "optional": true
        },
        "@types/node": {
          "optional": true
        },
        "@vitest/browser": {
          "optional": true
        },
        "@vitest/ui": {
          "optional": true
        },
        "happy-dom": {
          "optional": true
        },
        "jsdom": {
          "optional": true
        }
      }
    },
    "node_modules/vitest/node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vitest/node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vitest/node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/vitest/node_modules/rollup": {
      "version": "4.57.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.57.1.tgz",
      "integrity": "sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.57.1",
        "@rollup/rollup-android-arm64": "4.57.1",
        "@rollup/rollup-darwin-arm64": "4.57.1",
        "@rollup/rollup-darwin-x64": "4.57.1",
        "@rollup/rollup-freebsd-arm64": "4.57.1",
        "@rollup/rollup-freebsd-x64": "4.57.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.57.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.57.1",
        "@rollup/rollup-linux-arm64-gnu": "4.57.1",
        "@rollup/rollup-linux-arm64-musl": "4.57.1",
        "@rollup/rollup-linux-loong64-gnu": "4.57.1",
        "@rollup/rollup-linux-loong64-musl": "4.57.1",
        "@rollup/rollup-linux-ppc64-gnu": "4.57.1",
        "@rollup/rollup-linux-ppc64-musl": "4.57.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.57.1",
        "@rollup/rollup-linux-riscv64-musl": "4.57.1",
        "@rollup/rollup-linux-s390x-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-gnu": "4.57.1",
        "@rollup/rollup-linux-x64-musl": "4.57.1",
        "@rollup/rollup-openbsd-x64": "4.57.1",
        "@rollup/rollup-openharmony-arm64": "4.57.1",
        "@rollup/rollup-win32-arm64-msvc": "4.57.1",
        "@rollup/rollup-win32-ia32-msvc": "4.57.1",
        "@rollup/rollup-win32-x64-gnu": "4.57.1",
        "@rollup/rollup-win32-x64-msvc": "4.57.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/vitest/node_modules/vite": {
      "version": "5.4.21",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.21.tgz",
      "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/why-is-node-running": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/why-is-node-running/-/why-is-node-running-2.3.0.tgz",
      "integrity": "sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "siginfo": "^2.0.0",
        "stackback": "0.0.2"
      },
      "bin": {
        "why-is-node-running": "cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/yocto-queue": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-1.2.2.tgz",
      "integrity": "sha512-4LCcse/U2MHZ63HAJVE+v71o7yOdIe4cZ70Wpf8D/IyjDKYQLV5GD46B+hSTjJsvV5PztjvHoU580EftxjDZFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.20"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  }
}

```


--| frontend/package.json

```json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier . --check",
    "format:fix": "prettier . --write"
  },
  "devDependencies": {
    "@eslint/js": "^9.20.0",
    "eslint": "^9.20.0",
    "eslint-config-prettier": "^10.0.1",
    "prettier": "^3.5.2",
    "typescript": "^5.4.5",
    "typescript-eslint": "^8.24.1",
    "vite": "^3.0.7",
    "vitest": "^1.6.0"
  },
  "dependencies": {
    "@lit-labs/preact-signals": "^1.0.3",
    "@preact/signals-core": "^1.12.2",
    "lit": "^3.3.2"
  }
}

```


--| frontend/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": false,
    "module": "ESNext",
    "moduleResolution": "Node",
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  },
  "include": [
    "src",
    "wailsjs"
  ]
}
```


--| frontend/wailsjs/runtime/package.json

```json
{
  "name": "@wailsapp/runtime",
  "version": "2.0.0",
  "description": "Wails Javascript runtime library",
  "main": "runtime.js",
  "types": "runtime.d.ts",
  "scripts": {
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wailsapp/wails.git"
  },
  "keywords": [
    "Wails",
    "Javascript",
    "Go"
  ],
  "author": "Lea Anthony <lea.anthony@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wailsapp/wails/issues"
  },
  "homepage": "https://github.com/wailsapp/wails#readme"
}

```


--| go.mod

```mod
module github.com/MadeByDoug/wls-chatbot

go 1.24.0

require (
	github.com/anthropics/anthropic-sdk-go v1.21.0
	github.com/cloudflare/cloudflare-go v0.116.0
	github.com/openai/openai-go v1.12.0
	github.com/rs/zerolog v1.34.0
	github.com/spf13/cobra v1.10.2
	github.com/stretchr/testify v1.10.0
	github.com/zalando/go-keyring v0.2.6
	google.golang.org/genai v1.45.0
	gopkg.in/yaml.v3 v3.0.1
	modernc.org/sqlite v1.44.3
)

require (
	cloud.google.com/go v0.116.0 // indirect
	cloud.google.com/go/auth v0.9.3 // indirect
	cloud.google.com/go/compute/metadata v0.5.0 // indirect
	github.com/bep/debounce v1.2.1 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/go-ole/go-ole v1.3.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/google/go-querystring v1.1.0 // indirect
	github.com/google/s2a-go v0.1.8 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e // indirect
	github.com/labstack/echo/v4 v4.13.3 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/leaanthony/go-ansi-parser v1.6.1 // indirect
	github.com/leaanthony/gosod v1.0.4 // indirect
	github.com/leaanthony/slicer v1.6.0 // indirect
	github.com/leaanthony/u v1.1.1 // indirect
	github.com/ncruces/go-strftime v1.0.0 // indirect
	github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/samber/lo v1.49.1 // indirect
	github.com/spf13/pflag v1.0.9 // indirect
	github.com/tkrajina/go-reflector v0.5.8 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/wailsapp/go-webview2 v1.0.22 // indirect
	github.com/wailsapp/mimetype v1.4.1 // indirect
	go.opencensus.io v0.24.0 // indirect
	golang.org/x/crypto v0.40.0 // indirect
	golang.org/x/exp v0.0.0-20251023183803-a4bb9ffd2546 // indirect
	golang.org/x/net v0.41.0 // indirect
	golang.org/x/text v0.27.0 // indirect
	golang.org/x/time v0.9.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240903143218-8af14fe29dc1 // indirect
	google.golang.org/grpc v1.66.2 // indirect
	google.golang.org/protobuf v1.34.2 // indirect
	modernc.org/libc v1.67.6 // indirect
	modernc.org/mathutil v1.7.1 // indirect
	modernc.org/memory v1.11.0 // indirect
)

require (
	al.essio.dev/pkg/shellescape v1.5.1 // indirect
	github.com/danieljoos/wincred v1.2.2 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/tidwall/gjson v1.18.0 // indirect
	github.com/tidwall/match v1.2.0 // indirect
	github.com/tidwall/pretty v1.2.1 // indirect
	github.com/tidwall/sjson v1.2.5 // indirect
	github.com/wailsapp/wails/v2 v2.11.0
	golang.org/x/sys v0.38.0 // indirect
)

// replace github.com/wailsapp/wails/v2 v2.11.0 => /home/doug/go/pkg/mod

```


--| internal/core/config/config.go

```go
// config.go defines application configuration entities and helpers.
// internal/core/config/config.go
package config

import (
	"errors"
	"fmt"
	"sort"
	"strings"
	"time"

	modelcatalog "github.com/MadeByDoug/wls-chatbot/pkg/models"
)

// AppConfig represents the root application configuration.
type AppConfig struct {
	Providers []ProviderConfig `json:"providers"`
}

// UpdateFrequency describes how often provider resources are refreshed.
type UpdateFrequency string

const (
	UpdateFrequencyManual UpdateFrequency = "manual"
	UpdateFrequencyHourly UpdateFrequency = "hourly"
	UpdateFrequencyDaily  UpdateFrequency = "daily"
	UpdateFrequencyWeekly UpdateFrequency = "weekly"
)

// ProviderConfig describes a configured provider.
type ProviderConfig struct {
	Type            string            `json:"type"`
	Name            string            `json:"name"`
	DisplayName     string            `json:"displayName"`
	BaseURL         string            `json:"baseUrl"`
	DefaultModel    string            `json:"defaultModel"`
	UpdateFrequency UpdateFrequency   `json:"updateFrequency"`
	Models          []ModelConfig     `json:"models"`
	Inputs          map[string]string `json:"inputs,omitempty"`
}

// ModelConfig describes a provider model toggle in configuration.
type ModelConfig struct {
	ID      string `json:"id"`
	Enabled bool   `json:"enabled"`
}

// LoadConfig loads configuration from the provided store.
func LoadConfig(store Store) (AppConfig, error) {

	if store == nil {
		return AppConfig{}, fmt.Errorf("load config: store required")
	}

	cfg, err := store.Load()
	if err == nil {
		return cfg, nil
	}
	if errors.Is(err, ErrConfigNotFound) {
		cfg, cfgErr := defaultConfigFromCatalog()
		if cfgErr != nil {
			return AppConfig{}, fmt.Errorf("load config: default from catalog: %w", cfgErr)
		}
		if saveErr := store.Save(cfg); saveErr != nil {
			return AppConfig{}, fmt.Errorf("load config: save default: %w", saveErr)
		}
		return cfg, nil
	}

	return AppConfig{}, fmt.Errorf("load config: %w", err)
}

// ResolveUpdateFrequencies parses provider update frequencies from configuration.
func ResolveUpdateFrequencies(cfg AppConfig) (map[string]time.Duration, error) {

	frequencies := make(map[string]time.Duration)
	for _, providerConfig := range cfg.Providers {
		if providerConfig.UpdateFrequency == "" {
			continue
		}
		frequency, err := parseUpdateFrequency(providerConfig.UpdateFrequency)
		if err != nil {
			return nil, fmt.Errorf("provider %s updateFrequency: %w", providerConfig.Name, err)
		}
		if frequency <= 0 {
			continue
		}
		frequencies[providerConfig.Name] = frequency
	}

	if len(frequencies) == 0 {
		return nil, nil
	}

	return frequencies, nil
}

// parseUpdateFrequency converts enum values into durations.
func parseUpdateFrequency(value UpdateFrequency) (time.Duration, error) {

	switch value {
	case UpdateFrequencyManual:
		return 0, nil
	case UpdateFrequencyHourly:
		return time.Hour, nil
	case UpdateFrequencyDaily:
		return 24 * time.Hour, nil
	case UpdateFrequencyWeekly:
		return 7 * 24 * time.Hour, nil
	default:
		return 0, fmt.Errorf("unknown update frequency: %s", value)
	}
}

// defaultConfigFromCatalog builds default provider/model config from the canonical pkg/models catalog.
func defaultConfigFromCatalog() (AppConfig, error) {

	catalog, err := modelcatalog.LoadEmbedded()
	if err != nil {
		return AppConfig{}, err
	}

	providerByCatalogID := make(map[string]modelcatalog.Provider, len(catalog.Providers))
	for _, provider := range catalog.Providers {
		providerByCatalogID[strings.TrimSpace(provider.ID)] = provider
	}

	familyProviderByID := make(map[string]string, len(catalog.Families))
	for _, family := range catalog.Families {
		catalogProviderID := strings.TrimSpace(family.Provider)
		provider, ok := providerByCatalogID[catalogProviderID]
		if !ok {
			return AppConfig{}, fmt.Errorf("unsupported catalog provider: %s", family.Provider)
		}
		familyProviderByID[strings.TrimSpace(family.ID)] = strings.TrimSpace(provider.ID)
	}

	modelsByProvider := make(map[string][]ModelConfig)
	modelSeenByProvider := make(map[string]map[string]struct{})
	defaultModelByProvider := make(map[string]string)
	for _, model := range catalog.Models {
		providerName, ok := familyProviderByID[strings.TrimSpace(model.Family)]
		if !ok {
			return AppConfig{}, fmt.Errorf("catalog model %s references unknown family %s", model.ID, model.Family)
		}

		modelID := strings.TrimSpace(model.ID)
		if modelID == "" {
			continue
		}
		if _, seen := modelSeenByProvider[providerName]; !seen {
			modelSeenByProvider[providerName] = make(map[string]struct{})
		}
		if _, seen := modelSeenByProvider[providerName][modelID]; seen {
			continue
		}
		modelSeenByProvider[providerName][modelID] = struct{}{}
		modelsByProvider[providerName] = append(modelsByProvider[providerName], ModelConfig{ID: modelID, Enabled: true})
		if defaultModelByProvider[providerName] == "" {
			defaultModelByProvider[providerName] = modelID
		}
	}

	providerNames := make([]string, 0, len(modelsByProvider))
	for providerName := range modelsByProvider {
		providerNames = append(providerNames, providerName)
	}
	sort.Strings(providerNames)

	providers := make([]ProviderConfig, 0, len(providerNames))
	for _, providerID := range providerNames {
		provider := providerByCatalogID[providerID]
		name := strings.TrimSpace(provider.Name)
		if name == "" {
			return AppConfig{}, fmt.Errorf("catalog provider %s missing name", providerID)
		}
		providerType := strings.TrimSpace(provider.Type)
		if providerType == "" {
			return AppConfig{}, fmt.Errorf("catalog provider %s missing type", providerID)
		}
		displayName := strings.TrimSpace(provider.DisplayName)
		if displayName == "" {
			return AppConfig{}, fmt.Errorf("catalog provider %s missing display_name", providerID)
		}
		baseURL := strings.TrimSpace(provider.BaseURL)

		providers = append(providers, ProviderConfig{
			Type:            providerType,
			Name:            name,
			DisplayName:     displayName,
			BaseURL:         baseURL,
			DefaultModel:    defaultModelByProvider[providerID],
			UpdateFrequency: UpdateFrequencyManual,
			Models:          modelsByProvider[providerID],
			Inputs:          map[string]string{},
		})
	}

	return AppConfig{Providers: providers}, nil
}

```


--| internal/core/config/sqlite.go

```go
// sqlite.go persists application configuration and provider inputs in SQLite.
// internal/core/config/configstore/sqlite.go
package config

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	// config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
)

const appConfigSchema = `
CREATE TABLE IF NOT EXISTS app_config (
	id INTEGER PRIMARY KEY CHECK (id = 1),
	config_json TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL
);`

// SQLiteStore persists application configuration in SQLite.
type SQLiteStore struct {
	db *sql.DB
}

// NewSQLiteStore creates a SQLite-backed configuration store.
func NewSQLiteStore(db *sql.DB) (*SQLiteStore, error) {

	if db == nil {
		return nil, fmt.Errorf("config store: db required")
	}

	if _, err := db.Exec(appConfigSchema); err != nil {
		return nil, fmt.Errorf("config store: ensure schema: %w", err)
	}

	return &SQLiteStore{db: db}, nil
}

var _ Store = (*SQLiteStore)(nil)
var _ providercore.ProviderInputsStore = (*SQLiteStore)(nil)

// Load returns the stored application configuration.
func (s *SQLiteStore) Load() (AppConfig, error) {

	if s == nil || s.db == nil {
		return AppConfig{}, fmt.Errorf("config store: db required")
	}

	row := s.db.QueryRow("SELECT config_json FROM app_config WHERE id = 1")
	var data string
	if err := row.Scan(&data); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return AppConfig{}, ErrConfigNotFound
		}
		return AppConfig{}, fmt.Errorf("config store: load: %w", err)
	}

	var cfg AppConfig
	if err := json.Unmarshal([]byte(data), &cfg); err != nil {
		return AppConfig{}, fmt.Errorf("config store: decode: %w", err)
	}

	return cfg, nil
}

// Save writes the application configuration to the store.
func (s *SQLiteStore) Save(cfg AppConfig) error {

	if s == nil || s.db == nil {
		return fmt.Errorf("config store: db required")
	}

	data, err := json.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("config store: encode: %w", err)
	}

	now := time.Now().UnixMilli()
	_, err = s.db.Exec(
		`INSERT INTO app_config (id, config_json, created_at, updated_at)
		 VALUES (1, ?, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		  config_json = excluded.config_json,
		  updated_at = excluded.updated_at`,
		string(data),
		now,
		now,
	)
	if err != nil {
		return fmt.Errorf("config store: save: %w", err)
	}

	return nil
}

// LoadProviderInputs returns stored input values for a provider.
func (s *SQLiteStore) LoadProviderInputs(providerName string) (map[string]string, error) {

	cfg, err := s.Load()
	if err != nil {
		return nil, err
	}

	for i := range cfg.Providers {
		if cfg.Providers[i].Name == providerName {
			return cloneInputs(cfg.Providers[i].Inputs), nil
		}
	}

	return nil, fmt.Errorf("config store: provider not found: %s", providerName)
}

// SaveProviderInputs persists input values for a provider.
func (s *SQLiteStore) SaveProviderInputs(providerName string, inputs map[string]string) error {

	cfg, err := s.Load()
	if err != nil {
		return err
	}

	sanitizedInputs, err := sanitizeProviderInputs(inputs)
	if err != nil {
		return err
	}

	found := false
	for i := range cfg.Providers {
		if cfg.Providers[i].Name == providerName {
			cfg.Providers[i].Inputs = sanitizedInputs
			found = true
			break
		}
	}

	if !found {
		return fmt.Errorf("config store: provider not found: %s", providerName)
	}

	return s.Save(cfg)
}

// cloneInputs copies provider input values into a new map.
func cloneInputs(inputs map[string]string) map[string]string {

	if len(inputs) == 0 {
		return nil
	}
	clone := make(map[string]string, len(inputs))
	for key, value := range inputs {
		clone[key] = value
	}
	return clone
}

// sanitizeProviderInputs trims inputs and rejects secret-like keys from plain config persistence.
func sanitizeProviderInputs(inputs map[string]string) (map[string]string, error) {

	if len(inputs) == 0 {
		return nil, nil
	}

	sanitized := make(map[string]string, len(inputs))
	for key, value := range inputs {
		trimmedKey := strings.TrimSpace(key)
		trimmedValue := strings.TrimSpace(value)
		if trimmedKey == "" || trimmedValue == "" {
			continue
		}
		if providercore.IsSensitiveCredentialName(trimmedKey) {
			return nil, fmt.Errorf("config store: secret-like input key is not allowed: %s", trimmedKey)
		}
		sanitized[trimmedKey] = trimmedValue
	}

	if len(sanitized) == 0 {
		return nil, nil
	}
	return sanitized, nil
}

```


--| internal/core/config/store.go

```go
// store.go defines application configuration storage contracts.
// internal/core/config/app/store.go
package config

import "errors"

// ErrConfigNotFound signals the configuration has not been stored yet.
var ErrConfigNotFound = errors.New("config not found")

// Store persists application configuration.
type Store interface {
	Load() (AppConfig, error)
	Save(AppConfig) error
}

```


--| internal/core/datastore/seeder.go

```go
// seeder.go imports model catalog seed data into the datastore.
// internal/core/adapters/datastore/seeder.go
package datastore

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	modelcatalog "github.com/MadeByDoug/wls-chatbot/pkg/models"
)

// seededProvider describes a provider row used by model seeding.
type seededProvider struct {
	ID          string
	Name        string
	DisplayName string
	AdapterType string
	BaseURL     string
}

// SeedModels populates the database with model data from YAML
func SeedModels(db *sql.DB, data []byte) error {
	catalog, err := modelcatalog.Parse(data)
	if err != nil {
		return err
	}

	families := make(map[string]modelcatalog.Family)
	for _, f := range catalog.Families {
		families[f.ID] = f
	}

	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}
	defer func() {
		_ = tx.Rollback() // Rollback is a no-op if tx.Commit() was called
	}()

	now := time.Now().UnixMilli()

	// Prepare statements
	stmtEndpoint, err := tx.Prepare(`
		INSERT INTO catalog_endpoints (
			id, provider_id, display_name, adapter_type, base_url, route_kind, 
			origin_provider, origin_route_label, created_at, updated_at
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		ON CONFLICT(id) DO UPDATE SET
			provider_id = excluded.provider_id,
			display_name = excluded.display_name,
			adapter_type = excluded.adapter_type,
			base_url = excluded.base_url,
			route_kind = excluded.route_kind,
			origin_provider = excluded.origin_provider,
			origin_route_label = excluded.origin_route_label,
			updated_at = excluded.updated_at
	`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtEndpoint.Close() }()

	stmtEntry, err := tx.Prepare(`
		INSERT INTO model_catalog_entries (
			id, endpoint_id, model_id, display_name, first_seen_at, last_seen_at, 
			availability_state, approved, missed_refreshes, source, metadata_json
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		ON CONFLICT(endpoint_id, model_id) DO UPDATE SET last_seen_at = ?
	`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtEntry.Close() }()

	stmtCapabilities, err := tx.Prepare(`
		INSERT OR REPLACE INTO model_capabilities (
			model_catalog_entry_id, supports_streaming, supports_tool_calling, 
			supports_structured_output, supports_vision, capabilities_source, capabilities_as_of
		) VALUES (?, ?, ?, ?, ?, ?, ?)
	`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtCapabilities.Close() }()

	stmtSysTags, err := tx.Prepare(`INSERT OR IGNORE INTO model_system_tags (model_catalog_entry_id, tag) VALUES (?, ?)`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtSysTags.Close() }()

	stmtInputMod, err := tx.Prepare(`INSERT OR IGNORE INTO model_capabilities_input_modalities (model_catalog_entry_id, modality) VALUES (?, ?)`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtInputMod.Close() }()

	stmtOutputMod, err := tx.Prepare(`INSERT OR IGNORE INTO model_capabilities_output_modalities (model_catalog_entry_id, modality) VALUES (?, ?)`)
	if err != nil {
		return err
	}
	defer func() { _ = stmtOutputMod.Close() }()

	for _, model := range catalog.Models {
		fam, ok := families[model.Family]
		if !ok {
			return fmt.Errorf("unknown family %q for model %q", model.Family, model.ID)
		}
		provider, err := resolveSeededProvider(tx, fam.Provider)
		if err != nil {
			return fmt.Errorf("resolve provider for family %q: %w", model.Family, err)
		}

		// 1. Ensure Endpoint Exists (provider_id is constructed from provider name)
		endpointID := "ep_" + provider.Name + "_default"

		if _, err := stmtEndpoint.Exec(
			endpointID, provider.ID, provider.DisplayName+" Default", provider.AdapterType, provider.BaseURL, "llm",
			provider.Name, "default", now, now,
		); err != nil {
			return fmt.Errorf("insert endpoint: %w", err)
		}

		// 2. Insert Model Entry
		entryID := "entry_" + provider.Name + "_" + model.ID
		metadata := map[string]interface{}{
			"family":      model.Family,
			"is_snapshot": model.IsSnapshot,
		}
		if model.LinkAlias != "" {
			metadata["link_alias"] = model.LinkAlias
		}
		metaBytes, err := json.Marshal(metadata)
		if err != nil {
			return fmt.Errorf("marshal metadata for model %q: %w", model.ID, err)
		}

		if _, err := stmtEntry.Exec(
			entryID, endpointID, model.ID, model.ID, now, now,
			"available", 1, 0, "seed", string(metaBytes), now,
		); err != nil {
			return fmt.Errorf("insert entry %s: %w", model.ID, err)
		}

		// 3. Insert Capabilities
		if _, err := stmtCapabilities.Exec(
			entryID, fam.Capabilities.Streaming, fam.Capabilities.ToolCalling,
			fam.Capabilities.StructuredOutput, fam.Capabilities.Vision, "seed_v1", now,
		); err != nil {
			return fmt.Errorf("insert capabilities %s: %w", model.ID, err)
		}

		// 4. Insert Tags & Modalities
		for _, tag := range fam.SystemTags {
			if _, err := stmtSysTags.Exec(entryID, tag); err != nil {
				return err
			}
		}
		for _, mod := range fam.Modalities.Input {
			if _, err := stmtInputMod.Exec(entryID, mod); err != nil {
				return err
			}
		}
		for _, mod := range fam.Modalities.Output {
			if _, err := stmtOutputMod.Exec(entryID, mod); err != nil {
				return err
			}
		}
	}

	return tx.Commit()
}

// resolveSeededProvider maps YAML provider identifiers to catalog providers.
func resolveSeededProvider(tx *sql.Tx, providerName string) (seededProvider, error) {

	name := strings.TrimSpace(strings.ToLower(providerName))
	switch name {
	case "google":
		name = "gemini"
	case "xai":
		name = "grok"
	}

	var provider seededProvider
	if err := tx.QueryRow(
		`SELECT id, name, display_name, adapter_type, base_url
		 FROM catalog_providers
		 WHERE name = ?`,
		name,
	).Scan(
		&provider.ID,
		&provider.Name,
		&provider.DisplayName,
		&provider.AdapterType,
		&provider.BaseURL,
	); err != nil {
		if err == sql.ErrNoRows {
			return seededProvider{}, fmt.Errorf("provider %q not found in catalog_providers", name)
		}
		return seededProvider{}, err
	}

	if provider.BaseURL == "" {
		return seededProvider{}, fmt.Errorf("provider %q has empty base_url", provider.Name)
	}

	return provider, nil
}

```


--| internal/core/datastore/sqlite.go

```go
// sqlite.go opens and configures the shared SQLite datastore.
// internal/core/adapters/datastore/sqlite.go
package datastore

import (
	"database/sql"
	"embed"
	"fmt"
	"os"
	"path/filepath"

	modelcatalog "github.com/MadeByDoug/wls-chatbot/pkg/models"
	"github.com/rs/zerolog/log"
	_ "modernc.org/sqlite"
)

//go:embed schema.sql seed.sql
var sqlFiles embed.FS

const minimumDefaultProviderCount = 5
const sqliteBusyTimeoutMillis = 5000

var requiredSchemaTables = []string{
	"app_config",
	"catalog_providers",
	"provider_inputs",
	"catalog_endpoints",
	"model_catalog_entries",
	"model_capabilities",
	"model_capabilities_input_modalities",
	"model_capabilities_output_modalities",
	"model_system_profile",
	"model_system_tags",
	"model_user_addenda",
	"model_user_tags",
	"roles",
	"role_required_input_modalities",
	"role_required_output_modalities",
	"role_assignments",
	"chat_conversations",
	"chat_messages",
	"chat_message_blocks",
}

// OpenSQLite opens the SQLite database at the provided path.
func OpenSQLite(path string) (*sql.DB, error) {

	if path == "" {
		return nil, fmt.Errorf("open sqlite: path required")
	}

	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return nil, fmt.Errorf("open sqlite: ensure directory: %w", err)
	}

	db, err := sql.Open("sqlite", path)
	if err != nil {
		return nil, fmt.Errorf("open sqlite: %w", err)
	}

	if err := db.Ping(); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}

	db.SetMaxOpenConns(1)
	db.SetMaxIdleConns(1)

	if _, err := db.Exec("PRAGMA foreign_keys = ON"); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}
	if _, err := db.Exec("PRAGMA journal_mode = WAL"); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}
	if _, err := db.Exec("PRAGMA synchronous = NORMAL"); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}
	if _, err := db.Exec(fmt.Sprintf("PRAGMA busy_timeout = %d", sqliteBusyTimeoutMillis)); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}
	if _, err := db.Exec("PRAGMA temp_store = MEMORY"); err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: %w", err)
	}

	needsInit, err := shouldInitializeDatabase(db)
	if err != nil {
		_ = db.Close()
		return nil, fmt.Errorf("open sqlite: check initialization state: %w", err)
	}
	if needsInit {
		log.Info().Str("path", path).Msg("Initializing SQLite datastore")
		if err := initDatabase(db); err != nil {
			_ = db.Close()
			return nil, fmt.Errorf("open sqlite: init failed: %w", err)
		}

		needsInit, err = shouldInitializeDatabase(db)
		if err != nil {
			_ = db.Close()
			return nil, fmt.Errorf("open sqlite: verify initialization state: %w", err)
		}
		if needsInit {
			_ = db.Close()
			return nil, fmt.Errorf("open sqlite: init failed: datastore remains incomplete")
		}
	}

	return db, nil
}

// shouldInitializeDatabase determines whether schema and seed data are complete.
func shouldInitializeDatabase(db *sql.DB) (bool, error) {

	for _, tableName := range requiredSchemaTables {
		exists, err := tableExists(db, tableName)
		if err != nil {
			return false, err
		}
		if !exists {
			return true, nil
		}
	}

	appConfigRows, err := countRows(db, "SELECT COUNT(*) FROM app_config WHERE id = 1")
	if err != nil {
		return false, err
	}
	if appConfigRows == 0 {
		return true, nil
	}

	defaultProviders, err := countRows(db, "SELECT COUNT(*) FROM catalog_providers")
	if err != nil {
		return false, err
	}
	if defaultProviders < minimumDefaultProviderCount {
		return true, nil
	}

	seedModels, err := countRows(db, "SELECT COUNT(*) FROM model_catalog_entries WHERE source = 'seed'")
	if err != nil {
		return false, err
	}
	return seedModels == 0, nil
}

// tableExists returns whether a SQLite table exists.
func tableExists(db *sql.DB, tableName string) (bool, error) {

	var count int
	if err := db.QueryRow(
		"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name = ?",
		tableName,
	).Scan(&count); err != nil {
		return false, err
	}
	return count > 0, nil
}

// countRows executes a scalar count query.
func countRows(db *sql.DB, query string, args ...any) (int, error) {

	var count int
	if err := db.QueryRow(query, args...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// initDatabase executes the schema and seed scripts.
func initDatabase(db *sql.DB) error {

	log.Debug().Msg("Applying schema initialization script")
	schema, err := sqlFiles.ReadFile("schema.sql")
	if err != nil {
		return fmt.Errorf("read schema: %w", err)
	}
	if _, err := db.Exec(string(schema)); err != nil {
		return fmt.Errorf("exec schema: %w", err)
	}

	log.Debug().Msg("Applying seed initialization script")
	seed, err := sqlFiles.ReadFile("seed.sql")
	if err != nil {
		return fmt.Errorf("read seed: %w", err)
	}
	if _, err := db.Exec(string(seed)); err != nil {
		return fmt.Errorf("exec seed: %w", err)
	}

	log.Debug().Msg("Applying model seed initialization script")
	if err := SeedModels(db, modelcatalog.EmbeddedYAML()); err != nil {
		return fmt.Errorf("seed models: %w", err)
	}
	log.Debug().Msg("SQLite datastore initialization completed")

	return nil
}

```


--| internal/core/events/events.go

```go
// events.go defines generic typed event signal contracts and registration.
// internal/core/events/events.go
package events

import (
	"fmt"
	"reflect"
	"sort"
	"strings"
	"sync"
)

// Name identifies a frontend/backend event signal.
type Name string

// Signal is a strongly typed event signal identifier.
type Signal[T any] struct {
	name Name
}

// Name returns the wire signal name.
func (s Signal[T]) Name() Name {

	return s.name
}

// EmptyPayload is used for signals that intentionally carry no payload.
type EmptyPayload struct{}

// ToastPayload describes a generic toast notification signal payload.
type ToastPayload struct {
	Type    string `json:"type,omitempty"`
	Title   string `json:"title,omitempty"`
	Message string `json:"message,omitempty"`
}

// SignalToast is a shared UI signal for toast notifications.
var SignalToast = MustRegister[ToastPayload]("toast")

// Bus emits signals for transport adapters.
type Bus interface {
	Emit(signal Name, payload interface{})
}

// Emit publishes a strongly typed payload to a registered signal.
func Emit[T any](bus Bus, signal Signal[T], payload T) {

	if bus == nil {
		return
	}
	bus.Emit(signal.name, payload)
}

// Registry stores typed signal registrations.
type Registry struct {
	mu    sync.RWMutex
	types map[Name]reflect.Type
}

var defaultRegistry = NewRegistry()

// NewRegistry creates a typed signal registry.
func NewRegistry() *Registry {

	return &Registry{
		types: make(map[Name]reflect.Type),
	}
}

// register reserves a signal name for a payload type.
func (r *Registry) register(name Name, payloadType reflect.Type) (Name, error) {

	normalized, err := normalizeName(name)
	if err != nil {
		return "", err
	}

	r.mu.Lock()
	defer r.mu.Unlock()

	existing, exists := r.types[normalized]
	if exists {
		if existing == payloadType {
			return normalized, nil
		}
		return "", fmt.Errorf(
			"event registry: signal %q already registered with payload %s (requested %s)",
			normalized,
			existing.String(),
			payloadType.String(),
		)
	}

	r.types[normalized] = payloadType
	return normalized, nil
}

// RegisteredNames returns registered signal names in deterministic order.
func (r *Registry) RegisteredNames() []Name {

	r.mu.RLock()
	defer r.mu.RUnlock()

	names := make([]Name, 0, len(r.types))
	for name := range r.types {
		names = append(names, name)
	}
	sort.Slice(names, func(i, j int) bool {
		return names[i] < names[j]
	})
	return names
}

// PayloadType returns the registered payload type for a signal name.
func (r *Registry) PayloadType(name Name) (reflect.Type, bool) {

	r.mu.RLock()
	defer r.mu.RUnlock()
	payloadType, ok := r.types[name]
	return payloadType, ok
}

// RegisterIn adds a typed signal to a specific registry.
func RegisterIn[T any](registry *Registry, name Name) (Signal[T], error) {

	if registry == nil {
		return Signal[T]{}, fmt.Errorf("event registry: registry required")
	}

	registeredName, err := registry.register(name, payloadTypeOf[T]())
	if err != nil {
		return Signal[T]{}, err
	}
	return Signal[T]{name: registeredName}, nil
}

// MustRegisterIn adds a typed signal and panics when registration fails.
func MustRegisterIn[T any](registry *Registry, name Name) Signal[T] {

	signal, err := RegisterIn[T](registry, name)
	if err != nil {
		panic(err)
	}
	return signal
}

// Register adds a typed signal to the default registry.
func Register[T any](name Name) (Signal[T], error) {

	return RegisterIn[T](defaultRegistry, name)
}

// MustRegister adds a typed signal to the default registry and panics on failure.
func MustRegister[T any](name Name) Signal[T] {

	return MustRegisterIn[T](defaultRegistry, name)
}

// RegisteredNames returns default-registry signal names in deterministic order.
func RegisteredNames() []Name {

	return defaultRegistry.RegisteredNames()
}

// PayloadType returns a default-registry payload type for a signal name.
func PayloadType(name Name) (reflect.Type, bool) {

	return defaultRegistry.PayloadType(name)
}

func normalizeName(name Name) (Name, error) {

	normalized := Name(strings.TrimSpace(string(name)))
	if normalized == "" {
		return "", fmt.Errorf("event registry: signal name required")
	}
	return normalized, nil
}

func payloadTypeOf[T any]() reflect.Type {

	var pointer *T
	return reflect.TypeOf(pointer).Elem()
}

```


--| internal/core/logger/logger.go

```go
// define structured logging contracts for core use cases.
// internal/core/interfaces/logger.go
package logger

// LogField represents a structured logging field.
type LogField struct {
	Key   string
	Value string
}

// Logger provides structured logging for use cases.
type Logger interface {
	// Trace logs a trace message.
	Trace(message string, fields ...LogField)
	// Debug logs a debug message.
	Debug(message string, fields ...LogField)
	// Info logs an info message.
	Info(message string, fields ...LogField)
	// Warn logs a warning message with an optional error.
	Warn(message string, err error, fields ...LogField)
	// Error logs an error message with an optional error.
	Error(message string, err error, fields ...LogField)
}

```


--| internal/core/logger/zerolog.go

```go
// configure and adapt zerolog for core logging.
// internal/core/adapters/logger/zerolog.go
package logger

import (
	"os"
	"time"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

// New creates a new configured zerolog.Logger.
// It defaults to writing to a ConsoleWriter for human-readable output during development.
// This is compatible with Windows, Linux, and macOS.
func New(level string) zerolog.Logger {

	// Set global log level
	switch level {
	case "trace":
		zerolog.SetGlobalLevel(zerolog.TraceLevel)
	case "debug":
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	case "info":
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	case "warn":
		zerolog.SetGlobalLevel(zerolog.WarnLevel)
	case "error":
		zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	default:
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	}

	// Use ConsoleWriter for nicer development logs.
	// Out defaults to os.Stderr which is standard.
	// TimeFormat conforms to standard convenient reading.
	output := zerolog.ConsoleWriter{
		Out:        os.Stderr,
		TimeFormat: time.TimeOnly,
	}

	// Create a new logger with timestamp and caller information
	l := log.Output(output).With().Timestamp().Caller().Logger()

	return l
}

// Adapter bridges zerolog into the core Logger port.
type Adapter struct {
	logger zerolog.Logger
}

// NewAdapter creates a logger adapter for core use cases.
func NewAdapter(l zerolog.Logger) *Adapter {
	return &Adapter{logger: l}
}

// Trace logs a trace message.
func (a *Adapter) Trace(message string, fields ...LogField) {
	if a == nil {
		return
	}
	event := a.logger.Trace()
	writeFields(event, fields)
	event.Msg(message)
}

// Debug logs a debug message.
func (a *Adapter) Debug(message string, fields ...LogField) {
	if a == nil {
		return
	}
	event := a.logger.Debug()
	writeFields(event, fields)
	event.Msg(message)
}

// Info logs an info message.
func (a *Adapter) Info(message string, fields ...LogField) {
	if a == nil {
		return
	}
	event := a.logger.Info()
	writeFields(event, fields)
	event.Msg(message)
}

// Warn logs a warning message with an optional error.
func (a *Adapter) Warn(message string, err error, fields ...LogField) {
	if a == nil {
		return
	}
	event := a.logger.Warn()
	if err != nil {
		event = event.Err(err)
	}
	writeFields(event, fields)
	event.Msg(message)
}

// Error logs an error message with an optional error.
func (a *Adapter) Error(message string, err error, fields ...LogField) {

	if a == nil {
		return
	}
	event := a.logger.Error()
	if err != nil {
		event = event.Err(err)
	}
	writeFields(event, fields)
	event.Msg(message)
}

func writeFields(event *zerolog.Event, fields []LogField) {

	for _, field := range fields {
		event.Str(field.Key, field.Value)
	}
}

```


--| internal/features/ai/chat/adapters/chatrepo/sqlite.go

```go
// sqlite.go persists chat conversations with a normalized SQLite schema.
// internal/features/chat/adapters/chatrepo/sqlite.go
package chatrepo

import (
	"database/sql"
	"errors"
	"fmt"

	chatdomain "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/domain"
	chatports "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/ports"
)

const chatSchema = `
CREATE TABLE IF NOT EXISTS chat_conversations (
	id TEXT PRIMARY KEY,
	title TEXT NOT NULL,
	provider TEXT NOT NULL,
	model TEXT NOT NULL,
	temperature REAL NOT NULL,
	max_tokens INTEGER NOT NULL,
	system_prompt TEXT NOT NULL,
	created_at INTEGER NOT NULL,
	updated_at INTEGER NOT NULL,
	is_archived INTEGER NOT NULL CHECK (is_archived IN (0, 1))
);

CREATE TABLE IF NOT EXISTS chat_messages (
	id TEXT PRIMARY KEY,
	conversation_id TEXT NOT NULL,
	role TEXT NOT NULL,
	timestamp INTEGER NOT NULL,
	is_streaming INTEGER NOT NULL CHECK (is_streaming IN (0, 1)),
	provider TEXT,
	model TEXT,
	tokens_in INTEGER,
	tokens_out INTEGER,
	tokens_total INTEGER,
	latency_ms INTEGER,
	finish_reason TEXT,
	status_code INTEGER,
	error_message TEXT,
	FOREIGN KEY (conversation_id) REFERENCES chat_conversations(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_chat_messages_conversation_ts
ON chat_messages (conversation_id, timestamp DESC);

CREATE TABLE IF NOT EXISTS chat_message_blocks (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	message_id TEXT NOT NULL,
	block_index INTEGER NOT NULL,
	block_type TEXT NOT NULL,
	content TEXT NOT NULL,
	language TEXT,
	is_collapsed INTEGER NOT NULL CHECK (is_collapsed IN (0, 1)),
	artifact_id TEXT,
	artifact_name TEXT,
	artifact_type TEXT,
	artifact_content TEXT,
	artifact_language TEXT,
	artifact_version INTEGER,
	artifact_created_at INTEGER,
	artifact_updated_at INTEGER,
	action_id TEXT,
	action_tool_name TEXT,
	action_description TEXT,
	action_status TEXT,
	action_result TEXT,
	action_started_at INTEGER,
	action_completed_at INTEGER,
	FOREIGN KEY (message_id) REFERENCES chat_messages(id) ON DELETE CASCADE
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_chat_message_blocks_order
ON chat_message_blocks (message_id, block_index);
`

// Repository stores conversations in SQLite.
type Repository struct {
	db *sql.DB
}

// NewRepository creates a SQLite-backed chat repository.
func NewRepository(db *sql.DB) (*Repository, error) {

	if db == nil {
		return nil, fmt.Errorf("chat repo: db required")
	}
	if _, err := db.Exec(chatSchema); err != nil {
		return nil, fmt.Errorf("chat repo: ensure schema: %w", err)
	}

	return &Repository{db: db}, nil
}

var _ chatports.ChatRepository = (*Repository)(nil)

// Create saves a new conversation.
func (r *Repository) Create(conv *chatdomain.Conversation) error {

	if err := r.validateConversation(conv); err != nil {
		return err
	}

	return withTx(r.db, func(tx *sql.Tx) error {
		if err := insertConversation(tx, conv); err != nil {
			return err
		}
		if err := replaceMessages(tx, conv.ID, conv.Messages); err != nil {
			return err
		}
		return nil
	})
}

// Get returns a conversation by ID.
func (r *Repository) Get(id string) (*chatdomain.Conversation, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("chat repo: db required")
	}
	if id == "" {
		return nil, nil
	}

	var conv chatdomain.Conversation
	var isArchived int
	err := r.db.QueryRow(
		`SELECT id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived
		 FROM chat_conversations
		 WHERE id = ?`,
		id,
	).Scan(
		&conv.ID,
		&conv.Title,
		&conv.Settings.Provider,
		&conv.Settings.Model,
		&conv.Settings.Temperature,
		&conv.Settings.MaxTokens,
		&conv.Settings.SystemPrompt,
		&conv.CreatedAt,
		&conv.UpdatedAt,
		&isArchived,
	)
	if errors.Is(err, sql.ErrNoRows) {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("chat repo: get conversation: %w", err)
	}
	conv.IsArchived = isArchived == 1

	messages, err := loadMessages(r.db, conv.ID)
	if err != nil {
		return nil, err
	}
	conv.Messages = messages

	return &conv, nil
}

// List returns all conversations.
func (r *Repository) List() ([]*chatdomain.Conversation, error) {

	if r == nil || r.db == nil {
		return nil, fmt.Errorf("chat repo: db required")
	}

	rows, err := r.db.Query(
		`SELECT id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived
		 FROM chat_conversations
		 ORDER BY updated_at DESC`,
	)
	if err != nil {
		return nil, fmt.Errorf("chat repo: list conversations: %w", err)
	}

	conversations := make([]*chatdomain.Conversation, 0)
	for rows.Next() {
		conv := &chatdomain.Conversation{}
		var isArchived int
		if err := rows.Scan(
			&conv.ID,
			&conv.Title,
			&conv.Settings.Provider,
			&conv.Settings.Model,
			&conv.Settings.Temperature,
			&conv.Settings.MaxTokens,
			&conv.Settings.SystemPrompt,
			&conv.CreatedAt,
			&conv.UpdatedAt,
			&isArchived,
		); err != nil {
			return nil, fmt.Errorf("chat repo: list scan conversation: %w", err)
		}
		conv.IsArchived = isArchived == 1
		conversations = append(conversations, conv)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chat repo: list rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("chat repo: close rows: %w", err)
	}

	for _, conv := range conversations {
		messages, err := loadMessages(r.db, conv.ID)
		if err != nil {
			return nil, err
		}
		conv.Messages = messages
	}

	return conversations, nil
}

// Update persists a conversation update.
func (r *Repository) Update(conv *chatdomain.Conversation) error {

	if err := r.validateConversation(conv); err != nil {
		return err
	}

	return withTx(r.db, func(tx *sql.Tx) error {
		if err := upsertConversation(tx, conv); err != nil {
			return err
		}
		if err := replaceMessages(tx, conv.ID, conv.Messages); err != nil {
			return err
		}
		return nil
	})
}

// Delete removes a conversation by ID.
func (r *Repository) Delete(id string) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("chat repo: db required")
	}
	if id == "" {
		return nil
	}

	if _, err := r.db.Exec("DELETE FROM chat_conversations WHERE id = ?", id); err != nil {
		return fmt.Errorf("chat repo: delete: %w", err)
	}
	return nil
}

// validateConversation validates repository and conversation inputs.
func (r *Repository) validateConversation(conv *chatdomain.Conversation) error {

	if r == nil || r.db == nil {
		return fmt.Errorf("chat repo: db required")
	}
	if conv == nil || conv.ID == "" {
		return fmt.Errorf("chat repo: conversation required")
	}
	return nil
}

// withTx executes a function in a transaction.
func withTx(db *sql.DB, fn func(tx *sql.Tx) error) (err error) {

	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("chat repo: begin tx: %w", err)
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	if err = fn(tx); err != nil {
		return err
	}
	if err = tx.Commit(); err != nil {
		return fmt.Errorf("chat repo: commit tx: %w", err)
	}

	return nil
}

// insertConversation inserts a new conversation row.
func insertConversation(tx *sql.Tx, conv *chatdomain.Conversation) error {

	_, err := tx.Exec(
		`INSERT INTO chat_conversations (id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		conv.ID,
		conv.Title,
		conv.Settings.Provider,
		conv.Settings.Model,
		conv.Settings.Temperature,
		conv.Settings.MaxTokens,
		conv.Settings.SystemPrompt,
		conv.CreatedAt,
		conv.UpdatedAt,
		boolToInt(conv.IsArchived),
	)
	if err != nil {
		return fmt.Errorf("chat repo: insert conversation: %w", err)
	}
	return nil
}

// upsertConversation inserts or updates a conversation row.
func upsertConversation(tx *sql.Tx, conv *chatdomain.Conversation) error {

	_, err := tx.Exec(
		`INSERT INTO chat_conversations (id, title, provider, model, temperature, max_tokens, system_prompt, created_at, updated_at, is_archived)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		  title = excluded.title,
		  provider = excluded.provider,
		  model = excluded.model,
		  temperature = excluded.temperature,
		  max_tokens = excluded.max_tokens,
		  system_prompt = excluded.system_prompt,
		  created_at = excluded.created_at,
		  updated_at = excluded.updated_at,
		  is_archived = excluded.is_archived`,
		conv.ID,
		conv.Title,
		conv.Settings.Provider,
		conv.Settings.Model,
		conv.Settings.Temperature,
		conv.Settings.MaxTokens,
		conv.Settings.SystemPrompt,
		conv.CreatedAt,
		conv.UpdatedAt,
		boolToInt(conv.IsArchived),
	)
	if err != nil {
		return fmt.Errorf("chat repo: upsert conversation: %w", err)
	}
	return nil
}

// replaceMessages rewrites all messages and blocks for a conversation.
func replaceMessages(tx *sql.Tx, conversationID string, messages []*chatdomain.Message) error {

	if _, err := tx.Exec("DELETE FROM chat_messages WHERE conversation_id = ?", conversationID); err != nil {
		return fmt.Errorf("chat repo: delete messages: %w", err)
	}

	for _, message := range messages {
		if message == nil || message.ID == "" {
			continue
		}
		messageConversationID := message.ConversationID
		if messageConversationID == "" {
			messageConversationID = conversationID
		}

		provider := sql.NullString{}
		model := sql.NullString{}
		tokensIn := sql.NullInt64{}
		tokensOut := sql.NullInt64{}
		tokensTotal := sql.NullInt64{}
		latencyMs := sql.NullInt64{}
		finishReason := sql.NullString{}
		statusCode := sql.NullInt64{}
		errorMessage := sql.NullString{}

		if message.Metadata != nil {
			provider = newNullString(message.Metadata.Provider)
			model = newNullString(message.Metadata.Model)
			tokensIn = sql.NullInt64{Int64: int64(message.Metadata.TokensIn), Valid: true}
			tokensOut = sql.NullInt64{Int64: int64(message.Metadata.TokensOut), Valid: true}
			tokensTotal = sql.NullInt64{Int64: int64(message.Metadata.TokensTotal), Valid: true}
			if !tokensTotal.Valid || tokensTotal.Int64 == 0 {
				tokensTotal = sql.NullInt64{Int64: int64(message.Metadata.TokensIn + message.Metadata.TokensOut), Valid: true}
			}
			latencyMs = sql.NullInt64{Int64: message.Metadata.LatencyMs, Valid: true}
			finishReason = newNullString(message.Metadata.FinishReason)
			statusCode = sql.NullInt64{Int64: int64(message.Metadata.StatusCode), Valid: true}
			errorMessage = newNullString(message.Metadata.ErrorMessage)
		}

		if errorText := findFirstErrorContent(message.Blocks); errorText != "" {
			errorMessage = newNullString(errorText)
		}

		if _, err := tx.Exec(
			`INSERT INTO chat_messages
			 (id, conversation_id, role, timestamp, is_streaming, provider, model, tokens_in, tokens_out, tokens_total, latency_ms, finish_reason, status_code, error_message)
			 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
			message.ID,
			messageConversationID,
			string(message.Role),
			message.Timestamp,
			boolToInt(message.IsStreaming),
			provider,
			model,
			tokensIn,
			tokensOut,
			tokensTotal,
			latencyMs,
			finishReason,
			statusCode,
			errorMessage,
		); err != nil {
			return fmt.Errorf("chat repo: insert message: %w", err)
		}

		for blockIndex, block := range message.Blocks {
			if err := insertMessageBlock(tx, message.ID, blockIndex, block); err != nil {
				return err
			}
		}
	}

	return nil
}

// insertMessageBlock inserts one block row for a message.
func insertMessageBlock(tx *sql.Tx, messageID string, blockIndex int, block chatdomain.Block) error {

	artifactID := sql.NullString{}
	artifactName := sql.NullString{}
	artifactType := sql.NullString{}
	artifactContent := sql.NullString{}
	artifactLanguage := sql.NullString{}
	artifactVersion := sql.NullInt64{}
	artifactCreatedAt := sql.NullInt64{}
	artifactUpdatedAt := sql.NullInt64{}

	if block.Artifact != nil {
		artifactID = newNullString(block.Artifact.ID)
		artifactName = newNullString(block.Artifact.Name)
		artifactType = newNullString(block.Artifact.Type)
		artifactContent = newNullString(block.Artifact.Content)
		artifactLanguage = newNullString(block.Artifact.Language)
		artifactVersion = sql.NullInt64{Int64: int64(block.Artifact.Version), Valid: true}
		artifactCreatedAt = sql.NullInt64{Int64: block.Artifact.CreatedAt, Valid: true}
		artifactUpdatedAt = sql.NullInt64{Int64: block.Artifact.UpdatedAt, Valid: true}
	}

	actionID := sql.NullString{}
	actionToolName := sql.NullString{}
	actionDescription := sql.NullString{}
	actionStatus := sql.NullString{}
	actionResult := sql.NullString{}
	actionStartedAt := sql.NullInt64{}
	actionCompletedAt := sql.NullInt64{}

	if block.Action != nil {
		actionID = newNullString(block.Action.ID)
		actionToolName = newNullString(block.Action.ToolName)
		actionDescription = newNullString(block.Action.Description)
		actionStatus = newNullString(string(block.Action.Status))
		actionResult = newNullString(block.Action.Result)
		actionStartedAt = sql.NullInt64{Int64: block.Action.StartedAt, Valid: true}
		actionCompletedAt = sql.NullInt64{Int64: block.Action.CompletedAt, Valid: true}
	}

	_, err := tx.Exec(
		`INSERT INTO chat_message_blocks
		 (message_id, block_index, block_type, content, language, is_collapsed,
		  artifact_id, artifact_name, artifact_type, artifact_content, artifact_language, artifact_version, artifact_created_at, artifact_updated_at,
		  action_id, action_tool_name, action_description, action_status, action_result, action_started_at, action_completed_at)
		 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
		messageID,
		blockIndex,
		string(block.Type),
		block.Content,
		nullableString(block.Language),
		boolToInt(block.IsCollapsed),
		artifactID,
		artifactName,
		artifactType,
		artifactContent,
		artifactLanguage,
		artifactVersion,
		artifactCreatedAt,
		artifactUpdatedAt,
		actionID,
		actionToolName,
		actionDescription,
		actionStatus,
		actionResult,
		actionStartedAt,
		actionCompletedAt,
	)
	if err != nil {
		return fmt.Errorf("chat repo: insert block: %w", err)
	}

	return nil
}

// loadMessages fetches messages and blocks for one conversation.
func loadMessages(db *sql.DB, conversationID string) ([]*chatdomain.Message, error) {

	rows, err := db.Query(
		`SELECT id, role, timestamp, is_streaming, provider, model, tokens_in, tokens_out, tokens_total, latency_ms, finish_reason, status_code, error_message
		 FROM chat_messages
		 WHERE conversation_id = ?
		 ORDER BY timestamp ASC, id ASC`,
		conversationID,
	)
	if err != nil {
		return nil, fmt.Errorf("chat repo: list messages: %w", err)
	}

	messages := make([]*chatdomain.Message, 0)
	for rows.Next() {
		msg := &chatdomain.Message{ConversationID: conversationID}
		var (
			role        string
			isStreaming int
			provider    sql.NullString
			model       sql.NullString
			tokensIn    sql.NullInt64
			tokensOut   sql.NullInt64
			tokensTotal sql.NullInt64
			latencyMs   sql.NullInt64
			finish      sql.NullString
			statusCode  sql.NullInt64
			errorText   sql.NullString
		)
		if err := rows.Scan(
			&msg.ID,
			&role,
			&msg.Timestamp,
			&isStreaming,
			&provider,
			&model,
			&tokensIn,
			&tokensOut,
			&tokensTotal,
			&latencyMs,
			&finish,
			&statusCode,
			&errorText,
		); err != nil {
			return nil, fmt.Errorf("chat repo: scan message: %w", err)
		}
		msg.Role = chatdomain.Role(role)
		msg.IsStreaming = isStreaming == 1

		meta := &chatdomain.MessageMetadata{}
		if provider.Valid {
			meta.Provider = provider.String
		}
		if model.Valid {
			meta.Model = model.String
		}
		if tokensIn.Valid {
			meta.TokensIn = int(tokensIn.Int64)
		}
		if tokensOut.Valid {
			meta.TokensOut = int(tokensOut.Int64)
		}
		if tokensTotal.Valid {
			meta.TokensTotal = int(tokensTotal.Int64)
		}
		if latencyMs.Valid {
			meta.LatencyMs = latencyMs.Int64
		}
		if finish.Valid {
			meta.FinishReason = finish.String
		}
		if statusCode.Valid {
			meta.StatusCode = int(statusCode.Int64)
		}
		if errorText.Valid {
			meta.ErrorMessage = errorText.String
		}
		if hasMetadata(meta) {
			msg.Metadata = meta
		}

		messages = append(messages, msg)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chat repo: message rows: %w", err)
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("chat repo: close message rows: %w", err)
	}

	for _, msg := range messages {
		blocks, err := loadBlocks(db, msg.ID)
		if err != nil {
			return nil, err
		}
		msg.Blocks = blocks
	}

	return messages, nil
}

// loadBlocks fetches all blocks for one message.
func loadBlocks(db *sql.DB, messageID string) ([]chatdomain.Block, error) {

	rows, err := db.Query(
		`SELECT block_type, content, language, is_collapsed,
		        artifact_id, artifact_name, artifact_type, artifact_content, artifact_language, artifact_version, artifact_created_at, artifact_updated_at,
		        action_id, action_tool_name, action_description, action_status, action_result, action_started_at, action_completed_at
		 FROM chat_message_blocks
		 WHERE message_id = ?
		 ORDER BY block_index ASC`,
		messageID,
	)
	if err != nil {
		return nil, fmt.Errorf("chat repo: list blocks: %w", err)
	}
	defer func() { _ = rows.Close() }()

	blocks := make([]chatdomain.Block, 0)
	for rows.Next() {
		var (
			blockType        string
			content          string
			language         sql.NullString
			isCollapsed      int
			artifactID       sql.NullString
			artifactName     sql.NullString
			artifactType     sql.NullString
			artifactContent  sql.NullString
			artifactLanguage sql.NullString
			artifactVersion  sql.NullInt64
			artifactCreated  sql.NullInt64
			artifactUpdated  sql.NullInt64
			actionID         sql.NullString
			actionToolName   sql.NullString
			actionDesc       sql.NullString
			actionStatus     sql.NullString
			actionResult     sql.NullString
			actionStarted    sql.NullInt64
			actionCompleted  sql.NullInt64
		)
		if err := rows.Scan(
			&blockType,
			&content,
			&language,
			&isCollapsed,
			&artifactID,
			&artifactName,
			&artifactType,
			&artifactContent,
			&artifactLanguage,
			&artifactVersion,
			&artifactCreated,
			&artifactUpdated,
			&actionID,
			&actionToolName,
			&actionDesc,
			&actionStatus,
			&actionResult,
			&actionStarted,
			&actionCompleted,
		); err != nil {
			return nil, fmt.Errorf("chat repo: scan block: %w", err)
		}

		block := chatdomain.Block{
			Type:        chatdomain.BlockType(blockType),
			Content:     content,
			Language:    nullableValue(language),
			IsCollapsed: isCollapsed == 1,
		}
		if artifactID.Valid || artifactName.Valid || artifactType.Valid || artifactContent.Valid {
			block.Artifact = &chatdomain.Artifact{
				ID:        nullableValue(artifactID),
				Name:      nullableValue(artifactName),
				Type:      nullableValue(artifactType),
				Content:   nullableValue(artifactContent),
				Language:  nullableValue(artifactLanguage),
				Version:   int(nullableInt64Value(artifactVersion)),
				CreatedAt: nullableInt64Value(artifactCreated),
				UpdatedAt: nullableInt64Value(artifactUpdated),
			}
		}
		if actionID.Valid || actionToolName.Valid || actionDesc.Valid || actionStatus.Valid || actionResult.Valid {
			block.Action = &chatdomain.ActionExecution{
				ID:          nullableValue(actionID),
				ToolName:    nullableValue(actionToolName),
				Description: nullableValue(actionDesc),
				Status:      chatdomain.ActionStatus(nullableValue(actionStatus)),
				Result:      nullableValue(actionResult),
				StartedAt:   nullableInt64Value(actionStarted),
				CompletedAt: nullableInt64Value(actionCompleted),
				Args:        nil,
			}
		}

		blocks = append(blocks, block)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chat repo: block rows: %w", err)
	}

	return blocks, nil
}

// hasMetadata reports whether metadata carries meaningful values.
func hasMetadata(meta *chatdomain.MessageMetadata) bool {

	if meta == nil {
		return false
	}
	return meta.Provider != "" ||
		meta.Model != "" ||
		meta.TokensIn != 0 ||
		meta.TokensOut != 0 ||
		meta.TokensTotal != 0 ||
		meta.LatencyMs != 0 ||
		meta.FinishReason != "" ||
		meta.StatusCode != 0 ||
		meta.ErrorMessage != ""
}

// findFirstErrorContent extracts the first error block text in a message.
func findFirstErrorContent(blocks []chatdomain.Block) string {

	for _, block := range blocks {
		if block.Type == chatdomain.BlockTypeError && block.Content != "" {
			return block.Content
		}
	}
	return ""
}

// newNullString maps empty strings to NULL.
func newNullString(value string) sql.NullString {

	if value == "" {
		return sql.NullString{}
	}
	return sql.NullString{String: value, Valid: true}
}

// nullableString maps empty strings to NULL for writes.
func nullableString(value string) sql.NullString {

	return newNullString(value)
}

// nullableValue converts a nullable string to a plain value.
func nullableValue(value sql.NullString) string {

	if !value.Valid {
		return ""
	}
	return value.String
}

// nullableInt64Value converts a nullable int64 to a plain value.
func nullableInt64Value(value sql.NullInt64) int64 {

	if !value.Valid {
		return 0
	}
	return value.Int64
}

// boolToInt maps booleans into SQLite-friendly integers.
func boolToInt(value bool) int {

	if value {
		return 1
	}
	return 0
}

```


--| internal/features/ai/chat/app/chat/chat_service.go

```go
// chat_service.go provides chat backend operations.
// internal/core/backend/ai/chat_service.go
package chat

import (
	"context"
	"fmt"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/ports"
)

// ChatService handles chat operations for transport adapters.
type ChatService struct{}

var _ aiinterfaces.ChatInterface = (*ChatService)(nil)

// NewChatService creates a chat backend service.
func NewChatService() *ChatService {

	return &ChatService{}
}

// Chat streams chat completion chunks.
func (s *ChatService) Chat(context.Context, aiinterfaces.ChatRequest) (<-chan aiinterfaces.ChatChunk, error) {

	return nil, fmt.Errorf("backend service: chat not configured")
}

```


--| internal/features/ai/chat/app/chat/events.go

```go
// events.go registers strongly typed chat event signals for frontend transport.
// internal/features/ai/chat/app/chat/events.go
package chat

import coreevents "github.com/MadeByDoug/wls-chatbot/internal/core/events"

// MessageEventPayload represents message creation and stream-start event payloads.
type MessageEventPayload struct {
	ConversationID string   `json:"conversationId"`
	MessageID      string   `json:"messageId"`
	Timestamp      int64    `json:"ts"`
	Message        *Message `json:"message,omitempty"`
}

// StreamChunkEventPayload represents streaming update, error, and completion payloads.
type StreamChunkEventPayload struct {
	ConversationID string           `json:"conversationId"`
	MessageID      string           `json:"messageId"`
	Timestamp      int64            `json:"ts"`
	BlockIndex     int              `json:"blockIndex"`
	Content        string           `json:"content"`
	IsDone         bool             `json:"isDone"`
	Metadata       *MessageMetadata `json:"metadata,omitempty"`
	Error          string           `json:"error,omitempty"`
	StatusCode     int              `json:"statusCode,omitempty"`
}

// ConversationTitleEventPayload represents conversation title update payloads.
type ConversationTitleEventPayload struct {
	ConversationID string `json:"conversationId"`
	Timestamp      int64  `json:"ts"`
	Title          string `json:"title"`
}

var (
	SignalMessageCreated    = coreevents.MustRegister[MessageEventPayload]("chat.message")
	SignalStreamStarted     = coreevents.MustRegister[MessageEventPayload]("chat.stream.start")
	SignalStreamChunk       = coreevents.MustRegister[StreamChunkEventPayload]("chat.stream.chunk")
	SignalStreamError       = coreevents.MustRegister[StreamChunkEventPayload]("chat.stream.error")
	SignalStreamCompleted   = coreevents.MustRegister[StreamChunkEventPayload]("chat.stream.complete")
	SignalConversationTitle = coreevents.MustRegister[ConversationTitleEventPayload]("chat.conversation.title")
)

```


--| internal/features/ai/chat/app/chat/orchestration.go

```go
// orchestration.go orchestrates chat workflows, streaming, and event emission.
// internal/features/chat/app/chat/orchestration.go
package chat

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	coreevents "github.com/MadeByDoug/wls-chatbot/internal/core/events"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
)

// Orchestrator coordinates chat workflows and event emission.
type Orchestrator struct {
	service  *Service
	registry providercore.ProviderRegistry
	secrets  providercore.SecretStore
	emitter  coreevents.Bus
	stream   *streamManager
}

// NewOrchestrator creates a chat orchestrator with required dependencies.
func NewOrchestrator(chatService *Service, registry providercore.ProviderRegistry, secrets providercore.SecretStore, emitter coreevents.Bus) *Orchestrator {

	return &Orchestrator{
		service:  chatService,
		registry: registry,
		secrets:  secrets,
		emitter:  emitter,
		stream:   newStreamManager(),
	}
}

// CreateConversation creates a new conversation with the given settings.
func (o *Orchestrator) CreateConversation(providerName, model string) (*Conversation, error) {

	return o.service.CreateConversation(ConversationSettings{
		Provider: providerName,
		Model:    model,
	})
}

// SetActiveConversation sets the active conversation by ID.
func (o *Orchestrator) SetActiveConversation(id string) {

	o.service.SetActiveConversation(id)
}

// GetActiveConversation returns the currently active conversation.
func (o *Orchestrator) GetActiveConversation() *Conversation {

	id := o.service.ActiveConversationID()
	if id == "" {
		return nil
	}
	return o.service.GetConversation(id)
}

// GetConversation returns a conversation by ID.
func (o *Orchestrator) GetConversation(id string) *Conversation {

	return o.service.GetConversation(id)
}

// ListConversations returns summaries of all conversations.
func (o *Orchestrator) ListConversations() []ConversationSummary {

	return o.service.ListConversations()
}

// ListDeletedConversations returns summaries of archived conversations.
func (o *Orchestrator) ListDeletedConversations() []ConversationSummary {

	return o.service.ListDeletedConversations()
}

// UpdateConversationModel updates the model for a conversation.
func (o *Orchestrator) UpdateConversationModel(conversationID, model string) bool {

	return o.service.UpdateConversationModel(conversationID, model)
}

// UpdateConversationProvider updates the provider for a conversation.
func (o *Orchestrator) UpdateConversationProvider(conversationID, provider string) bool {

	return o.service.UpdateConversationProvider(conversationID, provider)
}

// DeleteConversation archives a conversation by ID.
func (o *Orchestrator) DeleteConversation(id string) bool {

	return o.service.DeleteConversation(id)
}

// RestoreConversation restores an archived conversation by ID.
func (o *Orchestrator) RestoreConversation(id string) bool {

	return o.service.RestoreConversation(id)
}

// PurgeConversation permanently deletes a conversation by ID.
func (o *Orchestrator) PurgeConversation(id string) bool {

	return o.service.PurgeConversation(id)
}

// SendMessage sends a user message and initiates a streaming response.
func (o *Orchestrator) SendMessage(ctx context.Context, conversationID, content string) (*Message, error) {

	conversationID = strings.TrimSpace(conversationID)
	content = strings.TrimSpace(content)
	if conversationID == "" {
		return nil, errors.New("conversation ID required")
	}
	if content == "" {
		return nil, errors.New("message content required")
	}

	conversation := o.service.GetConversation(conversationID)
	if conversation == nil {
		return nil, fmt.Errorf("conversation not found: %s", conversationID)
	}
	if conversation.IsArchived {
		return nil, fmt.Errorf("conversation archived: %s", conversationID)
	}

	userMsg := o.service.AddMessage(conversationID, RoleUser, content)
	if userMsg == nil {
		return nil, fmt.Errorf("failed to persist user message for conversation: %s", conversationID)
	}

	o.maybeAutoTitle(conversationID, userMsg)

	coreevents.Emit(o.emitter, SignalMessageCreated, MessageEventPayload{
		ConversationID: conversationID,
		MessageID:      userMsg.ID,
		Timestamp:      time.Now().UnixMilli(),
		Message:        userMsg,
	})

	conv := o.service.GetConversation(conversationID)
	if conv == nil {
		return userMsg, nil
	}

	providerName := strings.TrimSpace(conv.Settings.Provider)
	if providerName == "" {
		return userMsg, nil
	}

	streamMsg := o.service.CreateStreamingMessage(conversationID, RoleAssistant)
	if streamMsg == nil {
		return userMsg, nil
	}

	coreevents.Emit(o.emitter, SignalStreamStarted, MessageEventPayload{
		ConversationID: conversationID,
		MessageID:      streamMsg.ID,
		Timestamp:      time.Now().UnixMilli(),
		Message:        streamMsg,
	})

	prov, err := o.ensureProviderConfigured(providerName)
	if err != nil {
		o.emitStreamError(conversationID, streamMsg.ID, err)
		metadata := o.buildMetadata(providerName, conv.Settings.Model, "error", nil, time.Now(), err)
		_ = o.service.FinalizeMessage(conversationID, streamMsg.ID, metadata)
		return userMsg, nil
	}

	chatMessages := o.buildProviderMessages(conv, streamMsg.ID)
	opts := providergateway.ChatOptions{
		Model:       conv.Settings.Model,
		Temperature: conv.Settings.Temperature,
		MaxTokens:   conv.Settings.MaxTokens,
		Stream:      true,
	}

	ctx, cancel := context.WithCancel(ctx)
	o.stream.start(conversationID, streamMsg.ID, cancel)

	chunks, err := prov.Chat(ctx, chatMessages, opts)
	if err != nil {
		o.stream.clear(conversationID, streamMsg.ID)
		o.emitStreamError(conversationID, streamMsg.ID, err)
		metadata := o.buildMetadata(providerName, conv.Settings.Model, "error", nil, time.Now(), err)
		_ = o.service.FinalizeMessage(conversationID, streamMsg.ID, metadata)
		return userMsg, nil
	}

	go o.consumeStream(conversationID, streamMsg.ID, providerName, conv.Settings.Model, chunks)

	return userMsg, nil
}

// StopStream cancels the currently running stream.
func (o *Orchestrator) StopStream() {

	o.stream.stop()
}

// emitStreamChunk publishes a streaming chunk event.
func (o *Orchestrator) emitStreamChunk(conversationID, messageID string, blockIndex int, content string) {

	coreevents.Emit(o.emitter, SignalStreamChunk, StreamChunkEventPayload{
		ConversationID: conversationID,
		MessageID:      messageID,
		Timestamp:      time.Now().UnixMilli(),
		BlockIndex:     blockIndex,
		Content:        content,
		IsDone:         false,
	})
}

// emitStreamError publishes a streaming error event.
func (o *Orchestrator) emitStreamError(conversationID, messageID string, err error) {

	coreevents.Emit(o.emitter, SignalStreamError, StreamChunkEventPayload{
		ConversationID: conversationID,
		MessageID:      messageID,
		Timestamp:      time.Now().UnixMilli(),
		BlockIndex:     0,
		Content:        "",
		IsDone:         true,
		Error:          err.Error(),
		StatusCode:     StatusCodeFromErr(err),
	})
}

// emitStreamComplete publishes a stream completion event.
func (o *Orchestrator) emitStreamComplete(conversationID, messageID string, metadata *MessageMetadata) {

	coreevents.Emit(o.emitter, SignalStreamCompleted, StreamChunkEventPayload{
		ConversationID: conversationID,
		MessageID:      messageID,
		Timestamp:      time.Now().UnixMilli(),
		BlockIndex:     0,
		Content:        "",
		IsDone:         true,
		Metadata:       metadata,
	})
}

// ensureProviderConfigured returns a configured provider or an error.
func (o *Orchestrator) ensureProviderConfigured(name string) (providercore.Provider, error) {

	if o.registry == nil {
		return nil, fmt.Errorf("provider registry not configured")
	}
	prov := o.registry.Get(name)
	if prov == nil {
		return nil, fmt.Errorf("provider not found: %s", name)
	}

	fields := prov.CredentialFields()
	credentials := make(providercore.ProviderCredentials)
	for _, field := range fields {
		if !field.Secret {
			continue
		}
		if o.secrets == nil {
			if field.Required {
				return nil, fmt.Errorf("secret store not configured")
			}
			continue
		}
		value, err := o.secrets.GetProviderSecret(name, field.Name)
		if err != nil || strings.TrimSpace(value) == "" {
			if field.Required {
				return nil, fmt.Errorf("missing required credential: %s", field.Name)
			}
			continue
		}
		credentials[field.Name] = value
	}
	if len(credentials) > 0 {
		_ = prov.Configure(providercore.ProviderConfig{Credentials: credentials})
	}
	return prov, nil
}

// buildProviderMessages builds the provider-facing message list.
func (o *Orchestrator) buildProviderMessages(conv *Conversation, streamingMessageID string) []providergateway.ProviderMessage {

	conv.Lock()
	defer conv.Unlock()

	messages := make([]providergateway.ProviderMessage, 0, len(conv.Messages)+1)
	systemPrompt := strings.TrimSpace(conv.Settings.SystemPrompt)
	if systemPrompt != "" {
		messages = append(messages, providergateway.ProviderMessage{
			Role:    providergateway.RoleSystem,
			Content: systemPrompt,
		})
	}

	for _, msg := range conv.Messages {
		if msg.ID == streamingMessageID && len(msg.Blocks) == 0 {
			continue
		}
		content := textFromBlocks(msg.Blocks)
		if strings.TrimSpace(content) == "" {
			continue
		}
		messages = append(messages, providergateway.ProviderMessage{
			Role:    providergateway.Role(msg.Role),
			Content: content,
		})
	}
	return messages
}

// textFromBlocks builds a text-only content string from message blocks.
func textFromBlocks(blocks []Block) string {

	if len(blocks) == 0 {
		return ""
	}

	var builder strings.Builder
	for _, block := range blocks {
		if block.Type == BlockTypeText {
			builder.WriteString(block.Content)
		}
	}
	return builder.String()
}

// consumeStream handles incoming provider chunks and emits events.
func (o *Orchestrator) consumeStream(conversationID, messageID, providerName, fallbackModel string, chunks <-chan providergateway.Chunk) {

	defer o.stream.clear(conversationID, messageID)

	start := time.Now()
	var (
		finishReason string
		usage        *providergateway.UsageStats
		model        string
	)

	for chunk := range chunks {
		if chunk.Error != nil {
			if isContextCanceled(chunk.Error) {
				metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), "cancelled", usage, start, nil)
				_ = o.service.FinalizeMessage(conversationID, messageID, metadata)
				o.emitStreamComplete(conversationID, messageID, metadata)
			} else {
				o.emitStreamError(conversationID, messageID, chunk.Error)
				metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), "error", usage, start, chunk.Error)
				_ = o.service.FinalizeMessage(conversationID, messageID, metadata)
			}
			return
		}

		if chunk.Content != "" {
			if !o.service.AppendToMessage(conversationID, messageID, 0, chunk.Content) {
				err := fmt.Errorf("failed to persist stream chunk")
				o.emitStreamError(conversationID, messageID, err)
				metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), "error", usage, start, err)
				_ = o.service.FinalizeMessage(conversationID, messageID, metadata)
				return
			}
			o.emitStreamChunk(conversationID, messageID, 0, chunk.Content)
		}
		if chunk.Model != "" {
			model = chunk.Model
		}
		if chunk.Usage != nil {
			usage = chunk.Usage
		}
		if chunk.FinishReason != "" {
			finishReason = chunk.FinishReason
		}
	}

	if finishReason == "" && o.stream.wasCancelled(conversationID, messageID) {
		finishReason = "cancelled"
	}

	metadata := o.buildMetadata(providerName, chooseModel(model, fallbackModel), finishReason, usage, start, nil)
	if !o.service.FinalizeMessage(conversationID, messageID, metadata) {
		err := fmt.Errorf("failed to persist stream completion")
		o.emitStreamError(conversationID, messageID, err)
		return
	}
	o.emitStreamComplete(conversationID, messageID, metadata)
}

// buildMetadata builds message metadata from provider results.
func (o *Orchestrator) buildMetadata(
	providerName,
	model,
	finishReason string,
	usage *providergateway.UsageStats,
	start time.Time,
	err error,
) *MessageMetadata {

	meta := &MessageMetadata{
		Provider:     providerName,
		Model:        model,
		FinishReason: finishReason,
		LatencyMs:    time.Since(start).Milliseconds(),
	}
	if meta.FinishReason == "" {
		meta.FinishReason = "stop"
	}
	if usage != nil {
		meta.TokensIn = usage.PromptTokens
		meta.TokensOut = usage.CompletionTokens
		meta.TokensTotal = usage.TotalTokens
		if meta.TokensTotal == 0 {
			meta.TokensTotal = usage.PromptTokens + usage.CompletionTokens
		}
	}
	if err != nil {
		meta.StatusCode = StatusCodeFromErr(err)
		meta.ErrorMessage = err.Error()
	}
	return meta
}

// maybeAutoTitle updates the conversation title on the first user message.
func (o *Orchestrator) maybeAutoTitle(conversationID string, message *Message) {

	if message.Role != RoleUser {
		return
	}
	conv := o.service.GetConversation(conversationID)
	if conv == nil {
		return
	}
	conv.Lock()
	messageCount := len(conv.Messages)
	conv.Unlock()
	if messageCount != 1 {
		return
	}
	if len(message.Blocks) == 0 {
		return
	}
	content := message.Blocks[0].Content
	if content == "" {
		return
	}
	if len(content) > 50 {
		content = content[:50] + "..."
	}
	if o.service.SetConversationTitle(conversationID, content) {
		coreevents.Emit(o.emitter, SignalConversationTitle, ConversationTitleEventPayload{
			ConversationID: conversationID,
			Timestamp:      time.Now().UnixMilli(),
			Title:          content,
		})
	}
}

// chooseModel selects the best available model name.
func chooseModel(primary, fallback string) string {

	if strings.TrimSpace(primary) != "" {
		return primary
	}
	return fallback
}

// isContextCanceled checks for context cancellation errors.
func isContextCanceled(err error) bool {

	return errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded)
}

```


--| internal/features/ai/chat/app/chat/service.go

```go
// service.go manages chat conversation lifecycle and message state mutations.
// internal/features/chat/app/chat/service.go
package chat

import (
	"sync"
	"time"
)

// Service manages conversations and messages.
type Service struct {
	repo Repository

	mu           sync.RWMutex
	activeConvID string
}

// NewService creates a new chat service with the provided repository.
func NewService(repo Repository) *Service {

	return &Service{
		repo: repo,
	}
}

// CreateConversation creates a new conversation with the given settings.
func (s *Service) CreateConversation(settings ConversationSettings) (*Conversation, error) {

	conv := NewConversation(settings)
	if err := s.repo.Create(conv); err != nil {
		return nil, err
	}
	s.SetActiveConversation(conv.ID)
	return conv, nil
}

// SetActiveConversation marks a conversation as active.
func (s *Service) SetActiveConversation(id string) {

	s.mu.Lock()
	s.activeConvID = id
	s.mu.Unlock()
}

// ActiveConversationID returns the active conversation ID.
func (s *Service) ActiveConversationID() string {

	s.mu.RLock()
	id := s.activeConvID
	s.mu.RUnlock()
	return id
}

// GetConversation retrieves a conversation by ID.
func (s *Service) GetConversation(id string) *Conversation {

	conv, err := s.repo.Get(id)
	if err != nil {
		return nil
	}
	if conv == nil {
		return nil
	}
	return conv.Snapshot()
}

// ListConversations returns summaries of all conversations, sorted by updatedAt.
func (s *Service) ListConversations() []ConversationSummary {

	return s.listConversationsByArchivedStatus(false)
}

// ListDeletedConversations returns summaries for archived conversations.
func (s *Service) ListDeletedConversations() []ConversationSummary {

	return s.listConversationsByArchivedStatus(true)
}

// listConversationsByArchivedStatus returns summaries filtered by archive status.
func (s *Service) listConversationsByArchivedStatus(archived bool) []ConversationSummary {

	convs, err := s.repo.List()
	if err != nil {
		return nil
	}
	summaries := make([]ConversationSummary, 0, len(convs))
	for _, conv := range convs {
		if conv.CheckIsArchived() == archived {
			summaries = append(summaries, conv.GetSummary())
		}
	}

	// Sort by updatedAt descending
	for i := 0; i < len(summaries)-1; i++ {
		for j := i + 1; j < len(summaries); j++ {
			if summaries[j].UpdatedAt > summaries[i].UpdatedAt {
				summaries[i], summaries[j] = summaries[j], summaries[i]
			}
		}
	}

	return summaries
}

// AddMessage adds a message to a conversation.
func (s *Service) AddMessage(conversationID string, role Role, content string) *Message {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return nil
	}
	if conv == nil || conv.CheckIsArchived() {
		return nil
	}

	msg := NewMessage(conversationID, role, content)
	conv.AddMessage(msg)
	if err := s.repo.Update(conv); err != nil {
		return nil
	}
	return msg
}

// SetConversationTitle updates the title for a conversation.
func (s *Service) SetConversationTitle(conversationID, title string) bool {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return false
	}
	if conv == nil {
		return false
	}

	conv.Lock()
	conv.Title = title
	conv.UpdatedAt = time.Now().UnixMilli()
	conv.Unlock()

	return s.repo.Update(conv) == nil
}

// CreateStreamingMessage creates a new streaming message placeholder.
func (s *Service) CreateStreamingMessage(conversationID string, role Role) *Message {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return nil
	}
	if conv == nil || conv.CheckIsArchived() {
		return nil
	}

	msg := NewStreamingMessage(conversationID, role)
	conv.AddMessage(msg)
	if err := s.repo.Update(conv); err != nil {
		return nil
	}
	return msg
}

// AppendToMessage appends content to a streaming message.
func (s *Service) AppendToMessage(conversationID, messageID string, blockIndex int, content string) bool {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return false
	}
	if conv == nil {
		return false
	}

	conv.Lock()
	defer conv.Unlock()

	updated := false
	for _, msg := range conv.Messages {
		if msg.ID == messageID {
			// Extend blocks if needed
			for len(msg.Blocks) <= blockIndex {
				msg.Blocks = append(msg.Blocks, Block{Type: BlockTypeText})
			}
			msg.Blocks[blockIndex].Content += content
			updated = true
			break
		}
	}

	if updated {
		if err := s.repo.Update(conv); err != nil {
			return false
		}
	}

	return updated
}

// FinalizeMessage marks a streaming message as complete.
func (s *Service) FinalizeMessage(conversationID, messageID string, metadata *MessageMetadata) bool {

	conv, err := s.repo.Get(conversationID)
	if err != nil {
		return false
	}
	if conv == nil {
		return false
	}

	conv.Lock()
	defer conv.Unlock()

	updated := false
	for _, msg := range conv.Messages {
		if msg.ID == messageID {
			msg.IsStreaming = false
			msg.Metadata = metadata
			updated = true
			break
		}
	}

	if updated {
		if err := s.repo.Update(conv); err != nil {
			return false
		}
	}

	return updated
}

// DeleteConversation moves a conversation into the recycle bin.
func (s *Service) DeleteConversation(id string) bool {

	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv == nil || conv.CheckIsArchived() {
		return false
	}

	conv.Lock()
	conv.IsArchived = true
	conv.UpdatedAt = time.Now().UnixMilli()
	conv.Unlock()

	if s.ActiveConversationID() == id {
		s.SetActiveConversation("")
	}

	return s.repo.Update(conv) == nil
}

// RestoreConversation restores a conversation from the recycle bin.
func (s *Service) RestoreConversation(id string) bool {

	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv == nil || !conv.CheckIsArchived() {
		return false
	}

	conv.Lock()
	conv.IsArchived = false
	conv.UpdatedAt = time.Now().UnixMilli()
	conv.Unlock()

	return s.repo.Update(conv) == nil
}

// PurgeConversation permanently deletes a conversation.
func (s *Service) PurgeConversation(id string) bool {

	if s.ActiveConversationID() == id {
		s.SetActiveConversation("")
	}

	err := s.repo.Delete(id)
	return err == nil
}

// UpdateConversationModel updates the model for a conversation.
func (s *Service) UpdateConversationModel(id, model string) bool {

	if model == "" {
		return false
	}
	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv != nil && !conv.CheckIsArchived() {
		conv.Lock()
		defer conv.Unlock()
		conv.Settings.Model = model
		conv.UpdatedAt = time.Now().UnixMilli()
		return s.repo.Update(conv) == nil
	}
	return false
}

// UpdateConversationProvider updates the provider for a conversation.
func (s *Service) UpdateConversationProvider(id, provider string) bool {

	if provider == "" {
		return false
	}
	conv, err := s.repo.Get(id)
	if err != nil {
		return false
	}
	if conv != nil && !conv.CheckIsArchived() {
		conv.Lock()
		defer conv.Unlock()
		conv.Settings.Provider = provider
		conv.UpdatedAt = time.Now().UnixMilli()
		return s.repo.Update(conv) == nil
	}
	return false
}

```


--| internal/features/ai/chat/app/chat/stream_manager.go

```go
// stream_manager.go manages cancellation state for streaming chat responses.
// internal/features/chat/app/chat/stream_manager.go
package chat

import (
	"context"
	"sync"
	"time"
)

// streamInfo captures metadata about the active stream.
type streamInfo struct {
	conversationID string
	messageID      string
	startedAt      time.Time
	cancelled      bool
}

// streamManager controls the lifecycle of a single active stream.
type streamManager struct {
	mu     sync.Mutex
	cancel context.CancelFunc
	info   *streamInfo
}

// newStreamManager constructs a stream manager.
func newStreamManager() *streamManager {

	return &streamManager{}
}

// start records the active stream and stores its cancel function.
func (s *streamManager) start(conversationID, messageID string, cancel context.CancelFunc) {

	s.mu.Lock()
	defer s.mu.Unlock()
	if s.cancel != nil {
		s.cancel()
	}
	s.cancel = cancel
	s.info = &streamInfo{
		conversationID: conversationID,
		messageID:      messageID,
		startedAt:      time.Now(),
	}
}

// stop cancels the active stream if present.
func (s *streamManager) stop() {

	s.mu.Lock()
	if s.info != nil {
		s.info.cancelled = true
	}
	cancel := s.cancel
	s.mu.Unlock()
	if cancel != nil {
		cancel()
	}
}

// wasCancelled reports whether the active stream was cancelled.
func (s *streamManager) wasCancelled(conversationID, messageID string) bool {

	s.mu.Lock()
	defer s.mu.Unlock()
	if s.info == nil {
		return false
	}
	if s.info.conversationID != conversationID || s.info.messageID != messageID {
		return false
	}
	return s.info.cancelled
}

// clear removes the active stream if it matches the given identifiers.
func (s *streamManager) clear(conversationID, messageID string) {

	var cancel context.CancelFunc
	s.mu.Lock()
	if s.info != nil && s.info.conversationID == conversationID && s.info.messageID == messageID {
		cancel = s.cancel
		s.cancel = nil
		s.info = nil
	}
	s.mu.Unlock()
	if cancel != nil {
		cancel()
	}
}

```


--| internal/features/ai/chat/app/chat/types.go

```go
// types.go re-exports chat domain and port contracts into the app boundary.
// internal/features/chat/app/chat/types.go
package chat

import (
	chatdomain "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/domain"
	chatports "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/ports"
)

type Conversation = chatdomain.Conversation
type ConversationSettings = chatdomain.ConversationSettings
type ConversationSummary = chatdomain.ConversationSummary
type Message = chatdomain.Message
type MessageMetadata = chatdomain.MessageMetadata
type Role = chatdomain.Role
type Block = chatdomain.Block
type BlockType = chatdomain.BlockType

type Repository = chatports.ChatRepository

const (
	RoleUser      = chatdomain.RoleUser
	RoleAssistant = chatdomain.RoleAssistant
	RoleSystem    = chatdomain.RoleSystem
	RoleTool      = chatdomain.RoleTool
)

const (
	BlockTypeText     = chatdomain.BlockTypeText
	BlockTypeCode     = chatdomain.BlockTypeCode
	BlockTypeArtifact = chatdomain.BlockTypeArtifact
	BlockTypeThinking = chatdomain.BlockTypeThinking
	BlockTypeAction   = chatdomain.BlockTypeAction
	BlockTypeError    = chatdomain.BlockTypeError
	BlockTypeImage    = chatdomain.BlockTypeImage
)

// NewConversation builds a new conversation from domain settings.
func NewConversation(settings ConversationSettings) *Conversation {

	return chatdomain.NewConversation(settings)
}

// NewMessage builds a new domain message.
func NewMessage(conversationID string, role Role, content string) *Message {

	return chatdomain.NewMessage(conversationID, role, content)
}

// NewStreamingMessage builds a streaming placeholder message.
func NewStreamingMessage(conversationID string, role Role) *Message {

	return chatdomain.NewStreamingMessage(conversationID, role)
}

// StatusCodeFromErr extracts HTTP-like error status codes when available.
func StatusCodeFromErr(err error) int {

	return chatdomain.StatusCodeFromErr(err)
}

```


--| internal/features/ai/chat/domain/conversation.go

```go
// conversation.go defines chat conversation entities and behavior.
// internal/features/chat/domain/conversation.go
package domain

import (
	"crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"sync"
	"time"
)

// ConversationSettings holds the configuration for a conversation.
type ConversationSettings struct {
	Provider     string  `json:"provider"`
	Model        string  `json:"model"`
	Temperature  float64 `json:"temperature,omitempty"`
	MaxTokens    int     `json:"maxTokens,omitempty"`
	SystemPrompt string  `json:"systemPrompt,omitempty"`
}

// Conversation represents a chat conversation.
type Conversation struct {
	mu         sync.RWMutex
	ID         string               `json:"id"`
	Title      string               `json:"title"`
	Messages   []*Message           `json:"messages"`
	Settings   ConversationSettings `json:"settings"`
	CreatedAt  int64                `json:"createdAt"`
	UpdatedAt  int64                `json:"updatedAt"`
	IsArchived bool                 `json:"isArchived"`
}

// ConversationSummary is a lightweight representation for listing.
type ConversationSummary struct {
	ID           string `json:"id"`
	Title        string `json:"title"`
	LastMessage  string `json:"lastMessage,omitempty"`
	MessageCount int    `json:"messageCount"`
	UpdatedAt    int64  `json:"updatedAt"`
}

// NewConversation creates a new conversation with the given settings.
func NewConversation(settings ConversationSettings) *Conversation {

	now := time.Now().UnixMilli()
	return &Conversation{
		ID:        generateID(),
		Title:     "New conversation",
		Messages:  []*Message{},
		Settings:  settings,
		CreatedAt: now,
		UpdatedAt: now,
	}
}

// Lock locks the conversation for writes.
func (c *Conversation) Lock() {

	c.mu.Lock()
}

// Unlock releases the conversation write lock.
func (c *Conversation) Unlock() {

	c.mu.Unlock()
}

// CheckIsArchived returns the archived status safely.
func (c *Conversation) CheckIsArchived() bool {

	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.IsArchived
}

// AddMessage adds a message to the conversation.
func (c *Conversation) AddMessage(msg *Message) {

	c.mu.Lock()
	defer c.mu.Unlock()

	c.Messages = append(c.Messages, msg)
	c.UpdatedAt = time.Now().UnixMilli()
}

// GetSummary returns a lightweight summary of the conversation.
func (c *Conversation) GetSummary() ConversationSummary {

	c.mu.RLock()
	defer c.mu.RUnlock()

	summary := ConversationSummary{
		ID:           c.ID,
		Title:        c.Title,
		MessageCount: len(c.Messages),
		UpdatedAt:    c.UpdatedAt,
	}

	if len(c.Messages) > 0 {
		lastMsg := c.Messages[len(c.Messages)-1]
		if len(lastMsg.Blocks) > 0 {
			content := lastMsg.Blocks[0].Content
			if len(content) > 100 {
				summary.LastMessage = content[:100]
			} else {
				summary.LastMessage = content
			}
		}
	}

	return summary
}

// Snapshot returns a deep copy of the conversation for safe reads.
func (c *Conversation) Snapshot() *Conversation {

	if c == nil {
		return nil
	}

	c.mu.RLock()
	defer c.mu.RUnlock()

	return &Conversation{
		ID:         c.ID,
		Title:      c.Title,
		Messages:   cloneMessages(c.Messages),
		Settings:   c.Settings,
		CreatedAt:  c.CreatedAt,
		UpdatedAt:  c.UpdatedAt,
		IsArchived: c.IsArchived,
	}
}

// generateID creates a random ID.
func generateID() string {

	b := make([]byte, 16)
	read, err := rand.Read(b)
	if err != nil || read != len(b) {
		now := time.Now().UnixNano()
		binary.LittleEndian.PutUint64(b[:8], uint64(now))
		binary.LittleEndian.PutUint64(b[8:], uint64(now>>1))
	}
	return hex.EncodeToString(b)
}

// cloneMessages deep copies message pointers for snapshots.
func cloneMessages(messages []*Message) []*Message {

	if messages == nil {
		return nil
	}

	cloned := make([]*Message, len(messages))
	for i, message := range messages {
		cloned[i] = cloneMessage(message)
	}
	return cloned
}

// cloneMessage deep copies a message for snapshots.
func cloneMessage(message *Message) *Message {

	if message == nil {
		return nil
	}

	return &Message{
		ID:             message.ID,
		ConversationID: message.ConversationID,
		Role:           message.Role,
		Blocks:         cloneBlocks(message.Blocks),
		Timestamp:      message.Timestamp,
		IsStreaming:    message.IsStreaming,
		Metadata:       cloneMetadata(message.Metadata),
	}
}

// cloneBlocks deep copies blocks for snapshots.
func cloneBlocks(blocks []Block) []Block {

	if blocks == nil {
		return nil
	}

	cloned := make([]Block, len(blocks))
	for i, block := range blocks {
		cloned[i] = Block{
			Type:        block.Type,
			Content:     block.Content,
			Language:    block.Language,
			Artifact:    cloneArtifact(block.Artifact),
			Action:      cloneAction(block.Action),
			IsCollapsed: block.IsCollapsed,
		}
	}
	return cloned
}

// cloneArtifact deep copies an artifact for snapshots.
func cloneArtifact(artifact *Artifact) *Artifact {

	if artifact == nil {
		return nil
	}

	clone := *artifact
	return &clone
}

// cloneAction deep copies an action execution for snapshots.
func cloneAction(action *ActionExecution) *ActionExecution {

	if action == nil {
		return nil
	}

	clone := *action
	if action.Args != nil {
		clone.Args = make(map[string]interface{}, len(action.Args))
		for key, value := range action.Args {
			clone.Args[key] = value
		}
	}
	return &clone
}

// cloneMetadata deep copies message metadata for snapshots.
func cloneMetadata(metadata *MessageMetadata) *MessageMetadata {

	if metadata == nil {
		return nil
	}

	clone := *metadata
	return &clone
}

```


--| internal/features/ai/chat/domain/message.go

```go
// message.go defines chat message entities and content blocks.
// internal/features/chat/domain/message.go
package domain

import (
	"time"
)

// Role represents the sender of a message.
type Role string

const (
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleTool      Role = "tool"
)

// BlockType represents the type of content in a message block.
type BlockType string

const (
	BlockTypeText     BlockType = "text"
	BlockTypeCode     BlockType = "code"
	BlockTypeArtifact BlockType = "artifact"
	BlockTypeThinking BlockType = "thinking"
	BlockTypeAction   BlockType = "action"
	BlockTypeError    BlockType = "error"
	BlockTypeImage    BlockType = "image"
)

// ActionStatus represents the status of a tool action.
type ActionStatus string

const (
	ActionStatusPending   ActionStatus = "pending"
	ActionStatusApproved  ActionStatus = "approved"
	ActionStatusRejected  ActionStatus = "rejected"
	ActionStatusRunning   ActionStatus = "running"
	ActionStatusCompleted ActionStatus = "completed"
	ActionStatusFailed    ActionStatus = "failed"
)

// ActionExecution represents a tool call and its execution state.
type ActionExecution struct {
	ID          string                 `json:"id"`
	ToolName    string                 `json:"toolName"`
	Description string                 `json:"description"`
	Args        map[string]interface{} `json:"args"`
	Status      ActionStatus           `json:"status"`
	Result      string                 `json:"result,omitempty"`
	StartedAt   int64                  `json:"startedAt,omitempty"`
	CompletedAt int64                  `json:"completedAt,omitempty"`
}

// Artifact represents a generated document, code file, or other content.
type Artifact struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Type      string `json:"type"` // document, code, diagram, image, data
	Content   string `json:"content"`
	Language  string `json:"language,omitempty"`
	Version   int    `json:"version"`
	CreatedAt int64  `json:"createdAt"`
	UpdatedAt int64  `json:"updatedAt"`
}

// Block represents a content block within a message.
type Block struct {
	Type        BlockType        `json:"type"`
	Content     string           `json:"content"`
	Language    string           `json:"language,omitempty"`
	Artifact    *Artifact        `json:"artifact,omitempty"`
	Action      *ActionExecution `json:"action,omitempty"`
	IsCollapsed bool             `json:"isCollapsed,omitempty"`
}

// Message represents a single message in a conversation.
type Message struct {
	ID             string           `json:"id"`
	ConversationID string           `json:"conversationId"`
	Role           Role             `json:"role"`
	Blocks         []Block          `json:"blocks"`
	Timestamp      int64            `json:"timestamp"`
	IsStreaming    bool             `json:"isStreaming,omitempty"`
	Metadata       *MessageMetadata `json:"metadata,omitempty"`
}

// NewMessage creates a new message with the given role and content.
func NewMessage(conversationID string, role Role, content string) *Message {

	return &Message{
		ID:             generateID(),
		ConversationID: conversationID,
		Role:           role,
		Blocks: []Block{
			{
				Type:    BlockTypeText,
				Content: content,
			},
		},
		Timestamp: time.Now().UnixMilli(),
	}
}

// NewStreamingMessage creates a new message that will receive streaming content.
func NewStreamingMessage(conversationID string, role Role) *Message {

	return &Message{
		ID:             generateID(),
		ConversationID: conversationID,
		Role:           role,
		Blocks:         []Block{},
		Timestamp:      time.Now().UnixMilli(),
		IsStreaming:    true,
	}
}

```


--| internal/features/ai/chat/domain/metadata.go

```go
// metadata.go defines metadata captured from provider responses.
// internal/features/chat/domain/metadata.go
package domain

// MessageMetadata contains information about message generation.
type MessageMetadata struct {
	Provider     string `json:"provider,omitempty"`
	Model        string `json:"model,omitempty"`
	TokensIn     int    `json:"tokensIn,omitempty"`
	TokensOut    int    `json:"tokensOut,omitempty"`
	TokensTotal  int    `json:"tokensTotal,omitempty"`
	LatencyMs    int64  `json:"latencyMs,omitempty"`
	FinishReason string `json:"finishReason,omitempty"`
	StatusCode   int    `json:"statusCode,omitempty"`
	ErrorMessage string `json:"errorMessage,omitempty"`
}

```


--| internal/features/ai/chat/domain/status.go

```go
// status.go normalizes status codes from errors.
// internal/features/chat/domain/status.go
package domain

import "errors"

// StatusCoder is an interface for errors that have a status code.
type StatusCoder interface {
	StatusCode() int
}

// StatusCodeFromErr extracts a status code from an error if available.
func StatusCodeFromErr(err error) int {

	var coder StatusCoder
	if errors.As(err, &coder) {
		return coder.StatusCode()
	}
	return 0
}

```


--| internal/features/ai/chat/ports/chat.go

```go
// chat.go defines chat completion transport contracts.
// internal/core/interfaces/ai/chat.go
package ports

import "context"

// ChatInterface defines chat completion capabilities shared across transports.
type ChatInterface interface {
	Chat(ctx context.Context, request ChatRequest) (<-chan ChatChunk, error)
}

// ChatRequest contains inputs for a chat completion request.
type ChatRequest struct {
	ProviderName string        `json:"providerName"`
	ModelName    string        `json:"modelName"`
	Messages     []ChatMessage `json:"messages"`
	Options      ChatOptions   `json:"options,omitempty"`
}

// ChatMessage represents a single chat message payload.
type ChatMessage struct {
	Role    ChatRole `json:"role"`
	Content string   `json:"content"`
}

// ChatRole represents the sender role for chat messages.
type ChatRole string

const (
	ChatRoleUser      ChatRole = "user"
	ChatRoleAssistant ChatRole = "assistant"
	ChatRoleSystem    ChatRole = "system"
	ChatRoleTool      ChatRole = "tool"
)

// ChatOptions configures chat request behavior.
type ChatOptions struct {
	Temperature float64    `json:"temperature,omitempty"`
	MaxTokens   int        `json:"maxTokens,omitempty"`
	Stream      bool       `json:"stream,omitempty"`
	StopWords   []string   `json:"stopWords,omitempty"`
	Tools       []ChatTool `json:"tools,omitempty"`
}

// ChatTool describes a tool available for model tool-calling.
type ChatTool struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description,omitempty"`
	InputSchema map[string]interface{} `json:"inputSchema,omitempty"`
}

// ChatChunk represents one streamed chat response chunk.
type ChatChunk struct {
	Content      string         `json:"content,omitempty"`
	Model        string         `json:"model,omitempty"`
	ToolCalls    []ChatToolCall `json:"toolCalls,omitempty"`
	FinishReason string         `json:"finishReason,omitempty"`
	Usage        *ChatUsage     `json:"usage,omitempty"`
	Error        string         `json:"error,omitempty"`
}

// ChatToolCall represents a model-requested tool invocation.
type ChatToolCall struct {
	ID        string                 `json:"id"`
	Name      string                 `json:"name"`
	Arguments map[string]interface{} `json:"arguments,omitempty"`
}

// ChatUsage contains token accounting for a chat request.
type ChatUsage struct {
	InputTokens  int `json:"inputTokens,omitempty"`
	OutputTokens int `json:"outputTokens,omitempty"`
	TotalTokens  int `json:"totalTokens,omitempty"`
}

```


--| internal/features/ai/chat/ports/chat_repository.go

```go
// chat_repository.go defines chat persistence ports.
// internal/features/chat/ports/chat_repository.go
package ports

import chatdomain "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/domain"

// ChatRepository defines storage operations for conversations.
type ChatRepository interface {
	Create(conv *chatdomain.Conversation) error
	Get(id string) (*chatdomain.Conversation, error)
	List() ([]*chatdomain.Conversation, error)
	Update(conv *chatdomain.Conversation) error
	Delete(id string) error
}

```


--| internal/features/ai/image/image_service.go

```go
// image_service.go provides image generation and editing backend operations.
// internal/core/backend/ai/image_service.go
package ai

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"strings"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/image/ports"
	provider "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/provider"
)

// ImageProviderOperations defines image operations required by the image backend service.
type ImageProviderOperations interface {
	GenerateImage(ctx context.Context, name string, options provider.ImageGenerationOptions) (*provider.ImageResult, error)
	EditImage(ctx context.Context, name string, options provider.ImageEditOptions) (*provider.ImageResult, error)
}

// ImageService handles image generation and editing operations for transport adapters.
type ImageService struct {
	providers ImageProviderOperations
}

var _ aiinterfaces.ImageInterface = (*ImageService)(nil)

// NewImageService creates an image backend service from provider dependencies.
func NewImageService(providers ImageProviderOperations) *ImageService {

	return &ImageService{providers: providers}
}

// GenerateImage produces an image using a configured provider.
func (s *ImageService) GenerateImage(ctx context.Context, request aiinterfaces.GenerateImageRequest) (aiinterfaces.ImageBinaryResult, error) {

	if s.providers == nil {
		return aiinterfaces.ImageBinaryResult{}, fmt.Errorf("backend service: providers not configured")
	}

	result, err := s.providers.GenerateImage(ctx, request.ProviderName, provider.ImageGenerationOptions{
		Model:          request.ModelName,
		Prompt:         request.Prompt,
		N:              maxCount(request.N),
		Size:           request.Size,
		Quality:        request.Quality,
		Style:          request.Style,
		ResponseFormat: request.ResponseFormat,
		User:           request.User,
	})
	if err != nil {
		return aiinterfaces.ImageBinaryResult{}, err
	}

	return firstImageBinaryResult(ctx, result)
}

// EditImage edits an image using a configured provider.
func (s *ImageService) EditImage(ctx context.Context, request aiinterfaces.EditImageRequest) (aiinterfaces.ImageBinaryResult, error) {

	if s.providers == nil {
		return aiinterfaces.ImageBinaryResult{}, fmt.Errorf("backend service: providers not configured")
	}

	result, err := s.providers.EditImage(ctx, request.ProviderName, provider.ImageEditOptions{
		Model:  request.ModelName,
		Image:  request.ImagePath,
		Mask:   request.MaskPath,
		Prompt: request.Prompt,
		N:      maxCount(request.N),
		Size:   request.Size,
	})
	if err != nil {
		return aiinterfaces.ImageBinaryResult{}, err
	}

	return firstImageBinaryResult(ctx, result)
}

// maxCount normalizes optional image count values.
func maxCount(count int) int {

	if count <= 0 {
		return 1
	}
	return count
}

// firstImageBinaryResult extracts and resolves the first image payload.
func firstImageBinaryResult(ctx context.Context, result *provider.ImageResult) (aiinterfaces.ImageBinaryResult, error) {

	if result == nil || len(result.Data) == 0 {
		return aiinterfaces.ImageBinaryResult{}, fmt.Errorf("no image data returned")
	}

	imageData := result.Data[0]
	bytes, err := resolveImageBytes(ctx, imageData)
	if err != nil {
		return aiinterfaces.ImageBinaryResult{}, err
	}

	return aiinterfaces.ImageBinaryResult{
		Bytes:         bytes,
		RevisedPrompt: imageData.RevisedPrompt,
	}, nil
}

// resolveImageBytes resolves either base64 or URL image payloads into bytes.
func resolveImageBytes(ctx context.Context, imageData provider.ImageData) ([]byte, error) {

	if ctx == nil {
		ctx = context.Background()
	}

	if strings.TrimSpace(imageData.B64JSON) != "" {
		bytes, err := base64.StdEncoding.DecodeString(imageData.B64JSON)
		if err != nil {
			return nil, fmt.Errorf("failed to decode base64 image: %w", err)
		}
		return bytes, nil
	}

	if strings.TrimSpace(imageData.URL) != "" {
		request, err := http.NewRequestWithContext(ctx, http.MethodGet, imageData.URL, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to create image request: %w", err)
		}
		response, err := http.DefaultClient.Do(request)
		if err != nil {
			return nil, fmt.Errorf("failed to download image from URL: %w", err)
		}
		defer func() { _ = response.Body.Close() }()

		if response.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("failed to download image, status: %d", response.StatusCode)
		}

		bytes, err := io.ReadAll(response.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read image body: %w", err)
		}
		return bytes, nil
	}

	return nil, fmt.Errorf("provider returned neither base64 nor URL for image")
}

```


--| internal/features/ai/image/ports/image.go

```go
// image.go defines image generation and editing transport contracts.
// internal/core/interfaces/ai/image.go
package ai

import (
	"context"
)

// ImageInterface defines image generation capabilities shared across transports.
type ImageInterface interface {
	GenerateImage(ctx context.Context, request GenerateImageRequest) (ImageBinaryResult, error)
	EditImage(ctx context.Context, request EditImageRequest) (ImageBinaryResult, error)
}

// GenerateImageRequest contains image generation inputs.
type GenerateImageRequest struct {
	ProviderName   string `json:"providerName"`
	ModelName      string `json:"modelName,omitempty"`
	Prompt         string `json:"prompt"`
	N              int    `json:"n,omitempty"`
	Size           string `json:"size,omitempty"`
	Quality        string `json:"quality,omitempty"`
	Style          string `json:"style,omitempty"`
	ResponseFormat string `json:"responseFormat,omitempty"`
	User           string `json:"user,omitempty"`
}

// EditImageRequest contains image edit inputs.
type EditImageRequest struct {
	ProviderName string `json:"providerName"`
	ModelName    string `json:"modelName,omitempty"`
	Prompt       string `json:"prompt"`
	ImagePath    string `json:"imagePath"`
	MaskPath     string `json:"maskPath,omitempty"`
	N            int    `json:"n,omitempty"`
	Size         string `json:"size,omitempty"`
}

// ImageBinaryResult contains binary image output metadata.
type ImageBinaryResult struct {
	Bytes         []byte `json:"bytes"`
	RevisedPrompt string `json:"revisedPrompt,omitempty"`
}

```


--| internal/features/ai/model/interfaces/model.go

```go
// model.go defines model transport contracts for backend adapters.
// internal/core/interfaces/ai/model.go
package ai

import "context"

// ProviderModelMutationInterface defines provider-model CRUD capabilities.
type ProviderModelMutationInterface interface {
	AddProviderModel(ctx context.Context, request AddProviderModelRequest) error
	UpdateProviderModel(ctx context.Context, request UpdateProviderModelRequest) error
	RemoveProviderModel(ctx context.Context, providerName string, modelID string) error
	UpdateProviderModelCapabilities(ctx context.Context, request UpdateProviderModelCapabilitiesRequest) error
}

// ProviderModelInterface defines model catalog capabilities shared across transports.
type ProviderModelInterface interface {
	ListModels(ctx context.Context, filter ModelListFilter) ([]ModelSummary, error)
	ImportModels(ctx context.Context, request ImportModelsRequest) error
	SyncModels(ctx context.Context) (SyncModelsResult, error)
}

// AddProviderModelRequest contains inputs for appending a model to a provider.
type AddProviderModelRequest struct {
	ProviderName string        `json:"providerName"`
	Model        ProviderModel `json:"model"`
}

// UpdateProviderModelRequest contains mutable model fields for a provider model.
type UpdateProviderModelRequest struct {
	ProviderName string              `json:"providerName"`
	ModelID      string              `json:"modelId"`
	Model        ProviderModelUpdate `json:"model"`
}

// UpdateProviderModelCapabilitiesRequest contains mutable capability fields for a provider model.
type UpdateProviderModelCapabilitiesRequest struct {
	ProviderName string                          `json:"providerName"`
	ModelID      string                          `json:"modelId"`
	Capabilities ProviderModelCapabilitiesUpdate `json:"capabilities"`
}

// ProviderModelUpdate describes mutable provider-model attributes.
type ProviderModelUpdate struct {
	Name          *string `json:"name,omitempty"`
	ContextWindow *int    `json:"contextWindow,omitempty"`
}

// ProviderModelCapabilitiesUpdate describes mutable provider-model capability flags.
type ProviderModelCapabilitiesUpdate struct {
	SupportsStreaming *bool `json:"supportsStreaming,omitempty"`
	SupportsTools     *bool `json:"supportsTools,omitempty"`
	SupportsVision    *bool `json:"supportsVision,omitempty"`
}

// ProviderModel describes a model exposed by a provider.
type ProviderModel struct {
	ID                string `json:"id"`
	Name              string `json:"name"`
	ContextWindow     int    `json:"contextWindow"`
	SupportsStreaming bool   `json:"supportsStreaming"`
	SupportsTools     bool   `json:"supportsTools"`
	SupportsVision    bool   `json:"supportsVision"`
}

// ModelListFilter defines model query filters.
type ModelListFilter struct {
	Source                   string   `json:"source,omitempty"`
	RequiredInputModalities  []string `json:"requiredInputModalities,omitempty"`
	RequiredOutputModalities []string `json:"requiredOutputModalities,omitempty"`
	RequiredCapabilityIDs    []string `json:"requiredCapabilityIds,omitempty"`
	RequiredSystemTags       []string `json:"requiredSystemTags,omitempty"`
	RequiresStreaming        *bool    `json:"requiresStreaming,omitempty"`
	RequiresToolCalling      *bool    `json:"requiresToolCalling,omitempty"`
	RequiresStructuredOutput *bool    `json:"requiresStructuredOutput,omitempty"`
	RequiresVision           *bool    `json:"requiresVision,omitempty"`
}

// ModelCapabilities contains model feature and semantic capability metadata.
type ModelCapabilities struct {
	SupportsStreaming        bool     `json:"supportsStreaming"`
	SupportsToolCalling      bool     `json:"supportsToolCalling"`
	SupportsStructuredOutput bool     `json:"supportsStructuredOutput"`
	SupportsVision           bool     `json:"supportsVision"`
	InputModalities          []string `json:"inputModalities"`
	OutputModalities         []string `json:"outputModalities"`
	CapabilityIDs            []string `json:"capabilityIds"`
	SystemTags               []string `json:"systemTags,omitempty"`
}

// ModelSummary contains model listing fields used by adapters.
type ModelSummary struct {
	ID                string            `json:"id"`
	ModelID           string            `json:"modelId"`
	DisplayName       string            `json:"displayName"`
	ProviderName      string            `json:"providerName"`
	Source            string            `json:"source"`
	Approved          bool              `json:"approved"`
	AvailabilityState string            `json:"availabilityState"`
	ContextWindow     int               `json:"contextWindow"`
	CostTier          string            `json:"costTier"`
	Capabilities      ModelCapabilities `json:"capabilities"`
}

// ImportModelsRequest contains model import inputs.
type ImportModelsRequest struct {
	FilePath string `json:"filePath"`
}

// SyncModelsResult contains sync output metadata.
type SyncModelsResult struct {
	Path     string `json:"path"`
	Imported bool   `json:"imported"`
}

```


--| internal/features/ai/model/model_access.go

```go
// model_access.go resolves enabled model selections from settings configuration.
// internal/features/settings/module/model_access.go
package ai

import (
	"strings"

	config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
)

// ResolveEnabledModelsFromConfig returns enabled models from configuration only.
func ResolveEnabledModelsFromConfig(cfg config.AppConfig, providerName string, defaultModel string) []providercore.Model {
	providerConfig := findProviderConfig(&cfg, providerName)
	enabledIDs := []string{}
	if providerConfig != nil {
		enabledIDs = normalizeModelIDs(enabledModelIDs(providerConfig.Models))
	}
	trimmedDefault := strings.TrimSpace(defaultModel)
	if trimmedDefault != "" && !containsString(enabledIDs, trimmedDefault) {
		enabledIDs = append(enabledIDs, trimmedDefault)
	}
	return buildFallbackModels(enabledIDs)
}

// findProviderConfig returns the provider config entry for a name.
func findProviderConfig(cfg *config.AppConfig, providerName string) *config.ProviderConfig {
	for i := range cfg.Providers {
		if cfg.Providers[i].Name == providerName {
			return &cfg.Providers[i]
		}
	}
	return nil
}

// enabledModelIDs extracts enabled model IDs from config.
func enabledModelIDs(models []config.ModelConfig) []string {
	enabled := make([]string, 0, len(models))
	for _, model := range models {
		if !model.Enabled {
			continue
		}
		enabled = append(enabled, model.ID)
	}
	return enabled
}

// normalizeModelIDs trims and deduplicates model IDs.
func normalizeModelIDs(ids []string) []string {
	seen := make(map[string]struct{}, len(ids))
	normalized := make([]string, 0, len(ids))
	for _, id := range ids {
		trimmed := strings.TrimSpace(id)
		if trimmed == "" {
			continue
		}
		if _, ok := seen[trimmed]; ok {
			continue
		}
		seen[trimmed] = struct{}{}
		normalized = append(normalized, trimmed)
	}
	return normalized
}

// buildFallbackModels constructs model structs from IDs.
func buildFallbackModels(ids []string) []providercore.Model {
	models := make([]providercore.Model, 0, len(ids))
	for _, id := range ids {
		models = append(models, providercore.Model{
			ID:   id,
			Name: id,
		})
	}
	return models
}

// containsString checks whether a slice contains a value.
func containsString(values []string, target string) bool {
	for _, value := range values {
		if value == target {
			return true
		}
	}
	return false
}

```


--| internal/features/ai/model/model_service.go

```go
// model_service.go provides model catalog backend operations.
// internal/core/backend/ai/model_service.go
package ai

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/MadeByDoug/wls-chatbot/internal/core/datastore"
	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model/interfaces"
	"github.com/MadeByDoug/wls-chatbot/internal/platform"
)

// ModelCapabilitiesRecord defines catalog capability fields required by model service filters.
type ModelCapabilitiesRecord struct {
	SupportsStreaming        bool
	SupportsToolCalling      bool
	SupportsStructuredOutput bool
	SupportsVision           bool
	InputModalities          []string
	OutputModalities         []string
}

// ModelSummaryRecord defines catalog model summary fields required by model service operations.
type ModelSummaryRecord struct {
	ModelCapabilitiesRecord
	ID                string
	EndpointID        string
	ModelID           string
	DisplayName       string
	Source            string
	Approved          bool
	AvailabilityState string
	MetadataJSON      string
	CostTier          string
}

// EndpointRecord defines catalog endpoint fields required by model service operations.
type EndpointRecord struct {
	ID           string
	ProviderName string
}

// ModelCatalogOperations defines model catalog operations required by the model backend service.
type ModelCatalogOperations interface {
	ListModelSummaries(ctx context.Context) ([]ModelSummaryRecord, error)
	ListModelSystemTags(ctx context.Context) (map[string][]string, error)
	ListEndpoints(ctx context.Context) ([]EndpointRecord, error)
}

// ModelService handles model catalog operations for transport adapters.
type ModelService struct {
	catalog ModelCatalogOperations
	db      *sql.DB
	appName string
}

var _ aiinterfaces.ProviderModelInterface = (*ModelService)(nil)
var _ aiinterfaces.ProviderModelMutationInterface = (*ModelService)(nil)

// NewModelService creates a model backend service from catalog dependencies.
func NewModelService(catalog ModelCatalogOperations, db *sql.DB, appName string) *ModelService {

	return &ModelService{
		catalog: catalog,
		db:      db,
		appName: appName,
	}
}

// ListModels returns model summaries filtered by requested capabilities.
func (s *ModelService) ListModels(ctx context.Context, filter aiinterfaces.ModelListFilter) ([]aiinterfaces.ModelSummary, error) {

	if s.catalog == nil {
		return nil, fmt.Errorf("backend service: model catalog not configured")
	}
	if ctx == nil {
		ctx = context.Background()
	}

	records, err := s.catalog.ListModelSummaries(ctx)
	if err != nil {
		return nil, err
	}
	systemTagsByEntryID, err := s.catalog.ListModelSystemTags(ctx)
	if err != nil {
		return nil, err
	}
	endpoints, err := s.catalog.ListEndpoints(ctx)
	if err != nil {
		return nil, err
	}

	providerByEndpointID := make(map[string]string, len(endpoints))
	for _, endpoint := range endpoints {
		providerByEndpointID[endpoint.ID] = endpoint.ProviderName
	}

	summaries := make([]aiinterfaces.ModelSummary, 0, len(records))
	for _, record := range records {
		if !matchesSourceFilter(record.Source, filter.Source) {
			continue
		}

		profile := buildCapabilityProfile(record, systemTagsByEntryID[record.ID])
		if !matchesModelFilter(profile, filter) {
			continue
		}

		summaries = append(summaries, aiinterfaces.ModelSummary{
			ID:                record.ID,
			ModelID:           record.ModelID,
			DisplayName:       firstNonEmpty(record.DisplayName, record.ModelID),
			ProviderName:      providerByEndpointID[record.EndpointID],
			Source:            record.Source,
			Approved:          record.Approved,
			AvailabilityState: record.AvailabilityState,
			ContextWindow:     parseContextWindowFromMetadata(record.MetadataJSON),
			CostTier:          record.CostTier,
			Capabilities: aiinterfaces.ModelCapabilities{
				SupportsStreaming:        profile.SupportsStreaming,
				SupportsToolCalling:      profile.SupportsToolCalling,
				SupportsStructuredOutput: profile.SupportsStructuredOutput,
				SupportsVision:           profile.SupportsVision,
				InputModalities:          profile.InputModalities,
				OutputModalities:         profile.OutputModalities,
				CapabilityIDs:            profile.CapabilityIDs,
				SystemTags:               profile.SystemTags,
			},
		})
	}

	return summaries, nil
}

// ImportModels imports models from a local YAML file into the catalog datastore.
func (s *ModelService) ImportModels(_ context.Context, request aiinterfaces.ImportModelsRequest) error {

	if s.db == nil {
		return fmt.Errorf("backend service: datastore not configured")
	}

	path := strings.TrimSpace(request.FilePath)
	if path == "" {
		return fmt.Errorf("backend service: import models requires file path")
	}

	payload, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("backend service: read model file: %w", err)
	}

	if err := datastore.SeedModels(s.db, payload); err != nil {
		return fmt.Errorf("backend service: import models: %w", err)
	}

	return nil
}

// SyncModels imports models from the default app custom-models file when present.
func (s *ModelService) SyncModels(ctx context.Context) (aiinterfaces.SyncModelsResult, error) {

	if strings.TrimSpace(s.appName) == "" {
		return aiinterfaces.SyncModelsResult{}, fmt.Errorf("backend service: app name not configured")
	}

	appDataDir, err := platform.ResolveAppDataDir(s.appName)
	if err != nil {
		return aiinterfaces.SyncModelsResult{}, fmt.Errorf("backend service: resolve app data dir: %w", err)
	}

	customModelsPath := filepath.Join(appDataDir, "custom-models.yaml")
	if _, err := os.Stat(customModelsPath); err != nil {
		if os.IsNotExist(err) {
			return aiinterfaces.SyncModelsResult{
				Path:     customModelsPath,
				Imported: false,
			}, nil
		}
		return aiinterfaces.SyncModelsResult{}, fmt.Errorf("backend service: stat custom models file: %w", err)
	}

	if err := s.ImportModels(ctx, aiinterfaces.ImportModelsRequest{FilePath: customModelsPath}); err != nil {
		return aiinterfaces.SyncModelsResult{}, err
	}

	return aiinterfaces.SyncModelsResult{
		Path:     customModelsPath,
		Imported: true,
	}, nil
}

// AddProviderModel adds a model to a provider catalog entry set.
func (*ModelService) AddProviderModel(context.Context, aiinterfaces.AddProviderModelRequest) error {

	return fmt.Errorf("backend service: add provider model not configured")
}

// UpdateProviderModel updates mutable model fields for a provider model.
func (*ModelService) UpdateProviderModel(context.Context, aiinterfaces.UpdateProviderModelRequest) error {

	return fmt.Errorf("backend service: update provider model not configured")
}

// RemoveProviderModel removes a model from a provider catalog entry set.
func (*ModelService) RemoveProviderModel(context.Context, string, string) error {

	return fmt.Errorf("backend service: remove provider model not configured")
}

// UpdateProviderModelCapabilities updates mutable capability fields for a provider model.
func (*ModelService) UpdateProviderModelCapabilities(context.Context, aiinterfaces.UpdateProviderModelCapabilitiesRequest) error {

	return fmt.Errorf("backend service: update provider model capabilities not configured")
}

// modelCapabilityProfile contains model capabilities normalized for filtering.
type modelCapabilityProfile struct {
	SupportsStreaming        bool
	SupportsToolCalling      bool
	SupportsStructuredOutput bool
	SupportsVision           bool
	InputModalities          []string
	OutputModalities         []string
	CapabilityIDs            []string
	SystemTags               []string
}

// semanticCapabilityBySystemTag maps provider/system tags to semantic capability identifiers.
var semanticCapabilityBySystemTag = map[string][]string{
	"image_edit":                []string{"vision.edit.image"},
	"vision_segmentation_image": []string{"vision.segmentation.promptable_image"},
	"speech_asr":                []string{"speech.asr"},
	"speech_tts":                []string{"speech.tts"},
}

// buildCapabilityProfile builds a normalized model capability profile used for filtering.
func buildCapabilityProfile(record ModelSummaryRecord, systemTags []string) modelCapabilityProfile {

	normalizedSystemTags := uniqueNormalized(systemTags)
	capabilityIDs := uniqueNormalized(append(
		parseCapabilityIDsFromMetadata(record.MetadataJSON),
		deriveCapabilityIDsFromTags(normalizedSystemTags)...,
	))

	return modelCapabilityProfile{
		SupportsStreaming:        record.SupportsStreaming,
		SupportsToolCalling:      record.SupportsToolCalling,
		SupportsStructuredOutput: record.SupportsStructuredOutput,
		SupportsVision:           record.SupportsVision,
		InputModalities:          uniqueNormalized(record.InputModalities),
		OutputModalities:         uniqueNormalized(record.OutputModalities),
		CapabilityIDs:            capabilityIDs,
		SystemTags:               normalizedSystemTags,
	}
}

// matchesModelFilter reports whether a model capability profile satisfies all filter requirements.
func matchesModelFilter(profile modelCapabilityProfile, filter aiinterfaces.ModelListFilter) bool {

	if len(filter.RequiredInputModalities) > 0 && !containsAll(profile.InputModalities, filter.RequiredInputModalities) {
		return false
	}
	if len(filter.RequiredOutputModalities) > 0 && !containsAll(profile.OutputModalities, filter.RequiredOutputModalities) {
		return false
	}
	if len(filter.RequiredCapabilityIDs) > 0 && !containsAll(profile.CapabilityIDs, filter.RequiredCapabilityIDs) {
		return false
	}
	if len(filter.RequiredSystemTags) > 0 && !containsAll(profile.SystemTags, filter.RequiredSystemTags) {
		return false
	}

	if filter.RequiresStreaming != nil && profile.SupportsStreaming != *filter.RequiresStreaming {
		return false
	}
	if filter.RequiresToolCalling != nil && profile.SupportsToolCalling != *filter.RequiresToolCalling {
		return false
	}
	if filter.RequiresStructuredOutput != nil && profile.SupportsStructuredOutput != *filter.RequiresStructuredOutput {
		return false
	}
	if filter.RequiresVision != nil && profile.SupportsVision != *filter.RequiresVision {
		return false
	}

	return true
}

// deriveCapabilityIDsFromTags maps known model tags into semantic capability identifiers.
func deriveCapabilityIDsFromTags(systemTags []string) []string {

	derived := make([]string, 0)
	for _, tag := range uniqueNormalized(systemTags) {
		derived = append(derived, semanticCapabilityBySystemTag[tag]...)
	}
	return uniqueNormalized(derived)
}

// parseCapabilityIDsFromMetadata extracts semantic capability identifiers from model metadata JSON.
func parseCapabilityIDsFromMetadata(metadata string) []string {

	parsed := parseMetadataObject(metadata)
	if parsed == nil {
		return nil
	}

	capabilityIDs := make([]string, 0)
	for _, key := range []string{"capabilityIds", "capability_ids", "semantic_capabilities"} {
		capabilityIDs = append(capabilityIDs, readStringSlice(parsed[key])...)
	}

	return uniqueNormalized(capabilityIDs)
}

// parseSystemTagsFromMetadata extracts model system tags from model metadata JSON.
func parseSystemTagsFromMetadata(metadata string) []string {

	parsed := parseMetadataObject(metadata)
	if parsed == nil {
		return nil
	}

	tags := make([]string, 0)
	for _, key := range []string{"systemTags", "system_tags", "tags"} {
		tags = append(tags, readStringSlice(parsed[key])...)
	}

	return uniqueNormalized(tags)
}

// containsAll reports whether every value in needles appears in haystack.
func containsAll(haystack []string, needles []string) bool {

	haystackSet := make(map[string]struct{}, len(haystack))
	for _, value := range uniqueNormalized(haystack) {
		haystackSet[value] = struct{}{}
	}

	for _, value := range uniqueNormalized(needles) {
		if _, ok := haystackSet[value]; !ok {
			return false
		}
	}
	return true
}

// matchesSourceFilter reports whether a source value matches the optional source filter.
func matchesSourceFilter(source string, requested string) bool {

	trimmed := strings.TrimSpace(requested)
	if trimmed == "" {
		return true
	}
	return strings.EqualFold(strings.TrimSpace(source), trimmed)
}

// parseContextWindowFromMetadata reads optional context window hints from metadata.
func parseContextWindowFromMetadata(metadata string) int {

	parsed := parseMetadataObject(metadata)
	if parsed == nil {
		return 0
	}

	for _, key := range []string{"contextWindow", "context_window", "context_length"} {
		switch value := parsed[key].(type) {
		case float64:
			if value > 0 {
				return int(value)
			}
		case int:
			if value > 0 {
				return value
			}
		}
	}

	return 0
}

// parseMetadataObject parses metadata JSON into a map.
func parseMetadataObject(metadata string) map[string]interface{} {

	if strings.TrimSpace(metadata) == "" {
		return nil
	}

	parsed := make(map[string]interface{})
	if err := json.Unmarshal([]byte(metadata), &parsed); err != nil {
		return nil
	}
	return parsed
}

// readStringSlice converts metadata values into a normalized string slice.
func readStringSlice(value interface{}) []string {

	switch typed := value.(type) {
	case []string:
		return uniqueNormalized(typed)
	case []interface{}:
		items := make([]string, 0, len(typed))
		for _, item := range typed {
			if text, ok := item.(string); ok {
				items = append(items, text)
			}
		}
		return uniqueNormalized(items)
	case string:
		trimmed := strings.TrimSpace(typed)
		if trimmed == "" {
			return nil
		}
		return []string{strings.ToLower(trimmed)}
	default:
		return nil
	}
}

// uniqueNormalized returns sorted unique lowercase non-empty values.
func uniqueNormalized(values []string) []string {

	if len(values) == 0 {
		return nil
	}

	seen := make(map[string]struct{}, len(values))
	normalized := make([]string, 0, len(values))
	for _, value := range values {
		trimmed := strings.ToLower(strings.TrimSpace(value))
		if trimmed == "" {
			continue
		}
		if _, ok := seen[trimmed]; ok {
			continue
		}
		seen[trimmed] = struct{}{}
		normalized = append(normalized, trimmed)
	}

	if len(normalized) == 0 {
		return nil
	}
	slices.Sort(normalized)
	return normalized
}

// firstNonEmpty returns the first non-empty trimmed value.
func firstNonEmpty(values ...string) string {

	for _, value := range values {
		trimmed := strings.TrimSpace(value)
		if trimmed != "" {
			return trimmed
		}
	}
	return ""
}

```


--| internal/features/ai/providers/adapters/anthropic/provider.go

```go
// provider.go implements the Anthropic provider adapter.
// internal/features/providers/adapters/anthropic/provider.go
package anthropic

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/httpcompat"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
	anthropicsdk "github.com/anthropics/anthropic-sdk-go"
	"github.com/anthropics/anthropic-sdk-go/option"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	defaultAnthropicMaxTokens = 1024
	CredentialAPIKey          = providercore.CredentialAPIKey
	RoleUser                  = providergateway.RoleUser
	RoleAssistant             = providergateway.RoleAssistant
	RoleSystem                = providergateway.RoleSystem
)

// Anthropic implements the Provider interface for Anthropic.
type Anthropic struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*Anthropic)(nil)

// New creates a new Anthropic provider.
func New(config Config) *Anthropic {

	baseURL := normalizeBaseURL(config.BaseURL)
	if baseURL == "" {
		baseURL = "https://api.anthropic.com"
	}

	return &Anthropic{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (a *Anthropic) Name() string {

	return a.name
}

// DisplayName returns the human-readable provider name.
func (a *Anthropic) DisplayName() string {

	return a.displayName
}

// Models returns the available models.
func (a *Anthropic) Models() []Model {

	return a.models
}

// CredentialFields returns the expected credential inputs.
func (a *Anthropic) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (a *Anthropic) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			a.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		a.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		a.baseURL = normalizeBaseURL(config.BaseURL)
	}
	if config.Models != nil {
		a.models = config.Models
	}
	return nil
}

// normalizeBaseURL removes version suffixes that Anthropic SDK appends internally.
func normalizeBaseURL(raw string) string {

	normalized := strings.TrimSpace(raw)
	normalized = strings.TrimRight(normalized, "/")
	if strings.HasSuffix(strings.ToLower(normalized), "/v1") {
		normalized = strings.TrimRight(normalized[:len(normalized)-3], "/")
	}
	return normalized
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (a *Anthropic) SetHTTPClient(client HTTPClient) {

	if client != nil {
		a.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (a *Anthropic) httpClient() HTTPClient {

	if a.client == nil {
		a.client = providerhttp.NewDefaultClient()
	}
	return a.client
}

// TestConnection verifies the API is reachable.
func (a *Anthropic) TestConnection(ctx context.Context) error {

	_, err := a.ListResources(ctx)
	return err
}

// ListResources fetches the available models from Anthropic.
func (a *Anthropic) ListResources(ctx context.Context) ([]Model, error) {

	client := a.newSDKClient()
	page, err := client.Models.List(ctx, anthropicsdk.ModelListParams{})
	if err != nil {
		return nil, a.wrapAnthropicError(err)
	}

	models := make([]Model, 0, len(page.Data))
	for _, item := range page.Data {
		if item.ID == "" {
			continue
		}
		name := strings.TrimSpace(item.DisplayName)
		if name == "" {
			name = item.ID
		}
		models = append(models, Model{
			ID:   item.ID,
			Name: name,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// Chat implements streaming chat completion.
func (a *Anthropic) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	if strings.TrimSpace(opts.Model) == "" {
		return nil, fmt.Errorf("model required")
	}

	apiMessages, systemBlocks := a.toAnthropicMessages(messages)
	if len(apiMessages) == 0 {
		return nil, fmt.Errorf("messages required")
	}

	params := anthropicsdk.MessageNewParams{
		Model:     anthropicsdk.Model(opts.Model),
		MaxTokens: int64(a.resolveMaxTokens(opts)),
		Messages:  apiMessages,
	}
	if len(systemBlocks) > 0 {
		params.System = systemBlocks
	}
	if opts.Temperature > 0 {
		params.Temperature = anthropicsdk.Float(opts.Temperature)
	}
	if len(opts.StopWords) > 0 {
		params.StopSequences = opts.StopWords
	}

	if opts.Stream {
		return a.chatStreaming(ctx, params)
	}
	return a.chatOnce(ctx, params)
}

// resolveMaxTokens returns a valid max token value for Anthropic.
func (a *Anthropic) resolveMaxTokens(opts ChatOptions) int {

	if opts.MaxTokens > 0 {
		return opts.MaxTokens
	}
	return defaultAnthropicMaxTokens
}

// toAnthropicMessages converts provider messages into Anthropic params.
func (a *Anthropic) toAnthropicMessages(messages []ProviderMessage) ([]anthropicsdk.MessageParam, []anthropicsdk.TextBlockParam) {

	apiMessages := make([]anthropicsdk.MessageParam, 0, len(messages))
	systemBlocks := make([]anthropicsdk.TextBlockParam, 0)

	for _, msg := range messages {
		content := strings.TrimSpace(msg.Content)
		if content == "" {
			continue
		}

		if msg.Role == RoleSystem {
			systemBlocks = append(systemBlocks, anthropicsdk.TextBlockParam{Text: content})
			continue
		}

		block := anthropicsdk.NewTextBlock(content)
		if msg.Role == RoleAssistant {
			apiMessages = append(apiMessages, anthropicsdk.NewAssistantMessage(block))
			continue
		}

		apiMessages = append(apiMessages, anthropicsdk.NewUserMessage(block))
	}

	return apiMessages, systemBlocks
}

// chatOnce executes a non-streaming Anthropic chat request.
func (a *Anthropic) chatOnce(ctx context.Context, params anthropicsdk.MessageNewParams) (<-chan Chunk, error) {

	client := a.newSDKClient()
	resp, err := client.Messages.New(ctx, params)
	if err != nil {
		return nil, a.wrapAnthropicError(err)
	}

	content := a.textFromContentBlocks(resp.Content)
	chunks := make(chan Chunk, 1)
	go func() {
		defer close(chunks)
		chunks <- Chunk{
			Content:      content,
			Model:        string(resp.Model),
			FinishReason: a.mapStopReason(resp.StopReason),
			Usage:        a.toUsageStats(resp.Usage),
		}
	}()

	return chunks, nil
}

// chatStreaming executes a streaming Anthropic chat request.
func (a *Anthropic) chatStreaming(ctx context.Context, params anthropicsdk.MessageNewParams) (<-chan Chunk, error) {

	client := a.newSDKClient()
	stream := client.Messages.NewStreaming(ctx, params)
	chunks := make(chan Chunk, 100)

	go func() {
		defer close(chunks)
		defer func() { _ = stream.Close() }()

		message := anthropicsdk.Message{}
		for stream.Next() {
			event := stream.Current()
			if err := message.Accumulate(event); err != nil {
				chunks <- Chunk{Error: err}
				return
			}

			switch variant := event.AsAny().(type) {
			case anthropicsdk.ContentBlockDeltaEvent:
				delta := variant.Delta.AsAny()
				if textDelta, ok := delta.(anthropicsdk.TextDelta); ok {
					if text := textDelta.Text; text != "" {
						chunks <- Chunk{
							Content: text,
							Model:   string(message.Model),
						}
					}
				}
			}
		}

		if err := stream.Err(); err != nil {
			chunks <- Chunk{Error: a.wrapAnthropicError(err)}
			return
		}

		chunks <- Chunk{
			Model:        string(message.Model),
			FinishReason: a.mapStopReason(message.StopReason),
			Usage:        a.toUsageStats(message.Usage),
		}
	}()

	return chunks, nil
}

// textFromContentBlocks flattens Anthropic content blocks into plain text.
func (a *Anthropic) textFromContentBlocks(blocks []anthropicsdk.ContentBlockUnion) string {

	if len(blocks) == 0 {
		return ""
	}

	var builder strings.Builder
	for _, block := range blocks {
		if block.Type != "text" {
			continue
		}
		if block.Text == "" {
			continue
		}
		builder.WriteString(block.Text)
	}
	return builder.String()
}

// toUsageStats converts Anthropic usage into provider usage stats.
func (a *Anthropic) toUsageStats(usage anthropicsdk.Usage) *UsageStats {

	if usage.InputTokens == 0 && usage.OutputTokens == 0 {
		return nil
	}
	prompt := int(usage.InputTokens)
	completion := int(usage.OutputTokens)
	return &UsageStats{
		PromptTokens:     prompt,
		CompletionTokens: completion,
		TotalTokens:      prompt + completion,
	}
}

// mapStopReason normalizes Anthropic stop reasons for the provider response.
func (a *Anthropic) mapStopReason(reason anthropicsdk.StopReason) string {

	if reason == "" {
		return ""
	}
	return string(reason)
}

// newSDKClient constructs an Anthropic SDK client.
func (a *Anthropic) newSDKClient() anthropicsdk.Client {

	opts := []option.RequestOption{
		option.WithAPIKey(a.apiKey),
		option.WithHTTPClient(a.httpClient()),
	}
	if a.baseURL != "" {
		opts = append(opts, option.WithBaseURL(a.baseURL))
	}
	return anthropicsdk.NewClient(opts...)
}

// wrapAnthropicError normalizes SDK errors into APIError when possible.
func (a *Anthropic) wrapAnthropicError(err error) error {

	var apiErr *anthropicsdk.Error
	if errors.As(err, &apiErr) {
		return &providerhttp.APIError{Code: apiErr.StatusCode, Message: apiErr.Error()}
	}
	return err
}

// GenerateImage generates an image. Anthropic does not support this capability.
func (a *Anthropic) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("anthropic provider does not support image generation")
}

// EditImage returns not supported error.
func (a *Anthropic) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/ai/providers/adapters/cache/sqlite.go

```go
// sqlite.go persists provider resource cache snapshots in SQLite.
// internal/features/providers/adapters/cache/sqlite.go
package cache

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
)

const providerCacheSchema = `
CREATE TABLE IF NOT EXISTS provider_cache (
	id INTEGER PRIMARY KEY CHECK (id = 1),
	cache_json TEXT NOT NULL,
	updated_at INTEGER NOT NULL
);`

// SQLiteStore manages provider cache persistence in SQLite.
type SQLiteStore struct {
	db *sql.DB
}

// NewSQLiteStore creates a SQLite-backed cache store.
func NewSQLiteStore(db *sql.DB) (*SQLiteStore, error) {

	if db == nil {
		return nil, fmt.Errorf("provider cache: db required")
	}

	if _, err := db.Exec(providerCacheSchema); err != nil {
		return nil, fmt.Errorf("provider cache: ensure schema: %w", err)
	}

	return &SQLiteStore{db: db}, nil
}

var _ providercore.ProviderCache = (*SQLiteStore)(nil)

// Load retrieves the cached resources.
func (s *SQLiteStore) Load() (providercore.ProviderCacheSnapshot, error) {

	if s == nil || s.db == nil {
		return nil, fmt.Errorf("provider cache: db required")
	}

	row := s.db.QueryRow("SELECT cache_json FROM provider_cache WHERE id = 1")
	var data string
	if err := row.Scan(&data); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return make(providercore.ProviderCacheSnapshot), nil
		}
		return nil, fmt.Errorf("provider cache: load: %w", err)
	}

	var snapshot providercore.ProviderCacheSnapshot
	if err := json.Unmarshal([]byte(data), &snapshot); err != nil {
		return nil, fmt.Errorf("provider cache: decode: %w", err)
	}
	if snapshot == nil {
		snapshot = make(providercore.ProviderCacheSnapshot)
	}
	return snapshot, nil
}

// Save persists the resources to the cache store.
func (s *SQLiteStore) Save(snapshot providercore.ProviderCacheSnapshot) error {

	if s == nil || s.db == nil {
		return fmt.Errorf("provider cache: db required")
	}

	if snapshot == nil {
		snapshot = make(providercore.ProviderCacheSnapshot)
	}

	data, err := json.Marshal(snapshot)
	if err != nil {
		return fmt.Errorf("provider cache: encode: %w", err)
	}

	now := time.Now().UnixMilli()
	_, err = s.db.Exec(
		`INSERT INTO provider_cache (id, cache_json, updated_at)
		 VALUES (1, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		  cache_json = excluded.cache_json,
		  updated_at = excluded.updated_at`,
		string(data),
		now,
	)
	if err != nil {
		return fmt.Errorf("provider cache: save: %w", err)
	}

	return nil
}

```


--| internal/features/ai/providers/adapters/cloudflare/provider.go

```go
// provider.go implements the Cloudflare AI Gateway provider adapter.
// internal/features/providers/adapters/cloudflare/provider.go
package cloudflare

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"
	"strings"

	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/logger"
	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/httpcompat"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
	"github.com/cloudflare/cloudflare-go"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type ProviderCredentials = providercore.ProviderCredentials
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client
type Logger = coreports.Logger
type LogField = coreports.LogField

const (
	CredentialAccountID       = providercore.CredentialAccountID
	CredentialGatewayID       = providercore.CredentialGatewayID
	CredentialCloudflareToken = providercore.CredentialCloudflareToken
	CredentialAPIKey          = providercore.CredentialAPIKey
	CredentialToken           = providercore.CredentialToken
)

// Cloudflare implements the Provider interface for Cloudflare AI Gateway.
type Cloudflare struct {
	name            string
	displayName     string
	baseURL         string
	accountID       string
	gatewayID       string
	upstreamAPIKey  string
	cloudflareToken string
	gatewayToken    string
	logger          Logger
	models          []Model
	client          HTTPClient
}

var _ Provider = (*Cloudflare)(nil)

// New creates a new Cloudflare provider.
func New(config Config) *Cloudflare {

	provider := &Cloudflare{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     config.BaseURL,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
	_ = provider.Configure(config)
	return provider
}

// Name returns the provider identifier.
func (c *Cloudflare) Name() string {

	return c.name
}

// DisplayName returns the human-readable provider name.
func (c *Cloudflare) DisplayName() string {

	return c.displayName
}

// Models returns the available models.
func (c *Cloudflare) Models() []Model {

	return c.models
}

// CredentialFields returns the expected credential inputs.
func (c *Cloudflare) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:        CredentialAccountID,
			Label:       "Account ID",
			Required:    true,
			Secret:      false,
			Placeholder: "Cloudflare account ID",
			Help:        "The Cloudflare account identifier that owns the AI Gateway.",
		},
		{
			Name:        CredentialGatewayID,
			Label:       "Gateway ID",
			Required:    true,
			Secret:      false,
			Placeholder: "AI Gateway ID",
			Help:        "The gateway identifier from your Cloudflare AI Gateway settings.",
		},
		{
			Name:        CredentialCloudflareToken,
			Label:       "Cloudflare API Token",
			Required:    false,
			Secret:      true,
			Placeholder: "Cloudflare API token",
			Help:        "Required for Cloudflare-hosted Workers AI models (for example @cf/...).",
		},
		{
			Name:        CredentialAPIKey,
			Label:       "Upstream API Key (optional)",
			Required:    false,
			Secret:      true,
			Placeholder: "Provider API key",
			Help:        "Required for non-Workers AI models (for example openai/... or anthropic/...).",
		},
		{
			Name:        CredentialToken,
			Label:       "Gateway Auth Token (optional)",
			Required:    false,
			Secret:      true,
			Placeholder: "AI Gateway token",
			Help:        "Optional token for Cloudflare AI Gateway authentication (cf-aig-authorization).",
		},
	}
}

// Configure updates the provider configuration.
func (c *Cloudflare) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAccountID]; ok {
			c.accountID = strings.TrimSpace(value)
		}
		if value, ok := config.Credentials[CredentialCloudflareToken]; ok {
			c.cloudflareToken = strings.TrimSpace(value)
		}
	}
	if config.BaseURL != "" {
		c.baseURL = config.BaseURL
	}
	if config.Models != nil {
		c.models = config.Models
	}
	if config.Logger != nil {
		c.logger = config.Logger
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (c *Cloudflare) SetHTTPClient(client HTTPClient) {

	if client != nil {
		c.client = client
	}
}

// SetLogger sets the logger used for debug output.
func (c *Cloudflare) SetLogger(logger Logger) {

	if logger != nil {
		c.logger = logger
	}
}

// httpClient returns the configured HTTP client or a default client.
func (c *Cloudflare) httpClient() HTTPClient {

	if c.client == nil {
		c.client = providerhttp.NewDefaultClient()
	}
	return c.client
}

// newSDKClient creates a new Cloudflare SDK client.
func (c *Cloudflare) newSDKClient() (*cloudflare.API, error) {
	// Cloudflare SDK requires API Token.
	token := c.cloudflareToken
	if token == "" {
		return nil, fmt.Errorf("cloudflare API token required for SDK usage")
	}

	// Create client
	api, err := cloudflare.NewWithAPIToken(token)
	if err != nil {
		return nil, err
	}

	if c.client != nil {
		// propagate client if feasible, but SDK v0.116 doesn't easily expose it via NewWithAPIToken
	}

	return api, nil
}

// TestConnection verifies the API is reachable.
func (c *Cloudflare) TestConnection(ctx context.Context) error {
	// Simple validation
	if c.accountID == "" || c.cloudflareToken == "" {
		return fmt.Errorf("account ID and Cloudflare token required")
	}
	return nil
}

// ListResources fetches the available models.
func (c *Cloudflare) ListResources(ctx context.Context) ([]Model, error) {

	// SDK List logic using api.Raw
	api, err := c.newSDKClient()
	if err != nil {
		return nil, err
	}
	if c.accountID == "" {
		return nil, fmt.Errorf("account ID required for listing models")
	}

	// Try to list text generation models via generic search endpoint if available,
	// or assume standard models. Since SDK doesn't expose ListWorkersAIModels,
	// and we removed legacy, we attempt `GET accounts/{id}/ai/models/search`
	// which is the common endpoint.

	endpoint := fmt.Sprintf("accounts/%s/ai/models/search", c.accountID)
	// Some docs say `/ai/models/search`, others just `/ai/models`.
	// We'll try one. If it fails, we return error (strict no legacy).

	res, err := api.Raw(ctx, "GET", endpoint, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to list models via SDK: %w", err)
	}

	if !res.Success {
		return nil, fmt.Errorf("failed to list models: active success=false in response")
	}

	// Response structure for models search
	var listRes struct {
		Result []struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Task        struct {
				Name string `json:"name"`
			} `json:"task"`
		} `json:"result"`
	}

	if err := json.Unmarshal(res.Result, &listRes); err != nil {
		// fall back to empty list if parsing fails? Or strict error?
		return nil, fmt.Errorf("failed to parse models list: %w", err)
	}

	var models []Model
	seen := make(map[string]struct{})

	for _, m := range listRes.Result {
		// Filter for text generation or image models if desired?
		// For now, include all or just Text Generation.
		// "Text Generation" task name usually.
		if m.Task.Name == "Text Generation" || m.Task.Name == "Text-to-Image" {
			id := "@cf/" + m.Name
			if !strings.HasPrefix(m.Name, "@cf/") {
				// usually name is full like "meta/llama-2-7b-chat-int8" ?
				// The API returns name like "meta/llama-2-7b-chat-int8".
				// Workers AI requires "@cf/" prefix often, or just name?
				// SDK examples often show "@cf/meta/llama..."
				id = "@cf/" + m.Name
			}

			if _, ok := seen[id]; !ok {
				models = append(models, Model{
					ID:   id,
					Name: m.Name,
				})
				seen[id] = struct{}{}
			}
		}
	}

	if len(models) > 0 {
		sort.Slice(models, func(i, j int) bool {
			return models[i].ID < models[j].ID
		})
	}
	return models, nil
}

// Chat implements streaming chat completion.
func (c *Cloudflare) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	// Strict SDK / Workers AI logic
	if c.accountID == "" {
		return nil, fmt.Errorf("account ID required")
	}

	model := resolveModelName(opts.Model)

	api, err := c.newSDKClient()
	if err != nil {
		return nil, err
	}

	endpoint := fmt.Sprintf("accounts/%s/ai/run/%s", c.accountID, model)

	reqBody := map[string]interface{}{}
	sdkMessages := make([]map[string]string, 0, len(messages))
	for _, msg := range messages {
		if strings.TrimSpace(msg.Content) == "" {
			continue
		}
		sdkMessages = append(sdkMessages, map[string]string{
			"role":    string(msg.Role),
			"content": msg.Content,
		})
	}
	reqBody["messages"] = sdkMessages
	reqBody["max_tokens"] = opts.MaxTokens

	if opts.Stream {
		// SDK api.Raw does not support streaming (buffers response).
		// Per user instruction "Remove legacy", we cannot fallback to manual HTTP.
		// We return error for streaming requests.
		return nil, fmt.Errorf("streaming not supported with current SDK integration")
	}

	// Non-streaming via SDK Raw
	res, err := api.Raw(ctx, "POST", endpoint, reqBody, nil)
	if err != nil {
		return nil, err
	}

	if !res.Success {
		if len(res.Errors) > 0 {
			return nil, fmt.Errorf("ai error: %s", res.Errors[0].Message)
		}
		return nil, fmt.Errorf("ai request failed")
	}

	var aiRes struct {
		Response string `json:"response"`
	}
	if err := json.Unmarshal(res.Result, &aiRes); err != nil {
		return nil, fmt.Errorf("failed to parse AI response: %w", err)
	}

	chunks := make(chan Chunk, 1)
	chunks <- Chunk{
		Content: aiRes.Response,
	}
	close(chunks)
	return chunks, nil
}

// resolveModelName normalizes model names for Workers AI.
func resolveModelName(model string) string {
	model = strings.TrimSpace(model)
	// Ensure @cf prefix if missing and looks like it needs one?
	// or assume input is correct.
	// Common convention: "llama-2..." -> "@cf/meta/llama-2..."
	// But we can't guess vendor.
	// If it doesn't start with @cf/, we assume user provided full path or we fail?
	// Let's assume input is raw ID.
	return model
}

// logDebug writes debug output if a logger is configured.
func (c *Cloudflare) logDebug(message string, fields ...LogField) {

	if c.logger == nil {
		return
	}
	c.logger.Debug(message, fields...)
}

// isWorkersAIBaseURL reports whether the base URL targets Workers AI directly.
func isWorkersAIBaseURL(baseURL string) bool {
	return strings.Contains(strings.ToLower(baseURL), "/workers-ai/")
}

// GenerateImage generates an image. Cloudflare Workers AI supports this, but implementation is pending specific model support verification.
func (c *Cloudflare) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	// SDK's api.Raw() expects JSON response, but Image Gen returns binary (PNG).
	// Cannot use SDK's Raw method for this as it tries to parse JSON.
	return nil, fmt.Errorf("cloudflare provider image generation not yet implemented via SDK")
}

// EditImage returns not supported error.
func (c *Cloudflare) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/ai/providers/adapters/gemini/provider.go

```go
// provider.go implements the Gemini provider adapter.
// internal/features/providers/adapters/gemini/provider.go
package gemini

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/httpcompat"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
	"google.golang.org/genai"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey = providercore.CredentialAPIKey
	RoleAssistant    = providergateway.RoleAssistant
)

// Gemini implements the Provider interface for Google's Gemini API.
type Gemini struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*Gemini)(nil)

// New creates a new Gemini provider.
func New(config Config) *Gemini {

	baseURL := config.BaseURL
	// The SDK handles default base URL. Only set if explicitly provided?
	// Actually, SDK config might need it.

	return &Gemini{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (g *Gemini) Name() string {
	return g.name
}

// DisplayName returns the human-readable provider name.
func (g *Gemini) DisplayName() string {
	return g.displayName
}

// Models returns the available models.
func (g *Gemini) Models() []Model {
	return g.models
}

// CredentialFields returns the expected credential inputs.
func (g *Gemini) CredentialFields() []CredentialField {
	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (g *Gemini) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			g.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		g.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		g.baseURL = config.BaseURL
	}
	if config.Models != nil {
		g.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (g *Gemini) SetHTTPClient(client HTTPClient) {

	if client != nil {
		g.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (g *Gemini) httpClient() HTTPClient {

	if g.client == nil {
		g.client = providerhttp.NewDefaultClient()
	}
	return g.client
}

// newSDKClient creates a new Gemini SDK client.
func (g *Gemini) newSDKClient(ctx context.Context) (*genai.Client, error) {
	opts := &genai.ClientConfig{
		APIKey: g.apiKey,
	}
	// If base URL is custom, check if genai client supports it.
	// Looking at typical genai patterns, it's often implicit.
	// We'll trust the default unless we find a way to set it in ClientConfig if needed.
	// NOTE: google.golang.org/genai might not expose BaseURL directly in config,
	// but let's assume standard behavior or skip if not needed for migration.

	if g.client != nil {
		if client, ok := g.client.(*http.Client); ok {
			opts.HTTPClient = client
		}
	}

	return genai.NewClient(ctx, opts)
}

// TestConnection verifies the Gemini API is reachable.
func (g *Gemini) TestConnection(ctx context.Context) error {

	url := fmt.Sprintf("%s/models?key=%s", g.baseURL, g.apiKey)
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return err
	}

	resp, err := g.httpClient().Do(req)
	if err != nil {
		return err
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return &providerhttp.APIError{Code: resp.StatusCode, Message: string(body)}
	}

	return nil
}

// ListResources fetches the available models from the Gemini API.
func (g *Gemini) ListResources(ctx context.Context) ([]Model, error) {
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, err
	}

	pager, err := client.Models.List(ctx, nil)
	if err != nil {
		return nil, err
	}
	// Supports Go 1.23 iterator? The error said `assignment mismatch`.
	// Most likely `List` returns `*genai.ModelListIterator`.
	// If it handles standard iterator:

	models := make([]Model, 0)
	for _, item := range pager.Items {

		name := item.DisplayName
		if name == "" {
			name = item.Name // fallback
		}

		id := strings.TrimPrefix(item.Name, "models/")

		models = append(models, Model{
			ID:   id,
			Name: name,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].Name < models[j].Name
	})

	return models, nil
}

// Chat implements streaming chat completion for Gemini.
func (g *Gemini) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, err
	}

	sdkParts := make([]*genai.Content, 0, len(messages))
	for _, msg := range messages {
		if strings.TrimSpace(msg.Content) == "" {
			continue
		}
		role := "user"
		if msg.Role == RoleAssistant {
			role = "model"
		}
		sdkParts = append(sdkParts, &genai.Content{
			Role: role,
			Parts: []*genai.Part{
				{Text: msg.Content},
			},
		})
	}

	config := &genai.GenerateContentConfig{
		Temperature:     g.float32Ptr(opts.Temperature),
		MaxOutputTokens: int32(opts.MaxTokens),
	}

	modelID := opts.Model

	if opts.Stream {
		stream := client.Models.GenerateContentStream(ctx, modelID, sdkParts, config)
		chunks := make(chan Chunk, 100)
		go func() {
			defer close(chunks)
			// Go 1.23 iterator loop
			for resp, err := range stream {
				if err != nil {
					chunks <- Chunk{Error: err}
					return
				}

				// Process chunk
				for _, cand := range resp.Candidates {
					text := ""
					for _, part := range cand.Content.Parts {
						text += part.Text
					}
					chunk := Chunk{
						Content:      text,
						FinishReason: "",
					}
					if resp.UsageMetadata != nil {
						chunk.Usage = &UsageStats{
							PromptTokens:     int(resp.UsageMetadata.PromptTokenCount),
							CompletionTokens: int(resp.UsageMetadata.CandidatesTokenCount),
							TotalTokens:      int(resp.UsageMetadata.TotalTokenCount),
						}
					}
					chunks <- chunk
				}
			}
		}()
		return chunks, nil
	}

	// Non-streaming
	resp, err := client.Models.GenerateContent(ctx, modelID, sdkParts, config)
	if err != nil {
		return nil, err
	}

	chunks := make(chan Chunk, 1)
	go func() {
		defer close(chunks)
		for _, cand := range resp.Candidates {
			text := ""
			for _, part := range cand.Content.Parts {
				text += part.Text
			}
			chunk := Chunk{
				Content:      text,
				FinishReason: "",
			}
			if resp.UsageMetadata != nil {
				chunk.Usage = &UsageStats{
					PromptTokens:     int(resp.UsageMetadata.PromptTokenCount),
					CompletionTokens: int(resp.UsageMetadata.CandidatesTokenCount),
					TotalTokens:      int(resp.UsageMetadata.TotalTokenCount),
				}
			}
			chunks <- chunk
		}
	}()
	return chunks, nil
}

func (g *Gemini) float32Ptr(v float64) *float32 {
	if v == 0 {
		return nil
	}
	val := float32(v)
	return &val
}

// GenerateImage generates an image using the Gemini/Imagen predict API.
func (g *Gemini) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {

	// Default to a known Imagen model if not specified.
	model := opts.Model
	if model == "" {
		model = "imagen-4.0-generate-001"
	}

	// Gemini models (gemini-2.5-flash-image, etc.) use the GenerateContent API (multimodal).
	if strings.HasPrefix(model, "gemini") {
		return g.generateContentImage(ctx, model, opts)
	}

	// Use genai library for Imagen models (Imagen 3/4)
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create SDK client: %w", err)
	}

	cfg := &genai.GenerateImagesConfig{
		NumberOfImages: int32(opts.N),
	}
	if cfg.NumberOfImages == 0 {
		cfg.NumberOfImages = 1
	}

	// Aspect Ratio mapping
	if opts.Size == "1024x1024" || opts.Size == "1:1" {
		cfg.AspectRatio = "1:1"
	} else if opts.Size == "16:9" {
		cfg.AspectRatio = "16:9"
	} else if opts.Size == "9:16" {
		cfg.AspectRatio = "9:16"
	} else if opts.Size == "3:4" {
		cfg.AspectRatio = "3:4"
	} else if opts.Size == "4:3" {
		cfg.AspectRatio = "4:3"
	}

	resp, err := client.Models.GenerateImages(ctx, opts.Model, opts.Prompt, cfg)
	if err != nil {
		return nil, fmt.Errorf("genai generate images failed: %w", err)
	}

	result := &providergateway.ImageResult{
		// Data: make([]providergateway.ImageData, len(resp.GeneratedImages)),
		Data: make([]providergateway.ImageData, 0),
	}

	for _, img := range resp.GeneratedImages {
		result.Data = append(result.Data, providergateway.ImageData{
			B64JSON: base64.StdEncoding.EncodeToString(img.Image.ImageBytes),
		})
	}

	return result, nil
}

// generateContentImage handles image generation for Gemini models via the GenerateContent API.
func (g *Gemini) generateContentImage(ctx context.Context, model string, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	client, err := g.newSDKClient(ctx)
	if err != nil {
		return nil, err
	}

	// Construct content parts
	parts := []*genai.Part{
		{Text: opts.Prompt},
	}

	// Config
	// Note: Gemini models typically produce 1 image per request via GenerateContent defaults or strict configs.
	// The Go SDK might not expose explicit image count in GenerateContentConfig effectively for all models yet,
	// checking genai.GenerateContentConfig...
	config := &genai.GenerateContentConfig{
		// Temperature, etc. might apply.
		// For image generation, response MimeType might be specified?
	}

	resp, err := client.Models.GenerateContent(ctx, model, []*genai.Content{{Parts: parts}}, config)
	if err != nil {
		return nil, fmt.Errorf("generate content failed: %w", err)
	}

	if len(resp.Candidates) == 0 {
		return nil, fmt.Errorf("no candidates returned")
	}

	result := &providergateway.ImageResult{
		Data: make([]providergateway.ImageData, 0),
	}

	for _, cand := range resp.Candidates {
		for _, part := range cand.Content.Parts {
			if part.InlineData != nil {
				result.Data = append(result.Data, providergateway.ImageData{
					B64JSON: base64.StdEncoding.EncodeToString(part.InlineData.Data),
				})
			} else if part.FileData != nil {
				// URI based
				result.Data = append(result.Data, providergateway.ImageData{
					URL: part.FileData.FileURI,
				})
			}
		}
	}

	if len(result.Data) == 0 {
		return nil, fmt.Errorf("no image data found in response")
	}

	return result, nil
}

// EditImage edits an image using the Gemini/Imagen predict API.
func (g *Gemini) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {

	// Logic for imagen-3.0-capability-image-editing-001 or newer equivalents
	// Currently Imagen 4+ via genai SDK does not expose EditImage/Masking directly in the public docs provided.
	// We will attempt to use the genai client if possible, but standard 'GenerateImages' is text-to-image.

	return nil, fmt.Errorf("image editing is not currently supported by the genai library for Imagen 4 models (Text-to-Image only). Please use 'generate image' without an input image.")
}

// loadInputImage reads image from file path or returns error.
func loadInputImage(input string) ([]byte, error) {
	// Simple check: is it a file that exists?
	// If not, is it valid base64?

	// Try reading file first
	data, err := os.ReadFile(input)
	if err == nil {
		return data, nil
	}

	// If read file fails, maybe it is base64?
	decoded, err := base64.StdEncoding.DecodeString(input)
	if err == nil {
		return decoded, nil
	}

	return nil, fmt.Errorf("input is neither a valid file path nor base64 string")
}

```


--| internal/features/ai/providers/adapters/grok/provider.go

```go
// provider.go implements the Grok (xAI) provider adapter.
// internal/features/providers/adapters/grok/provider.go
package grok

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/httpcompat"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
	openaisdk "github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey = providercore.CredentialAPIKey
	RoleUser         = providergateway.RoleUser
	RoleAssistant    = providergateway.RoleAssistant
	RoleSystem       = providergateway.RoleSystem
)

// Grok implements the Provider interface for xAI.
type Grok struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*Grok)(nil)

// New creates a new Grok provider.
func New(config Config) *Grok {
	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = "https://api.x.ai/v1"
	}

	return &Grok{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (g *Grok) Name() string {
	return g.name
}

// DisplayName returns the human-readable provider name.
func (g *Grok) DisplayName() string {
	return g.displayName
}

// Models returns the available models.
func (g *Grok) Models() []Model {
	return g.models
}

// CredentialFields returns the expected credential inputs.
func (g *Grok) CredentialFields() []CredentialField {
	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (g *Grok) Configure(config Config) error {
	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			g.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		g.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		g.baseURL = config.BaseURL
	}
	if config.Models != nil {
		g.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (g *Grok) SetHTTPClient(client HTTPClient) {
	if client != nil {
		g.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (g *Grok) httpClient() HTTPClient {
	if g.client == nil {
		g.client = providerhttp.NewDefaultClient()
	}
	return g.client
}

// TestConnection verifies the API is reachable.
func (g *Grok) TestConnection(ctx context.Context) error {
	return g.testConnectionSDK(ctx)
}

// ListResources fetches the available models.
func (g *Grok) ListResources(ctx context.Context) ([]Model, error) {
	return g.listResourcesSDK(ctx)
}

// Chat implements streaming chat completion.
func (g *Grok) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {
	return g.chatSDK(ctx, messages, opts)
}

// GenerateImage generates an image using the OpenAI SDK (xAI compatible).
func (g *Grok) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	// xAI doesn't currently support image generation via this endpoint publicly documented as identical to OpenAI's DALL-E,
	// but the user requested it. We will assume compatibility or return error if it fails.
	// Actually, Grok 2 has image generation capabilities. It might be via the same /images/generations endpoint.

	client := g.newSDKClient()
	params := openaisdk.ImageGenerateParams{
		Prompt: opts.Prompt,
		Model:  openaisdk.ImageModel(opts.Model),
	}

	if opts.N > 0 {
		params.N = openaisdk.Int(int64(opts.N))
	}
	if opts.Size != "" {
		params.Size = openaisdk.ImageGenerateParamsSize(opts.Size)
	}
	if opts.Quality != "" {
		params.Quality = openaisdk.ImageGenerateParamsQuality(opts.Quality)
	}
	if opts.Style != "" {
		params.Style = openaisdk.ImageGenerateParamsStyle(opts.Style)
	}
	if opts.ResponseFormat != "" {
		params.ResponseFormat = openaisdk.ImageGenerateParamsResponseFormat(opts.ResponseFormat)
	}
	if opts.User != "" {
		params.User = openaisdk.String(opts.User)
	}

	resp, err := client.Images.Generate(ctx, params)
	if err != nil {
		return nil, g.wrapOpenAIError(err)
	}

	result := &providergateway.ImageResult{
		Created: resp.Created,
		Data:    make([]providergateway.ImageData, len(resp.Data)),
	}

	for i, d := range resp.Data {
		result.Data[i] = providergateway.ImageData{
			URL:           d.URL,
			B64JSON:       d.B64JSON,
			RevisedPrompt: d.RevisedPrompt,
		}
	}

	return result, nil
}

// normalizeBaseURL ensures the base URL ends with a slash.
func (g *Grok) normalizeBaseURL() string {
	baseURL := strings.TrimSpace(g.baseURL)
	if baseURL == "" {
		return baseURL
	}
	if !strings.HasSuffix(baseURL, "/") {
		baseURL += "/"
	}
	return baseURL
}

// newSDKClient constructs an OpenAI SDK client pointed at xAI.
func (g *Grok) newSDKClient() openaisdk.Client {
	opts := []option.RequestOption{
		option.WithAPIKey(g.apiKey),
		option.WithBaseURL(g.normalizeBaseURL()),
	}
	return openaisdk.NewClient(opts...)
}

// testConnectionSDK validates connectivity.
func (g *Grok) testConnectionSDK(ctx context.Context) error {
	client := g.newSDKClient()
	_, err := client.Models.List(ctx)
	if err != nil {
		return g.wrapOpenAIError(err)
	}
	return nil
}

// listResourcesSDK lists models.
func (g *Grok) listResourcesSDK(ctx context.Context) ([]Model, error) {
	client := g.newSDKClient()
	page, err := client.Models.List(ctx)
	if err != nil {
		return nil, g.wrapOpenAIError(err)
	}

	models := make([]Model, 0, len(page.Data))
	for _, item := range page.Data {
		if item.ID == "" {
			continue
		}
		// Basic filter or simply list all
		models = append(models, Model{
			ID:   item.ID,
			Name: item.ID,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// chatSDK executes chat requests.
func (g *Grok) chatSDK(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {
	client := g.newSDKClient()
	params := openaisdk.ChatCompletionNewParams{
		Model:    openaisdk.ChatModel(opts.Model),
		Messages: g.toSDKMessages(messages),
	}

	if opts.Temperature > 0 {
		params.Temperature = openaisdk.Float(opts.Temperature)
	}
	if opts.MaxTokens > 0 {
		params.MaxTokens = openaisdk.Int(int64(opts.MaxTokens))
	}
	if opts.Stream {
		params.StreamOptions = openaisdk.ChatCompletionStreamOptionsParam{
			IncludeUsage: openaisdk.Bool(true),
		}
	}

	if !opts.Stream {
		resp, err := client.Chat.Completions.New(ctx, params)
		if err != nil {
			return nil, g.wrapOpenAIError(err)
		}
		chunks := make(chan Chunk, 1)
		go func() {
			defer close(chunks)
			if len(resp.Choices) == 0 {
				return
			}
			choice := resp.Choices[0]
			chunk := Chunk{
				Content:      choice.Message.Content,
				FinishReason: choice.FinishReason,
				Usage:        g.toUsageStats(resp.Usage),
			}
			chunks <- chunk
		}()
		return chunks, nil
	}

	stream := client.Chat.Completions.NewStreaming(ctx, params)
	chunks := make(chan Chunk, 100)
	go func() {
		defer close(chunks)
		defer func() { _ = stream.Close() }()

		for stream.Next() {
			cur := stream.Current()
			usage := g.toUsageStatsFromChunk(cur)
			content := ""
			finishReason := ""

			if len(cur.Choices) > 0 {
				choice := cur.Choices[0]
				content = choice.Delta.Content
				finishReason = choice.FinishReason
			}

			if content == "" && finishReason == "" && usage == nil {
				continue
			}

			chunks <- Chunk{
				Content:      content,
				Model:        cur.Model,
				FinishReason: finishReason,
				Usage:        usage,
			}
		}

		if err := stream.Err(); err != nil {
			chunks <- Chunk{Error: g.wrapOpenAIError(err)}
		}
	}()

	return chunks, nil
}

// toSDKMessages converts chat messages to SDK message params.
func (g *Grok) toSDKMessages(messages []ProviderMessage) []openaisdk.ChatCompletionMessageParamUnion {
	result := make([]openaisdk.ChatCompletionMessageParamUnion, 0, len(messages))
	for _, msg := range messages {
		content := msg.Content
		if strings.TrimSpace(content) == "" {
			continue
		}

		switch msg.Role {
		case RoleSystem:
			result = append(result, openaisdk.SystemMessage(content))
		case RoleAssistant:
			result = append(result, openaisdk.AssistantMessage(content))
		case RoleUser:
			result = append(result, openaisdk.UserMessage(content))
		default:
			result = append(result, openaisdk.UserMessage(content))
		}
	}
	return result
}

// toUsageStats converts SDK usage to provider usage stats.
func (g *Grok) toUsageStats(usage openaisdk.CompletionUsage) *UsageStats {
	if usage.TotalTokens == 0 && usage.PromptTokens == 0 && usage.CompletionTokens == 0 {
		return nil
	}
	return &UsageStats{
		PromptTokens:     int(usage.PromptTokens),
		CompletionTokens: int(usage.CompletionTokens),
		TotalTokens:      int(usage.TotalTokens),
	}
}

// toUsageStatsFromChunk extracts usage stats from a streaming chunk.
func (g *Grok) toUsageStatsFromChunk(chunk openaisdk.ChatCompletionChunk) *UsageStats {
	if !chunk.JSON.Usage.Valid() {
		return nil
	}
	return g.toUsageStats(chunk.Usage)
}

// wrapOpenAIError normalizes SDK errors into APIError when possible.
func (g *Grok) wrapOpenAIError(err error) error {
	var apiErr *openaisdk.Error
	if errors.As(err, &apiErr) {
		message := strings.TrimSpace(apiErr.Message)
		if message == "" {
			message = strings.TrimSpace(apiErr.RawJSON())
		}
		return &providerhttp.APIError{Code: apiErr.StatusCode, Message: message}
	}
	return err
}

// GenerateImage returns not supported error (if not already implemented elsewhere, relying on interface compliance).
// ACTUALLY I need to check if GenerateImage is missing. If Gork compiles, it must have it.
// I will just append EditImage.
// EditImage returns not supported error.
func (g *Grok) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/ai/providers/adapters/httpcompat/api_error.go

```go
// api_error.go defines HTTP API error types for HTTP-compatible provider adapters.
// internal/features/providers/adapters/httpcompat/api_error.go
package providerhttp

import "fmt"

// APIError represents an HTTP API error with a status code.
type APIError struct {
	Code    int
	Message string
}

// Error formats the API error for display.
func (e *APIError) Error() string {

	if e == nil {
		return ""
	}
	if e.Message == "" {
		return fmt.Sprintf("API error: %d", e.Code)
	}
	return fmt.Sprintf("API error: %d - %s", e.Code, e.Message)
}

// StatusCode returns the HTTP status code for this error.
func (e *APIError) StatusCode() int {

	if e == nil {
		return 0
	}
	return e.Code
}

```


--| internal/features/ai/providers/adapters/httpcompat/client.go

```go
// client.go defines shared HTTP client helpers for provider adapters.
// internal/features/providers/adapters/httpcompat/client.go
package providerhttp

import (
	"net/http"
	"time"
)

const defaultHTTPTimeout = 15 * time.Second

// Client defines the minimal HTTP client contract for providers.
type Client interface {
	Do(req *http.Request) (*http.Response, error)
}

// NewDefaultClient constructs the default HTTP client with timeouts.
func NewDefaultClient() *http.Client {

	return &http.Client{
		Timeout: defaultHTTPTimeout,
	}
}

```


--| internal/features/ai/providers/adapters/httpcompat/openai_compat.go

```go
// openai_compat.go handles OpenAI-compatible HTTP flows shared by provider adapters.
// internal/features/providers/adapters/httpcompat/openai_compat.go
package providerhttp

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strings"

	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
)

// ListOpenAICompatModels fetches models from an OpenAI-compatible API.
func ListOpenAICompatModels(ctx context.Context, client Client, baseURL string, headers map[string]string) ([]providercore.Model, error) {

	baseURL = normalizeCompatBaseURL(baseURL)
	if baseURL == "" {
		return nil, fmt.Errorf("base URL required")
	}

	req, err := http.NewRequestWithContext(ctx, "GET", baseURL+"/models", nil)
	if err != nil {
		return nil, err
	}
	setHeaders(req, headers)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{Code: resp.StatusCode, Message: string(body)}
	}

	var payload struct {
		Data []struct {
			ID string `json:"id"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&payload); err != nil {
		return nil, err
	}

	models := make([]providercore.Model, 0, len(payload.Data))
	for _, item := range payload.Data {
		if item.ID == "" {
			continue
		}
		models = append(models, providercore.Model{
			ID:   item.ID,
			Name: item.ID,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// ChatOpenAICompat executes OpenAI-compatible chat completion requests.
func ChatOpenAICompat(ctx context.Context, client Client, baseURL string, headers map[string]string, messages []providergateway.ProviderMessage, opts providergateway.ChatOptions) (<-chan providergateway.Chunk, error) {

	baseURL = normalizeCompatBaseURL(baseURL)
	if baseURL == "" {
		return nil, fmt.Errorf("base URL required")
	}

	body, err := MarshalOpenAICompatBody(opts.Model, messages, opts)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", baseURL+"/chat/completions", bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	setHeaders(req, headers)

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		_ = resp.Body.Close()
		return nil, &APIError{Code: resp.StatusCode, Message: string(body)}
	}

	chunks := make(chan providergateway.Chunk, 100)

	go func() {
		defer close(chunks)
		defer func() { _ = resp.Body.Close() }()

		if opts.Stream {
			streamOpenAICompatResponse(resp.Body, chunks)
		} else {
			parseOpenAICompatResponse(resp.Body, chunks)
		}
	}()

	return chunks, nil
}

// MarshalOpenAICompatBody builds and marshals an OpenAI-compatible request body.
func MarshalOpenAICompatBody(model string, messages []providergateway.ProviderMessage, opts providergateway.ChatOptions) ([]byte, error) {

	reqBody := buildOpenAICompatBody(model, messages, opts)
	return json.Marshal(reqBody)
}

// buildOpenAICompatBody constructs an OpenAI-compatible request payload.
func buildOpenAICompatBody(model string, messages []providergateway.ProviderMessage, opts providergateway.ChatOptions) map[string]interface{} {

	apiMessages := make([]map[string]interface{}, 0, len(messages))
	for _, msg := range messages {
		content := msg.Content
		if strings.TrimSpace(content) == "" {
			continue
		}
		apiMessages = append(apiMessages, map[string]interface{}{
			"role":    string(msg.Role),
			"content": content,
		})
	}

	reqBody := map[string]interface{}{
		"model":    model,
		"messages": apiMessages,
		"stream":   opts.Stream,
	}

	if opts.Temperature > 0 {
		reqBody["temperature"] = opts.Temperature
	}
	if opts.MaxTokens > 0 {
		reqBody["max_tokens"] = opts.MaxTokens
	}

	return reqBody
}

// normalizeCompatBaseURL trims trailing slashes from OpenAI-compatible base URLs.
func normalizeCompatBaseURL(baseURL string) string {

	trimmed := strings.TrimSpace(baseURL)
	return strings.TrimRight(trimmed, "/")
}

// setHeaders adds configured headers when provided.
func setHeaders(req *http.Request, headers map[string]string) {

	if req == nil || len(headers) == 0 {
		return
	}
	for name, value := range headers {
		if strings.TrimSpace(name) == "" || strings.TrimSpace(value) == "" {
			continue
		}
		req.Header.Set(name, value)
	}
}

// streamOpenAICompatResponse parses SSE responses into chunks.
func streamOpenAICompatResponse(body io.Reader, chunks chan<- providergateway.Chunk) {

	scanner := bufio.NewScanner(body)
	scanner.Buffer(make([]byte, 0, 64*1024), 1024*1024)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "data: ") {
			continue
		}

		data := strings.TrimPrefix(line, "data: ")
		if data == "[DONE]" {
			chunks <- providergateway.Chunk{FinishReason: "stop"}
			return
		}

		var resp struct {
			Model   string `json:"model"`
			Choices []struct {
				Delta struct {
					Content string `json:"content"`
				} `json:"delta"`
				FinishReason string `json:"finish_reason"`
			} `json:"choices"`
			Usage *providergateway.UsageStats `json:"usage"`
		}

		if err := json.Unmarshal([]byte(data), &resp); err != nil {
			continue
		}

		if len(resp.Choices) > 0 {
			choice := resp.Choices[0]
			chunk := providergateway.Chunk{
				Content:      choice.Delta.Content,
				Model:        resp.Model,
				FinishReason: choice.FinishReason,
			}
			if resp.Usage != nil {
				chunk.Usage = resp.Usage
			}
			chunks <- chunk
		}
	}
	if err := scanner.Err(); err != nil {
		chunks <- providergateway.Chunk{Error: err}
	}
}

// parseOpenAICompatResponse parses a non-streaming response into a chunk.
func parseOpenAICompatResponse(body io.Reader, chunks chan<- providergateway.Chunk) {

	var resp struct {
		Choices []struct {
			Message struct {
				Content string `json:"content"`
			} `json:"message"`
			FinishReason string `json:"finish_reason"`
		} `json:"choices"`
		Usage *providergateway.UsageStats `json:"usage"`
	}

	if err := json.NewDecoder(body).Decode(&resp); err != nil {
		chunks <- providergateway.Chunk{Error: err}
		return
	}

	if len(resp.Choices) > 0 {
		choice := resp.Choices[0]
		chunks <- providergateway.Chunk{
			Content:      choice.Message.Content,
			FinishReason: choice.FinishReason,
			Usage:        resp.Usage,
		}
	}
}

```


--| internal/features/ai/providers/adapters/openai/provider.go

```go
// provider.go implements the OpenAI provider adapter.
// internal/features/providers/adapters/openai/provider.go
package openai

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/httpcompat"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
	openaisdk "github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type UsageStats = providergateway.UsageStats
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey = providercore.CredentialAPIKey
	RoleUser         = providergateway.RoleUser
	RoleAssistant    = providergateway.RoleAssistant
	RoleSystem       = providergateway.RoleSystem
)

// OpenAI implements the Provider interface for OpenAI-compatible APIs.
// Works with OpenAI, Groq, and other OpenAI-compatible endpoints.
type OpenAI struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*OpenAI)(nil)

// New creates a new OpenAI provider.
func New(config Config) *OpenAI {

	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = "https://api.openai.com/v1"
	}

	return &OpenAI{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (o *OpenAI) Name() string {

	return o.name
}

// DisplayName returns the human-readable provider name.
func (o *OpenAI) DisplayName() string {

	return o.displayName
}

// Models returns the available models.
func (o *OpenAI) Models() []Model {

	return o.models
}

// CredentialFields returns the expected credential inputs.
func (o *OpenAI) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
	}
}

// Configure updates the provider configuration.
func (o *OpenAI) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			o.apiKey = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		o.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		o.baseURL = config.BaseURL
	}
	if config.Models != nil {
		o.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (o *OpenAI) SetHTTPClient(client HTTPClient) {

	if client != nil {
		o.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (o *OpenAI) httpClient() HTTPClient {

	if o.client == nil {
		o.client = providerhttp.NewDefaultClient()
	}
	return o.client
}

// TestConnection verifies the API is reachable.
func (o *OpenAI) TestConnection(ctx context.Context) error {

	if o.usesOpenAISDK() {
		return o.testConnectionSDK(ctx)
	}

	headers := o.authHeaders()
	_, err := providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
	return err
}

// ListResources fetches the available models from an OpenAI-compatible API.
func (o *OpenAI) ListResources(ctx context.Context) ([]Model, error) {

	if o.usesOpenAISDK() {
		return o.listResourcesSDK(ctx)
	}

	headers := o.authHeaders()
	return providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
}

// Chat implements streaming chat completion.
func (o *OpenAI) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	if o.usesOpenAISDK() {
		return o.chatSDK(ctx, messages, opts)
	}

	headers := o.authHeaders()
	return providerhttp.ChatOpenAICompat(ctx, o.httpClient(), o.baseURL, headers, messages, opts)
}

// usesOpenAISDK decides whether to use the OpenAI SDK.
func (o *OpenAI) usesOpenAISDK() bool {

	return strings.Contains(strings.ToLower(o.baseURL), "api.openai.com")
}

// authHeaders returns configured request headers.
func (o *OpenAI) authHeaders() map[string]string {

	if strings.TrimSpace(o.apiKey) == "" {
		return nil
	}
	return map[string]string{
		"Authorization": "Bearer " + o.apiKey,
	}
}

// normalizeBaseURL ensures the base URL ends with a slash.
func (o *OpenAI) normalizeBaseURL() string {

	baseURL := strings.TrimSpace(o.baseURL)
	if baseURL == "" {
		return baseURL
	}
	if !strings.HasSuffix(baseURL, "/") {
		baseURL += "/"
	}
	return baseURL
}

// newSDKClient constructs an OpenAI SDK client.
func (o *OpenAI) newSDKClient() openaisdk.Client {

	opts := []option.RequestOption{option.WithAPIKey(o.apiKey)}
	if o.baseURL != "" {
		opts = append(opts, option.WithBaseURL(o.normalizeBaseURL()))
	}
	return openaisdk.NewClient(opts...)
}

// testConnectionSDK validates connectivity using the OpenAI SDK.
func (o *OpenAI) testConnectionSDK(ctx context.Context) error {

	client := o.newSDKClient()
	_, err := client.Models.List(ctx)
	if err != nil {
		return o.wrapOpenAIError(err)
	}
	return nil
}

// listResourcesSDK lists models using the OpenAI SDK.
func (o *OpenAI) listResourcesSDK(ctx context.Context) ([]Model, error) {

	client := o.newSDKClient()
	page, err := client.Models.List(ctx)
	if err != nil {
		return nil, o.wrapOpenAIError(err)
	}

	models := make([]Model, 0, len(page.Data))
	for _, item := range page.Data {
		if item.ID == "" {
			continue
		}
		models = append(models, Model{
			ID:   item.ID,
			Name: item.ID,
		})
	}

	sort.Slice(models, func(i, j int) bool {
		return models[i].ID < models[j].ID
	})

	return models, nil
}

// chatSDK executes chat requests with the OpenAI SDK.
func (o *OpenAI) chatSDK(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	client := o.newSDKClient()
	params := openaisdk.ChatCompletionNewParams{
		Model:    openaisdk.ChatModel(opts.Model),
		Messages: o.toSDKMessages(messages),
	}
	if opts.Temperature > 0 {
		params.Temperature = openaisdk.Float(opts.Temperature)
	}
	if opts.MaxTokens > 0 {
		params.MaxTokens = openaisdk.Int(int64(opts.MaxTokens))
	}
	if opts.Stream {
		params.StreamOptions = openaisdk.ChatCompletionStreamOptionsParam{
			IncludeUsage: openaisdk.Bool(true),
		}
	}

	if !opts.Stream {
		resp, err := client.Chat.Completions.New(ctx, params)
		if err != nil {
			return nil, o.wrapOpenAIError(err)
		}
		chunks := make(chan Chunk, 1)
		go func() {
			defer close(chunks)
			if len(resp.Choices) == 0 {
				return
			}
			choice := resp.Choices[0]
			chunk := Chunk{
				Content:      choice.Message.Content,
				FinishReason: choice.FinishReason,
				Usage:        o.toUsageStats(resp.Usage),
			}
			chunks <- chunk
		}()
		return chunks, nil
	}

	stream := client.Chat.Completions.NewStreaming(ctx, params)
	chunks := make(chan Chunk, 100)
	go func() {
		defer close(chunks)
		defer func() { _ = stream.Close() }()

		for stream.Next() {
			cur := stream.Current()
			usage := o.toUsageStatsFromChunk(cur)
			content := ""
			finishReason := ""

			if len(cur.Choices) > 0 {
				choice := cur.Choices[0]
				content = choice.Delta.Content
				finishReason = choice.FinishReason
			}

			if content == "" && finishReason == "" && usage == nil {
				continue
			}

			chunks <- Chunk{
				Content:      content,
				Model:        cur.Model,
				FinishReason: finishReason,
				Usage:        usage,
			}
		}

		if err := stream.Err(); err != nil {
			chunks <- Chunk{Error: o.wrapOpenAIError(err)}
		}
	}()

	return chunks, nil
}

// toSDKMessages converts chat messages to SDK message params.
func (o *OpenAI) toSDKMessages(messages []ProviderMessage) []openaisdk.ChatCompletionMessageParamUnion {

	result := make([]openaisdk.ChatCompletionMessageParamUnion, 0, len(messages))
	for _, msg := range messages {
		content := msg.Content
		if strings.TrimSpace(content) == "" {
			continue
		}

		switch msg.Role {
		case RoleSystem:
			result = append(result, openaisdk.SystemMessage(content))
		case RoleAssistant:
			result = append(result, openaisdk.AssistantMessage(content))
		case RoleUser:
			result = append(result, openaisdk.UserMessage(content))
		default:
			result = append(result, openaisdk.UserMessage(content))
		}
	}
	return result
}

// toUsageStats converts SDK usage to provider usage stats.
func (o *OpenAI) toUsageStats(usage openaisdk.CompletionUsage) *UsageStats {

	if usage.TotalTokens == 0 && usage.PromptTokens == 0 && usage.CompletionTokens == 0 {
		return nil
	}
	return &UsageStats{
		PromptTokens:     int(usage.PromptTokens),
		CompletionTokens: int(usage.CompletionTokens),
		TotalTokens:      int(usage.TotalTokens),
	}
}

// toUsageStatsFromChunk extracts usage stats from a streaming chunk.
func (o *OpenAI) toUsageStatsFromChunk(chunk openaisdk.ChatCompletionChunk) *UsageStats {

	if !chunk.JSON.Usage.Valid() {
		return nil
	}
	return o.toUsageStats(chunk.Usage)
}

// wrapOpenAIError normalizes SDK errors into APIError when possible.
// wrapOpenAIError normalizes SDK errors into APIError when possible.
func (o *OpenAI) wrapOpenAIError(err error) error {

	var apiErr *openaisdk.Error
	if errors.As(err, &apiErr) {
		message := strings.TrimSpace(apiErr.Message)
		if message == "" {
			message = strings.TrimSpace(apiErr.RawJSON())
		}
		return &providerhttp.APIError{Code: apiErr.StatusCode, Message: message}
	}
	return err
}

// GenerateImage generates an image using the OpenAI SDK.
func (o *OpenAI) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {

	client := o.newSDKClient()
	params := openaisdk.ImageGenerateParams{
		Prompt: opts.Prompt,
		Model:  openaisdk.ImageModel(opts.Model),
	}

	if opts.N > 0 {
		params.N = openaisdk.Int(int64(opts.N))
	}
	if opts.Size != "" {
		params.Size = openaisdk.ImageGenerateParamsSize(opts.Size)
	}
	if opts.Quality != "" {
		params.Quality = openaisdk.ImageGenerateParamsQuality(opts.Quality)
	}
	if opts.Style != "" {
		params.Style = openaisdk.ImageGenerateParamsStyle(opts.Style)
	}
	if opts.ResponseFormat != "" {
		params.ResponseFormat = openaisdk.ImageGenerateParamsResponseFormat(opts.ResponseFormat)
	}
	if opts.User != "" {
		params.User = openaisdk.String(opts.User)
	}

	resp, err := client.Images.Generate(ctx, params)
	if err != nil {
		return nil, o.wrapOpenAIError(err)
	}

	result := &providergateway.ImageResult{
		Created: resp.Created,
		Data:    make([]providergateway.ImageData, len(resp.Data)),
	}

	for i, d := range resp.Data {
		result.Data[i] = providergateway.ImageData{
			URL:           d.URL,
			B64JSON:       d.B64JSON,
			RevisedPrompt: d.RevisedPrompt,
		}
	}

	return result, nil
}

// EditImage returns not supported error.
// EditImage returns not supported error.
func (o *OpenAI) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/ai/providers/adapters/openrouter/provider.go

```go
// provider.go implements the OpenRouter provider adapter.
// internal/features/providers/adapters/openrouter/provider.go
package openrouter

import (
	"context"
	"fmt"
	"strings"

	providerhttp "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/httpcompat"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
)

type Model = providercore.Model
type Config = providercore.ProviderConfig
type ChatOptions = providergateway.ChatOptions
type ProviderMessage = providergateway.ProviderMessage
type Chunk = providergateway.Chunk
type CredentialField = providercore.CredentialField
type Provider = providercore.Provider
type HTTPClient = providerhttp.Client

const (
	CredentialAPIKey            = providercore.CredentialAPIKey
	CredentialOpenRouterReferer = providercore.CredentialOpenRouterReferer
	CredentialOpenRouterTitle   = providercore.CredentialOpenRouterTitle
)

// OpenRouter implements the Provider interface for OpenRouter.
type OpenRouter struct {
	name        string
	displayName string
	baseURL     string
	apiKey      string
	referer     string
	title       string
	models      []Model
	client      HTTPClient
}

var _ Provider = (*OpenRouter)(nil)

// New creates a new OpenRouter provider.
func New(config Config) *OpenRouter {

	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = "https://openrouter.ai/api/v1"
	}

	return &OpenRouter{
		name:        config.Name,
		displayName: config.DisplayName,
		baseURL:     baseURL,
		apiKey:      config.APIKey,
		models:      config.Models,
		client:      providerhttp.NewDefaultClient(),
	}
}

// Name returns the provider identifier.
func (o *OpenRouter) Name() string {

	return o.name
}

// DisplayName returns the human-readable provider name.
func (o *OpenRouter) DisplayName() string {

	return o.displayName
}

// Models returns the available models.
func (o *OpenRouter) Models() []Model {

	return o.models
}

// CredentialFields returns the expected credential inputs.
func (o *OpenRouter) CredentialFields() []CredentialField {

	return []CredentialField{
		{
			Name:     CredentialAPIKey,
			Label:    "API Key",
			Required: true,
			Secret:   true,
		},
		{
			Name:        CredentialOpenRouterReferer,
			Label:       "HTTP Referer (optional)",
			Required:    false,
			Secret:      false,
			Placeholder: "https://your-app.example",
			Help:        "Optional HTTP-Referer header used for OpenRouter analytics.",
		},
		{
			Name:        CredentialOpenRouterTitle,
			Label:       "App Title (optional)",
			Required:    false,
			Secret:      false,
			Placeholder: "Wails Chatbot",
			Help:        "Optional X-Title header used for OpenRouter analytics.",
		},
	}
}

// Configure updates the provider configuration.
func (o *OpenRouter) Configure(config Config) error {

	if config.Credentials != nil {
		if value, ok := config.Credentials[CredentialAPIKey]; ok {
			o.apiKey = strings.TrimSpace(value)
		}
		if value, ok := config.Credentials[CredentialOpenRouterReferer]; ok {
			o.referer = strings.TrimSpace(value)
		}
		if value, ok := config.Credentials[CredentialOpenRouterTitle]; ok {
			o.title = strings.TrimSpace(value)
		}
	}
	if strings.TrimSpace(config.APIKey) != "" {
		o.apiKey = config.APIKey
	}
	if config.BaseURL != "" {
		o.baseURL = config.BaseURL
	}
	if config.Models != nil {
		o.models = config.Models
	}
	return nil
}

// SetHTTPClient overrides the HTTP client used by the provider.
func (o *OpenRouter) SetHTTPClient(client HTTPClient) {

	if client != nil {
		o.client = client
	}
}

// httpClient returns the configured HTTP client or a default client.
func (o *OpenRouter) httpClient() HTTPClient {

	if o.client == nil {
		o.client = providerhttp.NewDefaultClient()
	}
	return o.client
}

// TestConnection verifies the API is reachable.
func (o *OpenRouter) TestConnection(ctx context.Context) error {

	headers := o.authHeaders()
	_, err := providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
	return err
}

// ListResources fetches the available models from OpenRouter.
func (o *OpenRouter) ListResources(ctx context.Context) ([]Model, error) {

	headers := o.authHeaders()
	return providerhttp.ListOpenAICompatModels(ctx, o.httpClient(), o.baseURL, headers)
}

// Chat implements streaming chat completion.
func (o *OpenRouter) Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error) {

	headers := o.authHeaders()
	return providerhttp.ChatOpenAICompat(ctx, o.httpClient(), o.baseURL, headers, messages, opts)
}

func (o *OpenRouter) authHeaders() map[string]string {

	headers := make(map[string]string)
	if strings.TrimSpace(o.apiKey) != "" {
		headers["Authorization"] = "Bearer " + strings.TrimSpace(o.apiKey)
	}
	if strings.TrimSpace(o.referer) != "" {
		headers["HTTP-Referer"] = strings.TrimSpace(o.referer)
	}
	if strings.TrimSpace(o.title) != "" {
		headers["X-Title"] = strings.TrimSpace(o.title)
	}
	if len(headers) == 0 {
		return nil
	}
	return headers
}

// GenerateImage generates an image. OpenRouter does not support this capability.
func (o *OpenRouter) GenerateImage(ctx context.Context, opts providergateway.ImageGenerationOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("openrouter provider does not support image generation")
}

// EditImage returns not supported error.
func (o *OpenRouter) EditImage(ctx context.Context, opts providergateway.ImageEditOptions) (*providergateway.ImageResult, error) {
	return nil, fmt.Errorf("edit image not supported by this provider")
}

```


--| internal/features/ai/providers/adapters/registry/inmemory.go

```go
// inmemory.go provides in-memory provider registry storage.
// internal/features/providers/adapters/registry/inmemory.go
package registry

import (
	"sync"

	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
)

// Registry manages available providers.
type Registry struct {
	mu        sync.RWMutex
	providers map[string]providercore.Provider
	active    string
	order     []string
}

// New creates a new provider registry.
func New() *Registry {

	return &Registry{
		providers: make(map[string]providercore.Provider),
	}
}

var _ providercore.ProviderRegistry = (*Registry)(nil)

// Register adds a provider to the registry.
func (r *Registry) Register(p providercore.Provider) {

	r.mu.Lock()
	defer r.mu.Unlock()
	if _, ok := r.providers[p.Name()]; !ok {
		r.order = append(r.order, p.Name())
	}
	r.providers[p.Name()] = p
}

// Get retrieves a provider by name.
func (r *Registry) Get(name string) providercore.Provider {

	r.mu.RLock()
	defer r.mu.RUnlock()
	return r.providers[name]
}

// GetActive returns the currently active provider.
func (r *Registry) GetActive() providercore.Provider {

	r.mu.RLock()
	defer r.mu.RUnlock()
	if r.active == "" {
		return nil
	}
	return r.providers[r.active]
}

// SetActive sets the active provider, or clears it when name is empty.
func (r *Registry) SetActive(name string) bool {

	r.mu.Lock()
	defer r.mu.Unlock()
	if name == "" {
		r.active = ""
		return true
	}
	if _, ok := r.providers[name]; ok {
		r.active = name
		return true
	}
	return false
}

// List returns all registered providers.
func (r *Registry) List() []providercore.Provider {

	r.mu.RLock()
	defer r.mu.RUnlock()

	providers := make([]providercore.Provider, 0, len(r.providers))
	for _, name := range r.order {
		if p, ok := r.providers[name]; ok {
			providers = append(providers, p)
		}
	}
	return providers
}

// ListConfigs returns configurations for all providers.
func (r *Registry) ListConfigs() []providercore.ProviderConfig {

	r.mu.RLock()
	defer r.mu.RUnlock()

	configs := make([]providercore.ProviderConfig, 0, len(r.providers))
	for _, name := range r.order {
		if p, ok := r.providers[name]; ok {
			configs = append(configs, providercore.ProviderConfig{
				Name:        p.Name(),
				DisplayName: p.DisplayName(),
				Models:      p.Models(),
			})
		}
	}
	return configs
}

```


--| internal/features/ai/providers/adapters/secretstore/keyring.go

```go
// keyring.go accesses OS keyring storage for provider secrets.
// internal/features/providers/adapters/secretstore/keyring.go
package securestore

import (
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	"github.com/zalando/go-keyring"
)

// KeyringStore stores provider credentials in the OS keychain.
type KeyringStore struct {
	serviceName string
}

// NewKeyringStore creates a keyring-backed secret store scoped to a service name.
func NewKeyringStore(serviceName string) *KeyringStore {
	return &KeyringStore{serviceName: serviceName}
}

var _ providercore.SecretStore = (*KeyringStore)(nil)

// SaveProviderSecret stores a provider secret field in the OS keychain.
func (s *KeyringStore) SaveProviderSecret(providerName, fieldName, value string) error {
	return keyring.Set(s.serviceName, s.credentialKey(providerName, fieldName), value)
}

// GetProviderSecret retrieves a provider secret field from the OS keychain.
func (s *KeyringStore) GetProviderSecret(providerName, fieldName string) (string, error) {
	return keyring.Get(s.serviceName, s.credentialKey(providerName, fieldName))
}

// HasProviderSecret returns true when a provider secret field is stored.
func (s *KeyringStore) HasProviderSecret(providerName, fieldName string) bool {
	_, err := keyring.Get(s.serviceName, s.credentialKey(providerName, fieldName))
	return err == nil
}

// DeleteProviderSecret removes a stored provider secret field.
func (s *KeyringStore) DeleteProviderSecret(providerName, fieldName string) error {
	return keyring.Delete(s.serviceName, s.credentialKey(providerName, fieldName))
}

// credentialKey builds the keyring entry key for a provider secret field.
func (s *KeyringStore) credentialKey(providerName, fieldName string) string {

	return providerName + ":" + fieldName
}

```


--| internal/features/ai/providers/interfaces/core/credential_policy.go

```go
// credential_policy.go classifies provider input keys that must be treated as secrets.
// internal/features/providers/interfaces/core/credential_policy.go
package core

import "strings"

var sensitiveCredentialNameTokens = []string{
	"api_key",
	"apikey",
	"token",
	"secret",
	"password",
	"private_key",
	"access_key",
	"client_secret",
}

// IsSensitiveCredentialName reports whether a credential key is secret-like and must not be persisted as plain input.
func IsSensitiveCredentialName(name string) bool {

	normalized := strings.ToLower(strings.TrimSpace(name))
	if normalized == "" {
		return false
	}

	switch normalized {
	case CredentialAPIKey, CredentialToken, CredentialCloudflareToken:
		return true
	}

	for _, token := range sensitiveCredentialNameTokens {
		if strings.Contains(normalized, token) {
			return true
		}
	}

	return false
}

```


--| internal/features/ai/providers/interfaces/core/provider.go

```go
// provider.go defines provider identity and configuration contracts.
// internal/features/providers/interfaces/core/provider.go
package core

import (
	"context"

	"github.com/MadeByDoug/wls-chatbot/internal/core/logger"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
)

// Model represents an AI model.
type Model struct {
	ID                string `json:"id"`
	Name              string `json:"name"`
	ContextWindow     int    `json:"contextWindow"`
	SupportsStreaming bool   `json:"supportsStreaming"`
	SupportsTools     bool   `json:"supportsTools"`
	SupportsVision    bool   `json:"supportsVision"`
}

// ProviderCredentials stores credential values by field name.
type ProviderCredentials map[string]string

// CredentialField describes an input required to configure a provider.
type CredentialField struct {
	Name        string `json:"name"`
	Label       string `json:"label"`
	Required    bool   `json:"required"`
	Secret      bool   `json:"secret"`
	Placeholder string `json:"placeholder,omitempty"`
	Help        string `json:"help,omitempty"`
}

const (
	CredentialAPIKey            = "api_key"
	CredentialAccountID         = "account_id"
	CredentialGatewayID         = "gateway_id"
	CredentialToken             = "token"
	CredentialCloudflareToken   = "cloudflare_api_token"
	CredentialOpenRouterReferer = "openrouter_referer"
	CredentialOpenRouterTitle   = "openrouter_title"
)

// ProviderConfig holds provider configuration.
type ProviderConfig struct {
	Name         string              `json:"name"`
	DisplayName  string              `json:"displayName"`
	APIKey       string              `json:"apiKey,omitempty"`
	BaseURL      string              `json:"baseUrl,omitempty"`
	DefaultModel string              `json:"defaultModel"`
	Models       []Model             `json:"models"`
	Credentials  ProviderCredentials `json:"credentials,omitempty"`
	Logger       logger.Logger              `json:"-"`
}

// Provider describes the full provider contract used by app services.
type Provider interface {
	providergateway.Provider
	Name() string
	DisplayName() string
	Models() []Model
	ListResources(ctx context.Context) ([]Model, error)
	CredentialFields() []CredentialField
	Configure(config ProviderConfig) error
}

```


--| internal/features/ai/providers/interfaces/core/provider_cache.go

```go
// provider_cache.go defines provider resource cache contracts.
// internal/features/providers/interfaces/core/provider_cache.go
package core

// ProviderCacheEntry represents cached resources for a provider.
type ProviderCacheEntry struct {
	UpdatedAt int64   `json:"updatedAt"`
	Models    []Model `json:"models"`
}

// ProviderCacheSnapshot contains cached resources by provider name.
type ProviderCacheSnapshot map[string]ProviderCacheEntry

// ProviderCache manages persistence of provider resources.
type ProviderCache interface {
	Load() (ProviderCacheSnapshot, error)
	Save(snapshot ProviderCacheSnapshot) error
}

```


--| internal/features/ai/providers/interfaces/core/provider_inputs_store.go

```go
// provider_inputs_store.go manages provider input persistence for non-secret fields.
// internal/features/providers/interfaces/core/provider_inputs_store.go
package core

// ProviderInputsStore persists non-secret provider input values.
type ProviderInputsStore interface {
	LoadProviderInputs(providerName string) (map[string]string, error)
	SaveProviderInputs(providerName string, inputs map[string]string) error
}

```


--| internal/features/ai/providers/interfaces/core/provider_registry.go

```go
// provider_registry.go defines provider registry contracts.
// internal/features/providers/interfaces/core/provider_registry.go
package core

// ProviderRegistry manages provider instances and active selection.
type ProviderRegistry interface {
	Register(p Provider)
	Get(name string) Provider
	GetActive() Provider
	SetActive(name string) bool
	List() []Provider
	ListConfigs() []ProviderConfig
}

```


--| internal/features/ai/providers/interfaces/core/secret_store.go

```go
// secret_store.go defines secret storage contracts for provider credentials.
// internal/features/providers/interfaces/core/secret_store.go
package core

// SecretStore manages provider secret storage.
type SecretStore interface {
	SaveProviderSecret(providerName, fieldName, value string) error
	GetProviderSecret(providerName, fieldName string) (string, error)
	HasProviderSecret(providerName, fieldName string) bool
	DeleteProviderSecret(providerName, fieldName string) error
}

```


--| internal/features/ai/providers/interfaces/gateway/capabilities.go

```go
// capabilities.go defines gateway semantic capability descriptors.
// internal/features/providers/interfaces/gateway/capabilities.go
package gateway

// CapabilityID identifies a semantic gateway capability.
type CapabilityID string

const (
	CapabilityChatText                     CapabilityID = "chat.text"
	CapabilityChatMultimodalToText         CapabilityID = "chat.multimodal_to_text"
	CapabilityGenerateImage                CapabilityID = "gen.image"
	CapabilityGenerateVideo                CapabilityID = "gen.video"
	CapabilitySpeechASR                    CapabilityID = "speech.asr"
	CapabilitySpeechTTS                    CapabilityID = "speech.tts"
	CapabilityRealtimeDuplexAudio          CapabilityID = "realtime.duplex_audio"
	CapabilityVisionSegmentationImage      CapabilityID = "vision.segmentation.promptable_image"
	CapabilityVisionSegmentationVideo      CapabilityID = "vision.segmentation.promptable_video"
	CapabilityRetrievalEmbedText           CapabilityID = "retrieval.embed.text"
	CapabilityRetrievalEmbedMultimodal     CapabilityID = "retrieval.embed.multimodal"
	CapabilityRankRerank                   CapabilityID = "rank.rerank"
	CapabilitySafetyModeration             CapabilityID = "safety.moderation"
	CapabilityAgentToolUse                 CapabilityID = "agent.tool_use"
)

// ControlDescriptor describes a provider-specific control exposed for a capability.
type ControlDescriptor struct {
	Name        string `json:"name"`
	Type        string `json:"type"`
	Required    bool   `json:"required"`
	Description string `json:"description,omitempty"`
}

// CapabilityDescriptor describes one semantic capability and its I/O contract.
type CapabilityDescriptor struct {
	ID          CapabilityID        `json:"id"`
	Inputs      []InputType         `json:"inputs"`
	Outputs     []OutputType        `json:"outputs"`
	Interaction InteractionType     `json:"interaction"`
	Controls    []ControlDescriptor `json:"controls,omitempty"`
}

// CapabilityAdvertiser is implemented by providers that expose capability metadata.
type CapabilityAdvertiser interface {
	GatewayCapabilities() []CapabilityDescriptor
}

```


--| internal/features/ai/providers/interfaces/gateway/chat_options.go

```go
// chat_options.go defines chat request configuration contracts.
// internal/features/providers/interfaces/gateway/chat_options.go
package gateway

// ChatOptions configures a chat completion request.
type ChatOptions struct {
	Model       string   `json:"model"`
	Temperature float64  `json:"temperature,omitempty"`
	MaxTokens   int      `json:"maxTokens,omitempty"`
	Stream      bool     `json:"stream"`
	Tools       []Tool   `json:"tools,omitempty"`
	StopWords   []string `json:"stopWords,omitempty"`
}

```


--| internal/features/ai/providers/interfaces/gateway/chunk.go

```go
// chunk.go defines streaming chunk response contracts.
// internal/features/providers/interfaces/gateway/chunk.go
package gateway

// Chunk represents a piece of a streaming response.
type Chunk struct {
	Content      string      `json:"content,omitempty"`
	Model        string      `json:"model,omitempty"`
	ToolCalls    []ToolCall  `json:"toolCalls,omitempty"`
	FinishReason string      `json:"finishReason,omitempty"`
	Usage        *UsageStats `json:"usage,omitempty"`
	Error        error       `json:"-"`
}

```


--| internal/features/ai/providers/interfaces/gateway/image_types.go

```go
// image_types.go defines types related to image generation.
// internal/features/providers/interfaces/gateway/image_types.go
package gateway

// ImageGenerationOptions defines parameters for image generation requests.
type ImageGenerationOptions struct {
	Model          string `json:"model"`
	Prompt         string `json:"prompt"`
	N              int    `json:"n,omitempty"`              // Number of images to generate
	Size           string `json:"size,omitempty"`           // 256x256, 512x512, 1024x1024
	Quality        string `json:"quality,omitempty"`        // standard, hd
	Style          string `json:"style,omitempty"`          // vivid, natural
	ResponseFormat string `json:"response_format,omitempty"` // url, b64_json
	User           string `json:"user,omitempty"`
}

// ImageEditOptions defines parameters for image editing requests.
type ImageEditOptions struct {
	Model  string `json:"model"`
	Image  string `json:"image"`           // Path or Base64
	Mask   string `json:"mask,omitempty"`  // Path or Base64 (optional)
	Prompt string `json:"prompt"`
	N      int    `json:"n,omitempty"`
	Size   string `json:"size,omitempty"`
}

// ImageResult represents the result of an image generation request.
type ImageResult struct {
	Created int64         `json:"created"`
	Data    []ImageData   `json:"data"`
}

// ImageData contains the generated image info.
type ImageData struct {
	URL           string `json:"url,omitempty"`
	B64JSON       string `json:"b64_json,omitempty"`
	RevisedPrompt string `json:"revised_prompt,omitempty"`
}

```


--| internal/features/ai/providers/interfaces/gateway/messages.go

```go
// messages.go defines provider message role and payload contracts.
// internal/features/providers/interfaces/gateway/messages.go
package gateway

// Role represents the sender of a provider message.
type Role string

const (
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleTool      Role = "tool"
)

// ProviderMessage represents a provider-ready chat message.
type ProviderMessage struct {
	Role    Role   `json:"role"`
	Content string `json:"content"`
}

```


--| internal/features/ai/providers/interfaces/gateway/modality_types.go

```go
// modality_types.go defines gateway modality and interaction classification types.
// internal/features/providers/interfaces/gateway/modality_types.go
package gateway

// InputType identifies normalized gateway input wire types.
type InputType string

const (
	InputText             InputType = "text"
	InputImage            InputType = "image"
	InputAudio            InputType = "audio"
	InputVideo            InputType = "video"
	InputDocument         InputType = "document"
	InputStructuredPrompt InputType = "structured_prompt"
)

// OutputType identifies normalized gateway output wire types.
type OutputType string

const (
	OutputText              OutputType = "text"
	OutputEmbedding         OutputType = "embedding"
	OutputImage             OutputType = "image"
	OutputAudio             OutputType = "audio"
	OutputVideo             OutputType = "video"
	OutputMasks             OutputType = "masks"
	OutputBoxes             OutputType = "boxes"
	OutputKeypoints         OutputType = "keypoints"
	OutputTracks            OutputType = "tracks"
	OutputSafetyLabels      OutputType = "safety_labels"
	OutputToolCalls         OutputType = "tool_calls"
	OutputRankingScores     OutputType = "ranking_scores"
	OutputActionInvocations OutputType = "action_invocations"
)

// InteractionType identifies the runtime interaction pattern for a gateway capability.
type InteractionType string

const (
	InteractionSingle    InteractionType = "single"
	InteractionStreaming InteractionType = "streaming"
	InteractionDuplex    InteractionType = "duplex"
	InteractionBatch     InteractionType = "batch"
)

```


--| internal/features/ai/providers/interfaces/gateway/provider.go

```go
// provider.go defines the base gateway provider network contract.
// internal/features/providers/interfaces/gateway/provider.go
package gateway

import "context"

// Provider defines baseline network calls for model providers.
type Provider interface {
	Chat(ctx context.Context, messages []ProviderMessage, opts ChatOptions) (<-chan Chunk, error)
	GenerateImage(ctx context.Context, opts ImageGenerationOptions) (*ImageResult, error)
	EditImage(ctx context.Context, opts ImageEditOptions) (*ImageResult, error)
	TestConnection(ctx context.Context) error
}

```


--| internal/features/ai/providers/interfaces/gateway/tools.go

```go
// tools.go defines gateway tool schema and invocation contracts.
// internal/features/providers/interfaces/gateway/tools.go
package gateway

// Tool represents a function the AI can call.
type Tool struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Parameters  map[string]interface{} `json:"parameters"`
}

// ToolCall represents an AI request to execute a tool.
type ToolCall struct {
	ID        string                 `json:"id"`
	Name      string                 `json:"name"`
	Arguments map[string]interface{} `json:"arguments"`
}

```


--| internal/features/ai/providers/interfaces/gateway/usage.go

```go
// usage.go defines gateway token usage contracts.
// internal/features/providers/interfaces/gateway/usage.go
package gateway

// UsageStats contains token usage information.
type UsageStats struct {
	PromptTokens     int `json:"promptTokens"`
	CompletionTokens int `json:"completionTokens"`
	TotalTokens      int `json:"totalTokens"`
}

```


--| internal/features/ai/providers/interfaces/provider.go

```go
// provider.go defines provider transport contracts for backend adapters.
// internal/core/interfaces/ai/provider.go
package ai

import (
	"context"

	modelinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model/interfaces"
)

type ProviderModel = modelinterfaces.ProviderModel
type ProviderModelMutationInterface = modelinterfaces.ProviderModelMutationInterface

// ProviderInterface defines provider query capabilities shared across transports.
type ProviderInterface interface {
	GetProviders(ctx context.Context) ([]ProviderInfo, error)
	TestProvider(ctx context.Context, name string) error
}

// ProviderMutationInterface defines provider CRUD capabilities.
type ProviderMutationInterface interface {
	AddProvider(ctx context.Context, request AddProviderRequest) (ProviderInfo, error)
	UpdateProvider(ctx context.Context, request UpdateProviderRequest) (ProviderInfo, error)
	RemoveProvider(ctx context.Context, name string) error
	UpdateProviderCredentials(ctx context.Context, request UpdateProviderCredentialsRequest) error
}

// ProviderManagementInterface defines full provider and provider-model CRUD capabilities.
type ProviderManagementInterface interface {
	ProviderInterface
	ProviderMutationInterface
	ProviderModelMutationInterface
}

// ProviderInfo contains transport-safe provider status data.
type ProviderInfo struct {
	Name             string                    `json:"name"`
	DisplayName      string                    `json:"displayName"`
	CredentialFields []ProviderCredentialField `json:"credentialFields,omitempty"`
	CredentialValues map[string]string         `json:"credentialValues,omitempty"`
	Models           []ProviderModel           `json:"models"`
	Resources        []ProviderModel           `json:"resources"`
	IsConnected      bool                      `json:"isConnected"`
	IsActive         bool                      `json:"isActive"`
	Status           *ProviderStatus           `json:"status,omitempty"`
}

// AddProviderRequest contains inputs for creating a provider definition.
type AddProviderRequest struct {
	Name          string            `json:"name"`
	DisplayName   string            `json:"displayName"`
	Type          string            `json:"type"`
	BaseURL       string            `json:"baseUrl,omitempty"`
	DefaultModel  string            `json:"defaultModel,omitempty"`
	Credentials   map[string]string `json:"credentials,omitempty"`
	EnabledModels []ProviderModel   `json:"enabledModels,omitempty"`
}

// UpdateProviderRequest contains mutable provider definition fields.
type UpdateProviderRequest struct {
	Name         string  `json:"name"`
	DisplayName  *string `json:"displayName,omitempty"`
	BaseURL      *string `json:"baseUrl,omitempty"`
	DefaultModel *string `json:"defaultModel,omitempty"`
}

// UpdateProviderCredentialsRequest contains credential values to merge for a provider.
type UpdateProviderCredentialsRequest struct {
	ProviderName string            `json:"providerName"`
	Credentials  map[string]string `json:"credentials"`
}

// ProviderCredentialField describes a provider input requirement.
type ProviderCredentialField struct {
	Name        string `json:"name"`
	Label       string `json:"label"`
	Required    bool   `json:"required"`
	Secret      bool   `json:"secret"`
	Placeholder string `json:"placeholder,omitempty"`
	Help        string `json:"help,omitempty"`
}

// ProviderStatus describes the last known provider health check.
type ProviderStatus struct {
	OK        bool   `json:"ok"`
	Message   string `json:"message,omitempty"`
	CheckedAt int64  `json:"checkedAt"`
}

```


--| internal/features/ai/providers/provider/events.go

```go
// events.go registers strongly typed provider event signals for frontend transport.
// internal/features/ai/providers/provider/events.go
package provider

import coreevents "github.com/MadeByDoug/wls-chatbot/internal/core/events"

var SignalProvidersUpdated = coreevents.MustRegister[coreevents.EmptyPayload]("providers:updated")

```


--| internal/features/ai/providers/provider/orchestration.go

```go
// orchestration.go orchestrates settings provider workflows and event emission.
// internal/features/settings/app/provider/orchestration.go
package provider

import (
	"context"
	"fmt"
	"strings"
	"sync"

	coreevents "github.com/MadeByDoug/wls-chatbot/internal/core/events"
)

// Orchestrator orchestrates provider workflows and event emission.
type Orchestrator struct {
	providers *Service
	emitter   coreevents.Bus
	activeMu  sync.Mutex
	activeRun bool
	ensureMu  sync.Mutex
}

// NewOrchestrator creates a provider orchestrator with required dependencies.
func NewOrchestrator(service *Service, _ SecretStore, emitter coreevents.Bus) *Orchestrator {

	return &Orchestrator{providers: service, emitter: emitter}
}

// GetProviders returns all available providers with their status.
func (o *Orchestrator) GetProviders() []Info {

	o.ensureActiveProviderAsync()
	return o.providers.List()
}

// ConnectProvider connects and configures a provider with the given credentials.
func (o *Orchestrator) ConnectProvider(ctx context.Context, name string, credentials ProviderCredentials) (Info, error) {

	info, err := o.providers.Connect(ctx, name, credentials)
	if err == nil {
		o.emitProvidersUpdated()
	}
	return info, err
}

// ConfigureProvider updates a provider's credentials without full connection flow.
func (o *Orchestrator) ConfigureProvider(name string, credentials ProviderCredentials) error {

	return o.providers.Configure(name, credentials)
}

// DisconnectProvider removes a provider's credentials and resets its state.
func (o *Orchestrator) DisconnectProvider(name string) error {

	previousActive := o.providers.GetActiveProvider()
	previousActiveName := ""
	if previousActive != nil {
		previousActiveName = previousActive.Name()
	}

	err := o.providers.Disconnect(name)
	if err != nil {
		return err
	}

	currentActive := o.providers.GetActiveProvider()
	if previousActiveName == name && currentActive != nil && currentActive.Name() != name {
		o.emitProviderSwitchToast(previousActive, currentActive)
	}

	o.emitProvidersUpdated()
	return nil
}

// SetActiveProvider sets the active provider by name.
func (o *Orchestrator) SetActiveProvider(name string) bool {

	ok := o.providers.SetActive(name)
	if ok {
		o.emitProvidersUpdated()
	}
	return ok
}

// TestProvider tests the connection to a provider.
func (o *Orchestrator) TestProvider(ctx context.Context, name string) error {

	return o.providers.TestConnection(ctx, name)
}

// GenerateImage generates an image through a configured provider.
func (o *Orchestrator) GenerateImage(ctx context.Context, name string, options ImageGenerationOptions) (*ImageResult, error) {

	prov, err := o.providerByName(name)
	if err != nil {
		return nil, err
	}
	if options.N <= 0 {
		options.N = 1
	}
	return prov.GenerateImage(ctx, options)
}

// EditImage edits an image through a configured provider.
func (o *Orchestrator) EditImage(ctx context.Context, name string, options ImageEditOptions) (*ImageResult, error) {

	prov, err := o.providerByName(name)
	if err != nil {
		return nil, err
	}
	if options.N <= 0 {
		options.N = 1
	}
	return prov.EditImage(ctx, options)
}

// RefreshProviderResources fetches the latest resources from a provider.
func (o *Orchestrator) RefreshProviderResources(ctx context.Context, name string) error {

	err := o.providers.RefreshResources(ctx, name)
	if err == nil {
		o.emitProvidersUpdated()
	}
	return err
}

// GetActiveProvider returns the currently active provider, if any.
func (o *Orchestrator) GetActiveProvider() *Info {

	o.ensureActiveProvider()
	infos := o.providers.List()
	for i := range infos {
		if infos[i].IsActive {
			info := infos[i]
			return &info
		}
	}
	return nil
}

// emitProvidersUpdated publishes a provider update event.
func (o *Orchestrator) emitProvidersUpdated() {

	coreevents.Emit(o.emitter, SignalProvidersUpdated, coreevents.EmptyPayload{})
}

// emitProviderSwitchToast notifies the frontend about an automatic provider switch.
func (o *Orchestrator) emitProviderSwitchToast(previousActive, currentActive Provider) {

	if o.emitter == nil || currentActive == nil {
		return
	}

	previousName := ""
	if previousActive != nil {
		previousName = previousActive.DisplayName()
	}

	message := fmt.Sprintf("Active provider switched to %s.", currentActive.DisplayName())
	if previousName != "" {
		message = fmt.Sprintf("Active provider switched from %s to %s.", previousName, currentActive.DisplayName())
	}

	coreevents.Emit(o.emitter, coreevents.SignalToast, coreevents.ToastPayload{
		Type:    "info",
		Title:   "Provider switched",
		Message: message,
	})
}

// ensureActiveProvider selects an active provider with valid credentials.
func (o *Orchestrator) ensureActiveProvider() {

	o.ensureMu.Lock()
	defer o.ensureMu.Unlock()

	infos := o.providers.List()
	active := o.providers.GetActiveProvider()
	if active != nil {
		for _, info := range infos {
			if info.Name != active.Name() || !info.IsConnected {
				continue
			}
			if err := o.providers.EnsureProviderConfigured(info.Name); err == nil {
				return
			}
			break
		}
	}
	for _, info := range infos {
		if !info.IsConnected {
			continue
		}
		if err := o.providers.EnsureProviderConfigured(info.Name); err != nil {
			continue
		}
		if o.providers.SetActive(info.Name) {
			return
		}
	}
}

// ensureActiveProviderAsync de-duplicates background active-provider checks.
func (o *Orchestrator) ensureActiveProviderAsync() {

	o.activeMu.Lock()
	if o.activeRun {
		o.activeMu.Unlock()
		return
	}
	o.activeRun = true
	o.activeMu.Unlock()

	go func() {
		defer func() {
			o.activeMu.Lock()
			o.activeRun = false
			o.activeMu.Unlock()
		}()
		o.ensureActiveProvider()
	}()
}

// providerByName resolves and configures a provider before runtime operations.
func (o *Orchestrator) providerByName(name string) (Provider, error) {

	trimmed := strings.TrimSpace(name)
	if trimmed == "" {
		return nil, fmt.Errorf("provider name required")
	}

	resolvedName := trimmed
	infos := o.providers.List()
	for _, info := range infos {
		if strings.EqualFold(info.Name, trimmed) {
			resolvedName = info.Name
			break
		}
	}

	if err := o.providers.EnsureProviderConfigured(resolvedName); err != nil {
		return nil, err
	}

	prov := o.providers.GetProvider(resolvedName)
	if prov == nil {
		return nil, fmt.Errorf("provider not found: %s", name)
	}
	return prov, nil
}

```


--| internal/features/ai/providers/provider/service.go

```go
// service.go manages provider connections, resources, and status for settings.
// internal/features/settings/app/provider/service.go
package provider

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
)

// Info represents provider information for the frontend.
type Info struct {
	Name             string            `json:"name"`
	DisplayName      string            `json:"displayName"`
	CredentialFields []CredentialField `json:"credentialFields,omitempty"`
	CredentialValues map[string]string `json:"credentialValues,omitempty"`
	Models           []Model           `json:"models"`
	Resources        []Model           `json:"resources"`
	IsConnected      bool              `json:"isConnected"`
	IsActive         bool              `json:"isActive"`
	Status           *Status           `json:"status,omitempty"`
}

// Status represents the last known health check for a provider.
type Status struct {
	OK        bool   `json:"ok"`
	Message   string `json:"message,omitempty"`
	CheckedAt int64  `json:"checkedAt"`
}

// resourceLister is implemented by providers that can list resources.
type resourceLister interface {
	ListResources(ctx context.Context) ([]Model, error)
}

var errNoResources = errors.New("no resources returned from provider")

// Service handles provider management logic.
type Service struct {
	registry          Registry
	resources         map[string][]Model
	resourceUpdatedAt map[string]int64
	cache             Cache
	enabledModelIDs   map[string][]string
	updateFrequency   map[string]time.Duration
	status            map[string]Status
	refreshing        map[string]bool
	mu                sync.RWMutex
	inputsStore       InputsStore
	secrets           SecretStore
	logger            Logger
	providerOpsMu     sync.Mutex
}

// validateProvider tests connectivity and updates resources when supported.
func (s *Service) validateProvider(ctx context.Context, name string, p Provider) (bool, error) {

	if lister, ok := p.(resourceLister); ok {
		resources, err := lister.ListResources(ctx)
		if err != nil {
			return true, err
		}
		if len(resources) == 0 {
			return true, errNoResources
		}
		s.SetResources(name, resources)
		return true, nil
	}
	if err := p.TestConnection(ctx); err != nil {
		return false, err
	}
	return false, nil
}

// NewService creates a new provider service.
func NewService(registry Registry, cache Cache, secrets SecretStore, inputs InputsStore, updateFrequency map[string]time.Duration, logger Logger) *Service {

	s := &Service{
		registry:          registry,
		resources:         make(map[string][]Model),
		resourceUpdatedAt: make(map[string]int64),
		cache:             cache,
		enabledModelIDs:   captureEnabledModelIDs(registry),
		updateFrequency:   copyUpdateFrequency(updateFrequency),
		status:            make(map[string]Status),
		refreshing:        make(map[string]bool),
		inputsStore:       inputs,
		secrets:           secrets,
		logger:            logger,
	}
	s.loadCache()
	s.applyEnabledModelsFromCache()
	return s
}

// loadCache loads cached provider resources from disk.
func (s *Service) loadCache() {

	if s.cache == nil {
		return
	}
	snapshot, err := s.cache.Load()
	if err != nil {
		return
	}

	for name, entry := range snapshot {
		if entry.Models != nil {
			s.resources[name] = entry.Models
		}
		if entry.UpdatedAt > 0 {
			s.resourceUpdatedAt[name] = entry.UpdatedAt
		}
	}
}

// applyEnabledModelsFromCache applies cached resources to enabled model lists.
func (s *Service) applyEnabledModelsFromCache() {

	if s.registry == nil {
		return
	}
	for _, prov := range s.registry.List() {
		name := prov.Name()
		resources := s.GetResources(name)
		s.applyEnabledModels(name, resources)
	}
}

// applyEnabledModels updates provider models using enabled IDs and available resources.
func (s *Service) applyEnabledModels(name string, resources []Model) {

	enabledIDs := s.enabledModelIDs[name]
	if p := s.registry.Get(name); p != nil {
		if len(resources) == 0 {
			_ = p.Configure(Config{Models: buildFallbackModels(enabledIDs)})
			return
		}
		if len(enabledIDs) == 0 {
			_ = p.Configure(Config{Models: resources})
			return
		}
		available := indexModelsByID(resources)
		_ = p.Configure(Config{Models: selectModelsByID(enabledIDs, available)})
	}
}

// captureEnabledModelIDs extracts enabled model IDs from configured providers.
func captureEnabledModelIDs(registry Registry) map[string][]string {

	result := make(map[string][]string)
	if registry == nil {
		return result
	}
	for _, prov := range registry.List() {
		result[prov.Name()] = extractModelIDs(prov.Models())
	}
	return result
}

// extractModelIDs normalizes model IDs from configured models.
func extractModelIDs(models []Model) []string {

	seen := make(map[string]struct{}, len(models))
	ids := make([]string, 0, len(models))
	for _, model := range models {
		trimmed := strings.TrimSpace(model.ID)
		if trimmed == "" {
			continue
		}
		if _, ok := seen[trimmed]; ok {
			continue
		}
		seen[trimmed] = struct{}{}
		ids = append(ids, trimmed)
	}
	return ids
}

// providerCredentialFields returns the credential schema for a provider.
func (s *Service) providerCredentialFields(p Provider) []CredentialField {

	if p == nil {
		return nil
	}
	return p.CredentialFields()
}

// loadProviderInputs returns stored non-secret inputs for a provider.
func (s *Service) loadProviderInputs(name string) ProviderCredentials {

	if s.inputsStore == nil {
		return nil
	}
	inputs, err := s.inputsStore.LoadProviderInputs(name)
	if err != nil {
		s.logWarn("Failed to load provider inputs", err, LogField{Key: "provider", Value: name})
		return nil
	}
	return inputs
}

// loadProviderSecrets returns stored secret values for a provider.
func (s *Service) loadProviderSecrets(name string, fields []CredentialField) ProviderCredentials {

	if s.secrets == nil {
		return nil
	}

	credentials := make(ProviderCredentials)
	for _, field := range fields {
		if !field.Secret {
			continue
		}
		value, err := s.secrets.GetProviderSecret(name, field.Name)
		if err != nil || strings.TrimSpace(value) == "" {
			continue
		}
		credentials[field.Name] = value
	}

	if len(credentials) == 0 {
		return nil
	}
	return credentials
}

// mergeCredentialValues combines stored and incoming credential values.
func mergeCredentialValues(base, override ProviderCredentials) ProviderCredentials {

	if len(base) == 0 && len(override) == 0 {
		return nil
	}

	merged := make(ProviderCredentials)
	for key, value := range base {
		trimmed := strings.TrimSpace(value)
		if trimmed == "" {
			continue
		}
		merged[key] = trimmed
	}
	for key, value := range override {
		trimmed := strings.TrimSpace(value)
		if trimmed == "" {
			continue
		}
		merged[key] = trimmed
	}

	if len(merged) == 0 {
		return nil
	}
	return merged
}

// validateRequiredCredentials verifies all required fields are present.
func validateRequiredCredentials(fields []CredentialField, credentials ProviderCredentials) error {

	for _, field := range fields {
		if !field.Required {
			continue
		}
		if strings.TrimSpace(credentials[field.Name]) == "" {
			label := field.Label
			if label == "" {
				label = field.Name
			}
			return fmt.Errorf("missing required credential: %s", label)
		}
	}
	return nil
}

// filterCredentialValues returns credential values matching the secret flag.
func filterCredentialValues(fields []CredentialField, credentials ProviderCredentials, secret bool) ProviderCredentials {

	if len(credentials) == 0 {
		return nil
	}

	filtered := make(ProviderCredentials)
	for _, field := range fields {
		if field.Secret != secret {
			continue
		}
		value := strings.TrimSpace(credentials[field.Name])
		if value == "" {
			continue
		}
		filtered[field.Name] = value
	}

	if len(filtered) == 0 {
		return nil
	}
	return filtered
}

// resolveCredentials merges stored and incoming credentials with validation.
func (s *Service) resolveCredentials(name string, fields []CredentialField, input ProviderCredentials) (ProviderCredentials, error) {

	stored := mergeCredentialValues(s.loadProviderInputs(name), s.loadProviderSecrets(name, fields))
	merged := mergeCredentialValues(stored, input)
	if err := validateRequiredCredentials(fields, merged); err != nil {
		return nil, err
	}
	return merged, nil
}

// persistCredentials saves provided credential values to storage.
func (s *Service) persistCredentials(name string, fields []CredentialField, input ProviderCredentials) error {

	if len(input) == 0 {
		return nil
	}

	var secretUpdates ProviderCredentials
	var inputUpdates ProviderCredentials

	for _, field := range fields {
		value, ok := input[field.Name]
		if !ok {
			continue
		}
		trimmed := strings.TrimSpace(value)
		if trimmed == "" {
			continue
		}
		if field.Secret {
			if secretUpdates == nil {
				secretUpdates = make(ProviderCredentials)
			}
			secretUpdates[field.Name] = trimmed
		} else {
			if providercore.IsSensitiveCredentialName(field.Name) {
				return fmt.Errorf("credential field %q must be stored as secret", field.Name)
			}
			if inputUpdates == nil {
				inputUpdates = make(ProviderCredentials)
			}
			inputUpdates[field.Name] = trimmed
		}
	}

	if len(secretUpdates) > 0 {
		if s.secrets == nil {
			return fmt.Errorf("secret store not configured")
		}
		for fieldName, value := range secretUpdates {
			if err := s.secrets.SaveProviderSecret(name, fieldName, value); err != nil {
				return err
			}
		}
	}

	if len(inputUpdates) > 0 {
		if s.inputsStore == nil {
			return fmt.Errorf("config store not configured")
		}
		mergedInputs := mergeCredentialValues(s.loadProviderInputs(name), inputUpdates)
		if err := s.inputsStore.SaveProviderInputs(name, mergedInputs); err != nil {
			return err
		}
	}

	return nil
}

// clearStoredCredentials removes stored inputs and secrets for a provider.
func (s *Service) clearStoredCredentials(name string, fields []CredentialField) error {

	if s.inputsStore != nil {
		if err := s.inputsStore.SaveProviderInputs(name, nil); err != nil {
			return err
		}
	}
	if s.secrets == nil {
		return nil
	}
	for _, field := range fields {
		if !field.Secret {
			continue
		}
		_ = s.secrets.DeleteProviderSecret(name, field.Name)
	}
	return nil
}

// isProviderConfigured returns true when required credential fields are present.
func (s *Service) isProviderConfigured(name string, fields []CredentialField) bool {

	credentials := mergeCredentialValues(s.loadProviderInputs(name), s.loadProviderSecrets(name, fields))
	return validateRequiredCredentials(fields, credentials) == nil
}

// refreshResourcesIfStale launches a background refresh when cache is outdated.
func (s *Service) refreshResourcesIfStale(name string) {

	if !s.shouldRefreshResources(name) {
		return
	}
	if s.registry == nil {
		return
	}
	if !s.isProviderConfigured(name, s.providerCredentialFields(s.registry.Get(name))) {
		return
	}
	if !s.markRefreshing(name) {
		return
	}

	go func() {
		defer s.clearRefreshing(name)
		ctx, cancel := context.WithTimeout(context.Background(), 12*time.Second)
		defer cancel()
		if err := s.RefreshResources(ctx, name); err != nil {
			s.logWarn("Failed to refresh stale resources", err, LogField{Key: "provider", Value: name})
		}
	}()
}

// shouldRefreshResources determines if cached resources are stale.
func (s *Service) shouldRefreshResources(name string) bool {

	frequency := s.getUpdateFrequency(name)
	if frequency <= 0 {
		return false
	}
	lastUpdated := s.getResourceUpdatedAt(name)
	if lastUpdated == 0 {
		return true
	}
	lastUpdateTime := time.UnixMilli(lastUpdated)
	return time.Since(lastUpdateTime) >= frequency
}

// getUpdateFrequency returns the configured update cadence for a provider.
func (s *Service) getUpdateFrequency(name string) time.Duration {

	if s.updateFrequency == nil {
		return 0
	}
	return s.updateFrequency[name]
}

// getResourceUpdatedAt returns the last update timestamp for cached resources.
func (s *Service) getResourceUpdatedAt(name string) int64 {

	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.resourceUpdatedAt[name]
}

// markRefreshing marks a provider as having an in-flight refresh.
func (s *Service) markRefreshing(name string) bool {

	s.mu.Lock()
	defer s.mu.Unlock()
	if s.refreshing[name] {
		return false
	}
	s.refreshing[name] = true
	return true
}

// clearRefreshing clears the in-flight refresh marker.
func (s *Service) clearRefreshing(name string) {

	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.refreshing, name)
}

// ensureProviderConfiguredLocked applies stored credentials while providerOpsMu is held.
func (s *Service) ensureProviderConfiguredLocked(name string) error {

	if s.registry == nil {
		return nil
	}
	p := s.registry.Get(name)
	if p == nil {
		return fmt.Errorf("provider not found: %s", name)
	}
	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, nil)
	if err != nil {
		return err
	}
	if len(resolved) == 0 {
		return nil
	}
	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		return err
	}
	return nil
}

// EnsureProviderConfigured applies persisted credentials for a provider under serialization lock.
func (s *Service) EnsureProviderConfigured(name string) error {

	s.providerOpsMu.Lock()
	defer s.providerOpsMu.Unlock()
	return s.ensureProviderConfiguredLocked(name)
}

// List returns all available providers with their status.
func (s *Service) List() []Info {

	if s.registry == nil {
		return nil
	}
	providers := s.registry.List()
	active := s.registry.GetActive()

	info := make([]Info, len(providers))
	for i, p := range providers {
		// Trigger stale-check; method schedules background refresh only when needed.
		s.refreshResourcesIfStale(p.Name())
		fields := s.providerCredentialFields(p)
		isConfigured := s.isProviderConfigured(p.Name(), fields)
		hasHealthyStatus := s.hasSuccessfulStatus(p.Name())
		// Skip loading inputs during list to avoid blocking - credentials are only needed on connect/configure
		info[i] = Info{
			Name:             p.Name(),
			DisplayName:      p.DisplayName(),
			CredentialFields: fields,
			CredentialValues: nil, // Load on demand, not during list
			Models:           p.Models(),
			Resources:        s.GetResources(p.Name()),
			IsConnected:      isConfigured || hasHealthyStatus,
			IsActive:         active != nil && active.Name() == p.Name(),
			Status:           s.GetStatus(p.Name()),
		}
	}
	return info
}

// Connect configures, validates, and persists a provider connection.
func (s *Service) Connect(ctx context.Context, name string, credentials ProviderCredentials) (Info, error) {

	s.providerOpsMu.Lock()
	defer s.providerOpsMu.Unlock()

	s.logInfo("Connecting provider", LogField{Key: "provider", Value: name})
	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		s.logWarn("Provider not found during connect", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, credentials)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		s.logWarn("Missing required credentials", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to configure provider", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	if ctx == nil {
		ctx = context.Background()
	}
	// Use a timeout for the connection test/list
	ctx, cancel := context.WithTimeout(ctx, 12*time.Second)
	defer cancel()

	usedLister, err := s.validateProvider(ctx, name, p)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		if usedLister {
			if errors.Is(err, errNoResources) {
				s.logWarn("No resources returned", err, LogField{Key: "provider", Value: name})
			} else {
				s.logError("Failed to list resources", err, LogField{Key: "provider", Value: name})
			}
		} else {
			s.logError("Connection test failed", err, LogField{Key: "provider", Value: name})
		}
		return Info{}, err
	}

	if err := s.persistCredentials(name, fields, credentials); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to save credentials", err, LogField{Key: "provider", Value: name})
		return Info{}, err
	}

	s.registry.SetActive(name)
	s.logInfo("Provider connected successfully", LogField{Key: "provider", Value: name})

	active := s.registry.GetActive()
	s.SetStatus(name, true, "")
	inputs := s.loadProviderInputs(p.Name())
	return Info{
		Name:             p.Name(),
		DisplayName:      p.DisplayName(),
		CredentialFields: fields,
		CredentialValues: filterCredentialValues(fields, inputs, false),
		Models:           p.Models(),
		Resources:        s.GetResources(p.Name()),
		IsConnected:      s.isProviderConfigured(p.Name(), fields),
		IsActive:         active != nil && active.Name() == p.Name(),
		Status:           s.GetStatus(p.Name()),
	}, nil
}

// Disconnect removes a provider's credentials and resets its state.
func (s *Service) Disconnect(name string) error {

	s.providerOpsMu.Lock()
	defer s.providerOpsMu.Unlock()

	s.logInfo("Disconnecting provider", LogField{Key: "provider", Value: name})
	fields := s.providerCredentialFields(s.registry.Get(name))
	if err := s.clearStoredCredentials(name, fields); err != nil {
		s.logError("Failed to remove credentials", err, LogField{Key: "provider", Value: name})
		return fmt.Errorf("failed to remove credentials: %w", err)
	}

	// 2. Clear from registry/memory
	p := s.registry.Get(name)
	if p != nil {
		clear := make(ProviderCredentials)
		for _, field := range fields {
			clear[field.Name] = ""
		}
		_ = p.Configure(Config{Credentials: clear})
	}

	// 3. Clear cached resources
	s.SetResources(name, nil)
	s.ClearStatus(name)

	// 4. Update active provider if needed
	active := s.registry.GetActive()
	if active != nil && active.Name() == name {
		nextActive := s.selectNextActiveProvider(name)
		if nextActive == "" {
			_ = s.registry.SetActive("")
		} else if s.registry.SetActive(nextActive) {
			if err := s.ensureProviderConfiguredLocked(nextActive); err != nil {
				_ = s.registry.SetActive("")
			}
		} else {
			_ = s.registry.SetActive("")
		}
	}

	return nil
}

// selectNextActiveProvider finds the next connected provider after the given name.
func (s *Service) selectNextActiveProvider(disconnected string) string {

	if s.registry == nil {
		return ""
	}

	providers := s.registry.List()
	if len(providers) == 0 {
		return ""
	}

	startIndex := 0
	for i, p := range providers {
		if p != nil && p.Name() == disconnected {
			startIndex = i + 1
			break
		}
	}

	for offset := 0; offset < len(providers); offset++ {
		index := (startIndex + offset) % len(providers)
		candidate := providers[index]
		if candidate == nil {
			continue
		}
		name := candidate.Name()
		if name == "" || name == disconnected {
			continue
		}
		if s.isProviderConfigured(name, s.providerCredentialFields(candidate)) {
			return name
		}
	}

	return ""
}

// Configure updates and persists provider credentials while refreshing status.
func (s *Service) Configure(name string, credentials ProviderCredentials) error {

	s.providerOpsMu.Lock()
	defer s.providerOpsMu.Unlock()

	s.logInfo("Configuring provider", LogField{Key: "provider", Value: name})
	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		s.logWarn("Provider not found during configure", err, LogField{Key: "provider", Value: name})
		return err
	}
	trimmedInput := mergeCredentialValues(nil, credentials)
	if len(trimmedInput) == 0 {
		err := fmt.Errorf("credentials required for provider: %s", name)
		s.SetStatus(name, false, err.Error())
		s.logWarn("Empty credentials during configure", err, LogField{Key: "provider", Value: name})
		return err
	}
	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, credentials)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		s.logWarn("Missing required credentials", err, LogField{Key: "provider", Value: name})
		return err
	}
	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to configure provider", err, LogField{Key: "provider", Value: name})
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 12*time.Second)
	defer cancel()

	usedLister, err := s.validateProvider(ctx, name, p)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		if usedLister {
			if errors.Is(err, errNoResources) {
				s.logWarn("No resources returned", err, LogField{Key: "provider", Value: name})
			} else {
				s.logError("Failed to list resources", err, LogField{Key: "provider", Value: name})
			}
		} else {
			s.logError("Connection test failed", err, LogField{Key: "provider", Value: name})
		}
		return err
	}

	if err := s.persistCredentials(name, fields, credentials); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logError("Failed to save credentials", err, LogField{Key: "provider", Value: name})
		return err
	}

	s.SetStatus(name, true, "")
	return nil
}

// SetActive sets the active provider.
func (s *Service) SetActive(name string) bool {

	s.providerOpsMu.Lock()
	defer s.providerOpsMu.Unlock()

	s.logInfo("Setting active provider", LogField{Key: "provider", Value: name})
	return s.registry.SetActive(name)
}

// TestConnection tests the connection to a provider.
func (s *Service) TestConnection(ctx context.Context, name string) error {

	s.providerOpsMu.Lock()
	defer s.providerOpsMu.Unlock()
	return s.testConnectionLocked(ctx, name)
}

// testConnectionLocked tests provider connectivity while providerOpsMu is held.
func (s *Service) testConnectionLocked(ctx context.Context, name string) error {

	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		return err
	}
	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, nil)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	if ctx == nil {
		ctx = context.Background()
	}
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	if err := p.TestConnection(ctx); err != nil {
		s.SetStatus(name, false, err.Error())
		s.logWarn("Test connection failed", err, LogField{Key: "provider", Value: name})
		return err
	}
	s.SetStatus(name, true, "")
	return nil
}

// RefreshResources fetches the latest resources from the provider.
func (s *Service) RefreshResources(ctx context.Context, name string) error {

	s.providerOpsMu.Lock()
	defer s.providerOpsMu.Unlock()

	s.logDebug("Refreshing resources", LogField{Key: "provider", Value: name})
	if ctx == nil {
		ctx = context.Background()
	}
	if _, hasDeadline := ctx.Deadline(); !hasDeadline {
		timeoutCtx, cancel := context.WithTimeout(ctx, 12*time.Second)
		defer cancel()
		ctx = timeoutCtx
	}
	p := s.registry.Get(name)
	if p == nil {
		err := fmt.Errorf("provider not found: %s", name)
		s.SetStatus(name, false, err.Error())
		return err
	}

	fields := s.providerCredentialFields(p)
	resolved, err := s.resolveCredentials(name, fields, nil)
	if err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	if err := p.Configure(Config{Credentials: resolved}); err != nil {
		s.SetStatus(name, false, err.Error())
		return err
	}
	if lister, ok := p.(resourceLister); ok {
		resources, err := lister.ListResources(ctx)
		if err != nil {
			s.SetStatus(name, false, err.Error())
			s.logError("Failed to refresh resources", err, LogField{Key: "provider", Value: name})
			return err
		}
		if len(resources) == 0 {
			err := fmt.Errorf("no resources returned from provider")
			s.SetStatus(name, false, err.Error())
			return err
		}
		s.SetResources(name, resources)
		s.SetStatus(name, true, "")
		return nil
	}
	if err := s.testConnectionLocked(ctx, name); err != nil {
		return err
	}
	return nil
}

// GetResources returns a copy of cached resources for a provider.
func (s *Service) GetResources(name string) []Model {

	s.mu.RLock()
	resources := s.resources[name]
	s.mu.RUnlock()

	if resources == nil {
		return nil
	}

	cloned := make([]Model, len(resources))
	copy(cloned, resources)
	return cloned
}

// SetResources updates cached resources for a provider.
func (s *Service) SetResources(name string, resources []Model) {

	s.mu.Lock()
	if resources == nil {
		delete(s.resources, name)
		delete(s.resourceUpdatedAt, name)
	} else {
		s.resources[name] = resources
		s.resourceUpdatedAt[name] = time.Now().UnixMilli()
	}
	snapshot := s.buildCacheSnapshotLocked()
	s.mu.Unlock()

	if s.cache != nil {
		_ = s.cache.Save(snapshot)
	}
	s.applyEnabledModels(name, resources)
}

// buildCacheSnapshotLocked generates the cache snapshot from locked state.
func (s *Service) buildCacheSnapshotLocked() CacheSnapshot {

	snapshot := make(CacheSnapshot, len(s.resources))
	for name, resources := range s.resources {
		snapshot[name] = CacheEntry{
			UpdatedAt: s.resourceUpdatedAt[name],
			Models:    resources,
		}
	}
	return snapshot
}

// indexModelsByID builds a lookup map for models.
func indexModelsByID(models []Model) map[string]Model {

	index := make(map[string]Model, len(models))
	for _, model := range models {
		if model.ID == "" {
			continue
		}
		index[model.ID] = model
	}
	return index
}

// selectModelsByID returns models in the order of provided IDs.
func selectModelsByID(ids []string, available map[string]Model) []Model {

	selected := make([]Model, 0, len(ids))
	for _, id := range ids {
		if model, ok := available[id]; ok {
			selected = append(selected, model)
		}
	}
	return selected
}

// buildFallbackModels constructs model structs from IDs.
func buildFallbackModels(ids []string) []Model {

	models := make([]Model, 0, len(ids))
	for _, id := range ids {
		models = append(models, Model{
			ID:   id,
			Name: id,
		})
	}
	return models
}

// copyUpdateFrequency clones the update frequency map.
func copyUpdateFrequency(input map[string]time.Duration) map[string]time.Duration {

	if input == nil {
		return nil
	}
	result := make(map[string]time.Duration, len(input))
	for name, value := range input {
		result[name] = value
	}
	return result
}

// GetStatus returns the last recorded status for a provider.
func (s *Service) GetStatus(name string) *Status {

	s.mu.RLock()
	defer s.mu.RUnlock()
	status, ok := s.status[name]
	if !ok {
		return nil
	}
	result := status
	return &result
}

// hasSuccessfulStatus returns true if the provider has a cached successful status.
func (s *Service) hasSuccessfulStatus(name string) bool {

	s.mu.RLock()
	defer s.mu.RUnlock()
	status, ok := s.status[name]
	return ok && status.OK
}

// SetStatus records a provider status check result.
func (s *Service) SetStatus(name string, ok bool, message string) {

	s.mu.Lock()
	defer s.mu.Unlock()
	s.status[name] = Status{
		OK:        ok,
		Message:   message,
		CheckedAt: time.Now().UnixMilli(),
	}
}

// ClearStatus removes any stored status for a provider.
func (s *Service) ClearStatus(name string) {

	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.status, name)
}

// GetActiveProvider returns the currently active provider.
func (s *Service) GetActiveProvider() Provider {

	if s.registry == nil {
		return nil
	}
	return s.registry.GetActive()
}

// GetProvider returns a provider by name.
func (s *Service) GetProvider(name string) Provider {

	if s.registry == nil {
		return nil
	}
	return s.registry.Get(name)
}

func (s *Service) logDebug(message string, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Debug(message, fields...)
}

func (s *Service) logInfo(message string, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Info(message, fields...)
}

func (s *Service) logWarn(message string, err error, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Warn(message, err, fields...)
}

func (s *Service) logError(message string, err error, fields ...LogField) {

	if s.logger == nil {
		return
	}
	s.logger.Error(message, err, fields...)
}

```


--| internal/features/ai/providers/provider/types.go

```go
// types.go re-exports provider contracts for the settings provider app service.
// internal/features/settings/app/provider/types.go
package provider

import (
	coreports "github.com/MadeByDoug/wls-chatbot/internal/core/logger"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providergateway "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/gateway"
)

type Provider = providercore.Provider
type Config = providercore.ProviderConfig
type ProviderMessage = providergateway.ProviderMessage
type ChatOptions = providergateway.ChatOptions
type Role = providergateway.Role
type Model = providercore.Model
type Tool = providergateway.Tool
type Chunk = providergateway.Chunk
type UsageStats = providergateway.UsageStats
type ImageGenerationOptions = providergateway.ImageGenerationOptions
type ImageEditOptions = providergateway.ImageEditOptions
type ImageResult = providergateway.ImageResult
type ImageData = providergateway.ImageData
type CredentialField = providercore.CredentialField
type ProviderCredentials = providercore.ProviderCredentials

type Registry = providercore.ProviderRegistry
type Cache = providercore.ProviderCache
type CacheSnapshot = providercore.ProviderCacheSnapshot
type CacheEntry = providercore.ProviderCacheEntry
type SecretStore = providercore.SecretStore
type InputsStore = providercore.ProviderInputsStore
type Logger = coreports.Logger
type LogField = coreports.LogField

```


--| internal/features/ai/providers/provider_service.go

```go
// provider_service.go provides provider backend operations.
// internal/core/backend/ai/provider_service.go
package providers

import (
	"context"
	"fmt"
	"strings"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces"
	provider "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/provider"
)

// ProviderOperations defines provider actions required by the provider backend service.
type ProviderOperations interface {
	GetProviders() []provider.Info
	TestProvider(ctx context.Context, name string) error
	ConnectProvider(ctx context.Context, name string, credentials provider.ProviderCredentials) (provider.Info, error)
	ConfigureProvider(name string, credentials provider.ProviderCredentials) error
	DisconnectProvider(name string) error
}

// ProviderService handles provider operations for transport adapters.
type ProviderService struct {
	providers ProviderOperations
}

var _ aiinterfaces.ProviderInterface = (*ProviderService)(nil)
var _ aiinterfaces.ProviderMutationInterface = (*ProviderService)(nil)

// NewProviderService creates a provider backend service from feature-level dependencies.
func NewProviderService(providers ProviderOperations) *ProviderService {

	return &ProviderService{providers: providers}
}

// GetProviders returns configured provider statuses.
func (s *ProviderService) GetProviders(context.Context) ([]aiinterfaces.ProviderInfo, error) {

	if s.providers == nil {
		return nil, fmt.Errorf("backend service: providers not configured")
	}
	return mapProviderInfos(s.providers.GetProviders()), nil
}

// TestProvider checks connectivity for a provider.
func (s *ProviderService) TestProvider(ctx context.Context, name string) error {

	if s.providers == nil {
		return fmt.Errorf("backend service: providers not configured")
	}
	return s.providers.TestProvider(ctx, name)
}

// AddProvider configures credentials for a known provider and returns the updated provider state.
func (s *ProviderService) AddProvider(ctx context.Context, request aiinterfaces.AddProviderRequest) (aiinterfaces.ProviderInfo, error) {

	if s.providers == nil {
		return aiinterfaces.ProviderInfo{}, fmt.Errorf("backend service: providers not configured")
	}

	if strings.TrimSpace(request.Name) == "" {
		return aiinterfaces.ProviderInfo{}, fmt.Errorf("backend service: provider name required")
	}
	if strings.TrimSpace(request.Type) != "" || strings.TrimSpace(request.BaseURL) != "" ||
		strings.TrimSpace(request.DefaultModel) != "" || len(request.EnabledModels) > 0 {
		return aiinterfaces.ProviderInfo{}, fmt.Errorf("backend service: dynamic provider registration fields are not supported")
	}

	info, err := s.providers.ConnectProvider(ctx, request.Name, provider.ProviderCredentials(request.Credentials))
	if err != nil {
		return aiinterfaces.ProviderInfo{}, err
	}

	return mapProviderInfo(info), nil
}

// UpdateProvider updates mutable provider metadata when supported by the provider runtime.
func (*ProviderService) UpdateProvider(context.Context, aiinterfaces.UpdateProviderRequest) (aiinterfaces.ProviderInfo, error) {

	return aiinterfaces.ProviderInfo{}, fmt.Errorf("backend service: provider metadata updates are not configured")
}

// RemoveProvider disconnects a configured provider.
func (s *ProviderService) RemoveProvider(_ context.Context, name string) error {

	if s.providers == nil {
		return fmt.Errorf("backend service: providers not configured")
	}
	if strings.TrimSpace(name) == "" {
		return fmt.Errorf("backend service: provider name required")
	}

	return s.providers.DisconnectProvider(name)
}

// UpdateProviderCredentials updates provider credentials and validates connectivity.
func (s *ProviderService) UpdateProviderCredentials(_ context.Context, request aiinterfaces.UpdateProviderCredentialsRequest) error {

	if s.providers == nil {
		return fmt.Errorf("backend service: providers not configured")
	}
	if strings.TrimSpace(request.ProviderName) == "" {
		return fmt.Errorf("backend service: provider name required")
	}

	return s.providers.ConfigureProvider(request.ProviderName, provider.ProviderCredentials(request.Credentials))
}

// mapProviderInfo converts a single provider use case record into a backend interface DTO.
func mapProviderInfo(info provider.Info) aiinterfaces.ProviderInfo {

	var status *aiinterfaces.ProviderStatus
	if info.Status != nil {
		status = &aiinterfaces.ProviderStatus{
			OK:        info.Status.OK,
			Message:   info.Status.Message,
			CheckedAt: info.Status.CheckedAt,
		}
	}

	return aiinterfaces.ProviderInfo{
		Name:             info.Name,
		DisplayName:      info.DisplayName,
		CredentialFields: mapProviderCredentialFields(info.CredentialFields),
		CredentialValues: copyStringMap(info.CredentialValues),
		Models:           mapProviderModels(info.Models),
		Resources:        mapProviderModels(info.Resources),
		IsConnected:      info.IsConnected,
		IsActive:         info.IsActive,
		Status:           status,
	}
}

// mapProviderInfos converts provider use case records into backend interface DTOs.
func mapProviderInfos(infos []provider.Info) []aiinterfaces.ProviderInfo {

	if len(infos) == 0 {
		return nil
	}

	mapped := make([]aiinterfaces.ProviderInfo, 0, len(infos))
	for _, info := range infos {
		mapped = append(mapped, mapProviderInfo(info))
	}

	return mapped
}

// mapProviderCredentialFields converts provider credential fields into backend DTOs.
func mapProviderCredentialFields(fields []provider.CredentialField) []aiinterfaces.ProviderCredentialField {

	if len(fields) == 0 {
		return nil
	}

	mapped := make([]aiinterfaces.ProviderCredentialField, 0, len(fields))
	for _, field := range fields {
		mapped = append(mapped, aiinterfaces.ProviderCredentialField{
			Name:        field.Name,
			Label:       field.Label,
			Required:    field.Required,
			Secret:      field.Secret,
			Placeholder: field.Placeholder,
			Help:        field.Help,
		})
	}
	return mapped
}

// mapProviderModels converts provider model metadata into backend DTOs.
func mapProviderModels(models []provider.Model) []aiinterfaces.ProviderModel {

	if len(models) == 0 {
		return nil
	}

	mapped := make([]aiinterfaces.ProviderModel, 0, len(models))
	for _, model := range models {
		mapped = append(mapped, aiinterfaces.ProviderModel{
			ID:                model.ID,
			Name:              model.Name,
			ContextWindow:     model.ContextWindow,
			SupportsStreaming: model.SupportsStreaming,
			SupportsTools:     model.SupportsTools,
			SupportsVision:    model.SupportsVision,
		})
	}
	return mapped
}

// copyStringMap duplicates a string map for safe transport-layer use.
func copyStringMap(values map[string]string) map[string]string {

	if len(values) == 0 {
		return nil
	}

	duplicated := make(map[string]string, len(values))
	for key, value := range values {
		duplicated[key] = value
	}
	return duplicated
}

```


--| internal/features/ai/providers/providers.go

```go
// providers.go builds settings provider dependencies from configuration.
// internal/features/settings/module/providers.go
package providers

import (
	"fmt"
	"strings"

	config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	corelogger "github.com/MadeByDoug/wls-chatbot/internal/core/logger"
	modelaccess "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model"
	anthropicadapter "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/anthropic"
	cloudflareadapter "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/cloudflare"
	geminiadapter "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/gemini"
	grokadapter "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/grok"
	openaiadapter "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/openai"
	openrouteradapter "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/openrouter"
	providerregistry "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/registry"
	providercore "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces/core"
	providerusecase "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/provider"
)

// LoadProvidersFromStore loads providers from configuration storage.
func LoadProvidersFromStore(store config.Store, secrets providercore.SecretStore) ([]providercore.Provider, error) {

	cfg, err := config.LoadConfig(store)
	if err != nil {
		return nil, err
	}
	return ProvidersFromConfig(cfg, secrets, nil)
}

// ProvidersFromConfig constructs providers from configuration.
func ProvidersFromConfig(cfg config.AppConfig, secrets providercore.SecretStore, logger corelogger.Logger) ([]providercore.Provider, error) {

	providers := make([]providercore.Provider, 0, len(cfg.Providers))
	for _, p := range cfg.Providers {
		credentials := buildProviderCredentials(p, secrets)
		apiKey := strings.TrimSpace(credentials[providercore.CredentialAPIKey])
		enabledModels := modelaccess.ResolveEnabledModelsFromConfig(cfg, p.Name, p.DefaultModel)
		providerConfig := providercore.ProviderConfig{
			Name:         p.Name,
			DisplayName:  p.DisplayName,
			APIKey:       apiKey,
			BaseURL:      p.BaseURL,
			DefaultModel: p.DefaultModel,
			Models:       enabledModels,
			Credentials:  credentials,
			Logger:       logger,
		}
		switch p.Type {
		case "openai":
			providers = append(providers, openaiadapter.New(providerConfig))
		case "anthropic":
			providers = append(providers, anthropicadapter.New(providerConfig))
		case "gemini":
			providers = append(providers, geminiadapter.New(providerConfig))
		case "grok":
			providers = append(providers, grokadapter.New(providerConfig))
		case "cloudflare":
			providers = append(providers, cloudflareadapter.New(providerConfig))
		case "openrouter":
			providers = append(providers, openrouteradapter.New(providerConfig))
		default:
			return nil, fmt.Errorf("unknown provider type: %s", p.Type)
		}
	}
	return providers, nil
}

// buildProviderCredentials merges config inputs with stored secrets.
func buildProviderCredentials(cfg config.ProviderConfig, secrets providercore.SecretStore) providercore.ProviderCredentials {

	credentials := make(providercore.ProviderCredentials)
	for key, value := range cfg.Inputs {
		if strings.TrimSpace(value) == "" {
			continue
		}
		credentials[key] = value
	}

	secretFields := providerSecretFields(cfg.Type)
	if secrets != nil && len(secretFields) > 0 {
		for _, field := range secretFields {
			if value, err := secrets.GetProviderSecret(cfg.Name, field); err == nil && strings.TrimSpace(value) != "" {
				credentials[field] = value
			}
		}
	}

	if len(credentials) == 0 {
		return nil
	}
	return credentials
}

// providerSecretFields returns secret credential field names for a provider type.
func providerSecretFields(providerType string) []string {

	switch providerType {
	case "openai", "anthropic", "gemini", "grok":
		return []string{providercore.CredentialAPIKey}
	case "openrouter":
		return []string{providercore.CredentialAPIKey}
	case "cloudflare":
		return []string{
			providercore.CredentialCloudflareToken,
			providercore.CredentialAPIKey,
			providercore.CredentialToken,
		}
	default:
		return nil
	}
}

// BuildProviderService wires provider adapters into the provider use case.
func BuildProviderService(cfg config.AppConfig, cache providercore.ProviderCache, secrets providercore.SecretStore, inputs providercore.ProviderInputsStore, logger corelogger.Logger) (*providerusecase.Service, providercore.ProviderRegistry, error) {

	registry := providerregistry.New()
	providerConfigs, providerErr := ProvidersFromConfig(cfg, secrets, logger)
	if providerErr == nil {
		for _, p := range providerConfigs {
			registry.Register(p)
		}
	}

	updateFrequency, frequencyErr := config.ResolveUpdateFrequencies(cfg)
	service := providerusecase.NewService(registry, cache, secrets, inputs, updateFrequency, logger)
	if providerErr != nil {
		return service, registry, providerErr
	}
	if frequencyErr != nil {
		return service, registry, frequencyErr
	}
	return service, registry, nil
}

```


--| internal/platform/paths.go

```go
// paths.go resolves OS-specific settings filesystem paths.
// internal/features/settings/adapters/platform/paths.go
package platform

import (
	"fmt"
	"os"
	"path/filepath"
)

// ResolveAppDataDir resolves and creates the OS config directory for the app.
func ResolveAppDataDir(appName string) (string, error) {

	if appName == "" {
		return "", fmt.Errorf("resolve app data dir: app name required")
	}

	configDir, err := os.UserConfigDir()
	if err != nil || configDir == "" {
		return "", fmt.Errorf("resolve user config dir: %w", err)
	}

	appDir := filepath.Join(configDir, appName)
	if err := os.MkdirAll(appDir, 0o755); err != nil {
		return "", fmt.Errorf("create app data dir: %w", err)
	}

	return appDir, nil
}

```


--| internal/ui/adapters/cli/ai/backend_factory.go

```go
// backend_factory.go builds backend dependencies for AI CLI command execution.
// internal/ui/adapters/cli/ai/backend_factory.go
package ai

import (
	"database/sql"

	config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	"github.com/MadeByDoug/wls-chatbot/internal/core/logger"
	chatai "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/app/chat"
	imageai "github.com/MadeByDoug/wls-chatbot/internal/features/ai/image"
	modelai "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model"
	providersapi "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers"
	settingsmodule "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers"
	providercache "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/cache"
	"github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/secretstore"
	providerusecase "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/provider"
	"github.com/rs/zerolog"
)

// backendServices groups AI backend services used by AI CLI commands.
type backendServices struct {
	Provider *providersapi.ProviderService
	Model    *modelai.ModelService
	Image    *imageai.ImageService
	Chat     *chatai.ChatService
}

// buildBackendServices builds AI backend services used by AI CLI commands.
func buildBackendServices(log zerolog.Logger, cfg config.AppConfig, db *sql.DB, appName string, keyringServiceName string) (backendServices, error) {

	coreLogger := logger.NewAdapter(log)
	secrets := securestore.NewKeyringStore(keyringServiceName)

	cache, err := providercache.NewSQLiteStore(db)
	if err != nil {
		return backendServices{}, err
	}

	configStore, err := config.NewSQLiteStore(db)
	if err != nil {
		return backendServices{}, err
	}

	providerService, _, err := settingsmodule.BuildProviderService(cfg, cache, secrets, configStore, coreLogger)
	if err != nil {
		return backendServices{}, err
	}

	providerOrchestrator := providerusecase.NewOrchestrator(providerService, secrets, nil)
	return backendServices{
		Provider: providersapi.NewProviderService(providerOrchestrator),
		Model:    modelai.NewModelService(nil, db, appName),
		Image:    imageai.NewImageService(providerOrchestrator),
		Chat:     chatai.NewChatService(),
	}, nil
}

```


--| internal/ui/adapters/cli/ai/backend_helpers.go

```go
// backend_helpers.go loads backend dependencies for AI CLI command execution.
// internal/ui/adapters/cli/ai/backend_helpers.go
package ai

import "fmt"

// loadBackend builds AI backend services using root-resolved dependencies.
func loadBackend(deps Dependencies) (backendServices, error) {

	if deps.Dependencies == nil {
		return backendServices{}, fmt.Errorf("cli ai adapter: common dependencies required")
	}

	if err := deps.Dependencies.ValidateResolved(); err != nil {
		return backendServices{}, fmt.Errorf("cli ai adapter: %w", err)
	}

	services, err := buildBackendServices(
		deps.BaseLogger,
		deps.Config,
		deps.DB,
		deps.AppName,
		deps.KeyringServiceName,
	)
	if err != nil {
		return backendServices{}, err
	}

	return services, nil
}

```


--| internal/ui/adapters/cli/ai/chat_command.go

```go
// chat_command.go defines AI CLI adapters for chat workflows.
// internal/ui/adapters/cli/ai/chat_command.go
package ai

import (
	"context"
	"fmt"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/ports"
	"github.com/spf13/cobra"
)

// newChatCommand creates the parent 'chat' command.
func newChatCommand(deps Dependencies) *cobra.Command {

	cmd := &cobra.Command{
		Use:   "chat",
		Short: "Run chat completions",
	}
	cmd.AddCommand(newChatSendCommand(deps))
	return cmd
}

// newChatSendCommand creates the 'chat send' command.
func newChatSendCommand(deps Dependencies) *cobra.Command {

	var providerName string
	var modelName string
	var prompt string
	var systemPrompt string

	cmd := &cobra.Command{
		Use:   "send",
		Short: "Send a chat prompt",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			messages := make([]aiinterfaces.ChatMessage, 0, 2)
			if systemPrompt != "" {
				messages = append(messages, aiinterfaces.ChatMessage{
					Role:    aiinterfaces.ChatRoleSystem,
					Content: systemPrompt,
				})
			}
			messages = append(messages, aiinterfaces.ChatMessage{
				Role:    aiinterfaces.ChatRoleUser,
				Content: prompt,
			})

			chunks, err := services.Chat.Chat(context.Background(), aiinterfaces.ChatRequest{
				ProviderName: providerName,
				ModelName:    modelName,
				Messages:     messages,
				Options: aiinterfaces.ChatOptions{
					Stream: true,
				},
			})
			if err != nil {
				return err
			}

			for chunk := range chunks {
				if chunk.Error != "" {
					return fmt.Errorf("%s", chunk.Error)
				}
				if chunk.Content == "" {
					continue
				}
				fmt.Print(chunk.Content)
			}
			fmt.Println()
			return nil
		},
	}

	cmd.Flags().StringVar(&providerName, "provider", "", "Provider name")
	_ = cmd.MarkFlagRequired("provider")
	cmd.Flags().StringVar(&modelName, "model", "", "Model name")
	_ = cmd.MarkFlagRequired("model")
	cmd.Flags().StringVar(&prompt, "prompt", "", "Prompt text")
	_ = cmd.MarkFlagRequired("prompt")
	cmd.Flags().StringVar(&systemPrompt, "system", "", "Optional system prompt")
	return cmd
}

```


--| internal/ui/adapters/cli/ai/dependencies.go

```go
// dependencies.go defines dependency contracts consumed by AI CLI command adapters.
// internal/ui/adapters/cli/ai/dependencies.go
package ai

import (
	"fmt"

	commonadapter "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/common"
)

// Dependencies groups construction functions required by AI CLI adapters.
type Dependencies struct {
	*commonadapter.Dependencies
}

// validate returns an error when required AI CLI adapter dependencies are missing.
func (d Dependencies) validate() error {

	if d.Dependencies == nil {
		return fmt.Errorf("cli ai adapter: common dependencies required")
	}
	if err := d.Dependencies.ValidateCore(); err != nil {
		return fmt.Errorf("cli ai adapter: %w", err)
	}
	return nil
}

```


--| internal/ui/adapters/cli/ai/image_command.go

```go
// image_command.go defines AI CLI adapters for image generation workflows.
// internal/ui/adapters/cli/ai/image_command.go
package ai

import (
	"context"
	"fmt"
	"os"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/image/ports"
	"github.com/spf13/cobra"
)

// newImageCommand creates the parent 'image' command.
func newImageCommand(deps Dependencies) *cobra.Command {

	cmd := &cobra.Command{
		Use:   "image",
		Short: "Generate or edit images",
	}
	cmd.AddCommand(newImageGenerateCommand(deps))
	cmd.AddCommand(newImageEditCommand(deps))
	return cmd
}

// newImageGenerateCommand creates the 'image generate' command.
func newImageGenerateCommand(deps Dependencies) *cobra.Command {

	var providerName string
	var modelName string
	var prompt string
	var outputPath string

	cmd := &cobra.Command{
		Use:   "generate",
		Short: "Generate an image",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			deps.BaseLogger.Info().Str("provider", providerName).Str("model", modelName).Msg("Generating image...")
			result, err := services.Image.GenerateImage(context.Background(), aiinterfaces.GenerateImageRequest{
				ProviderName: providerName,
				ModelName:    modelName,
				Prompt:       prompt,
				N:            1,
			})
			if err != nil {
				return fmt.Errorf("generation failed: %w", err)
			}

			if outputPath != "" {
				if err := os.WriteFile(outputPath, result.Bytes, 0o644); err != nil {
					return fmt.Errorf("failed to write output file: %w", err)
				}
				deps.BaseLogger.Info().Str("path", outputPath).Msg("Image saved")
			} else {
				deps.BaseLogger.Info().Int("bytes", len(result.Bytes)).Msg("Image generated (use --output to save)")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&providerName, "provider", "", "Provider name (e.g. gemini, openai)")
	_ = cmd.MarkFlagRequired("provider")
	cmd.Flags().StringVar(&modelName, "model", "", "Model name (optional)")
	cmd.Flags().StringVar(&prompt, "prompt", "", "Image prompt")
	_ = cmd.MarkFlagRequired("prompt")
	cmd.Flags().StringVar(&outputPath, "output", "", "Output path for the generated image")

	return cmd
}

// newImageEditCommand creates the 'image edit' command.
func newImageEditCommand(deps Dependencies) *cobra.Command {

	var providerName string
	var modelName string
	var prompt string
	var outputPath string
	var imagePath string
	var maskPath string

	cmd := &cobra.Command{
		Use:   "edit",
		Short: "Edit an image",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			deps.BaseLogger.Info().Str("provider", providerName).Str("model", modelName).Msg("Editing image...")
			result, err := services.Image.EditImage(context.Background(), aiinterfaces.EditImageRequest{
				ProviderName: providerName,
				ModelName:    modelName,
				Prompt:       prompt,
				ImagePath:    imagePath,
				MaskPath:     maskPath,
				N:            1,
			})
			if err != nil {
				return fmt.Errorf("editing failed: %w", err)
			}

			if outputPath != "" {
				if err := os.WriteFile(outputPath, result.Bytes, 0o644); err != nil {
					return fmt.Errorf("failed to write output file: %w", err)
				}
				deps.BaseLogger.Info().Str("path", outputPath).Msg("Image saved")
			} else {
				deps.BaseLogger.Info().Int("bytes", len(result.Bytes)).Msg("Image generated (use --output to save)")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&providerName, "provider", "", "Provider name (e.g. gemini, openai)")
	_ = cmd.MarkFlagRequired("provider")
	cmd.Flags().StringVar(&modelName, "model", "", "Model name (optional)")
	cmd.Flags().StringVar(&prompt, "prompt", "", "Image prompt")
	_ = cmd.MarkFlagRequired("prompt")
	cmd.Flags().StringVar(&imagePath, "image", "", "Input image path")
	_ = cmd.MarkFlagRequired("image")
	cmd.Flags().StringVar(&maskPath, "mask", "", "Input mask path (optional)")
	cmd.Flags().StringVar(&outputPath, "output", "", "Output path for the generated image")

	return cmd
}

```


--| internal/ui/adapters/cli/ai/model_command.go

```go
// model_command.go defines AI CLI adapters for model catalog workflows.
// internal/ui/adapters/cli/ai/model_command.go
package ai

import (
	"context"
	"fmt"
	"strings"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model/interfaces"
	"github.com/spf13/cobra"
)

// newModelCommand creates the 'model' command with subcommands.
func newModelCommand(deps Dependencies) *cobra.Command {

	cmd := &cobra.Command{
		Use:     "model",
		Aliases: []string{"models"},
		Short:   "Manage model catalog",
	}
	cmd.AddCommand(newModelListCommand(deps))
	cmd.AddCommand(newModelImportCommand(deps))
	cmd.AddCommand(newModelSyncCommand(deps))
	return cmd
}

// newModelListCommand lists models in the catalog.
func newModelListCommand(deps Dependencies) *cobra.Command {

	var source string
	var requiredInputModalities []string
	var requiredOutputModalities []string
	var requiredCapabilityIDs []string
	var requiredSystemTags []string

	cmd := &cobra.Command{
		Use:   "list",
		Short: "List models in the catalog",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			summaries, err := services.Model.ListModels(context.Background(), aiinterfaces.ModelListFilter{
				Source:                   source,
				RequiredInputModalities:  requiredInputModalities,
				RequiredOutputModalities: requiredOutputModalities,
				RequiredCapabilityIDs:    requiredCapabilityIDs,
				RequiredSystemTags:       requiredSystemTags,
			})
			if err != nil {
				return err
			}

			fmt.Printf("%-40s %-15s %-12s %-10s\n", "MODEL ID", "PROVIDER", "SOURCE", "APPROVED")
			fmt.Println(strings.Repeat("-", 80))
			for _, summary := range summaries {
				approved := "no"
				if summary.Approved {
					approved = "yes"
				}
				fmt.Printf("%-40s %-15s %-12s %-10s\n", summary.ModelID, summary.ProviderName, summary.Source, approved)
			}
			return nil
		},
	}
	cmd.Flags().StringVar(&source, "source", "", "Filter by source (seed, user, discovered)")
	cmd.Flags().StringSliceVar(&requiredInputModalities, "requires-input-modality", nil, "Require one or more input modalities (repeat flag)")
	cmd.Flags().StringSliceVar(&requiredOutputModalities, "requires-output-modality", nil, "Require one or more output modalities (repeat flag)")
	cmd.Flags().StringSliceVar(&requiredCapabilityIDs, "requires-capability", nil, "Require one or more semantic capability IDs (repeat flag)")
	cmd.Flags().StringSliceVar(&requiredSystemTags, "requires-system-tag", nil, "Require one or more model system tags (repeat flag)")
	return cmd
}

// newModelImportCommand imports custom models from a YAML file.
func newModelImportCommand(deps Dependencies) *cobra.Command {

	var filePath string

	cmd := &cobra.Command{
		Use:   "import",
		Short: "Import custom models from a YAML file",
		Long:  "Import custom models from a YAML file. Format matches models.yaml structure.",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			if err := services.Model.ImportModels(context.Background(), aiinterfaces.ImportModelsRequest{
				FilePath: filePath,
			}); err != nil {
				return err
			}

			fmt.Println("Custom models imported successfully.")
			return nil
		},
	}
	cmd.Flags().StringVar(&filePath, "file", "", "Path to the custom models YAML file")
	_ = cmd.MarkFlagRequired("file")
	return cmd
}

// newModelSyncCommand re-syncs custom models from the default location.
func newModelSyncCommand(deps Dependencies) *cobra.Command {

	cmd := &cobra.Command{
		Use:   "sync",
		Short: "Sync custom models from app config directory",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			result, err := services.Model.SyncModels(context.Background())
			if err != nil {
				return err
			}
			if !result.Imported {
				fmt.Printf("No custom models file found at %s\n", result.Path)
				return nil
			}

			fmt.Printf("Custom models synced from %s\n", result.Path)
			return nil
		},
	}
	return cmd
}

```


--| internal/ui/adapters/cli/ai/provider_command.go

```go
// provider_command.go defines AI CLI adapters for provider workflows.
// internal/ui/adapters/cli/ai/provider_command.go
package ai

import (
	"context"
	"fmt"
	"strings"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces"
	"github.com/spf13/cobra"
)

// newProviderCommand creates the parent 'provider' command.
func newProviderCommand(deps Dependencies) *cobra.Command {

	cmd := &cobra.Command{
		Use:   "provider",
		Short: "Manage AI providers",
	}
	cmd.AddCommand(newProviderListCommand(deps))
	cmd.AddCommand(newProviderTestCommand(deps))
	cmd.AddCommand(newProviderAddCommand(deps))
	cmd.AddCommand(newProviderRemoveCommand(deps))
	cmd.AddCommand(newProviderCredentialsCommand(deps))
	return cmd
}

// newProviderListCommand lists configured providers.
func newProviderListCommand(deps Dependencies) *cobra.Command {

	cmd := &cobra.Command{
		Use:   "list",
		Short: "List configured providers",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			providers, err := services.Provider.GetProviders(context.Background())
			if err != nil {
				return err
			}

			fmt.Printf("%-15s %-25s %-10s %-10s\n", "NAME", "DISPLAY NAME", "CONNECTED", "ACTIVE")
			fmt.Println(strings.Repeat("-", 70))
			for _, provider := range providers {
				connected := "no"
				active := "no"
				if provider.IsConnected {
					connected = "yes"
				}
				if provider.IsActive {
					active = "yes"
				}
				fmt.Printf("%-15s %-25s %-10s %-10s\n", provider.Name, provider.DisplayName, connected, active)
			}
			return nil
		},
	}
	return cmd
}

// newProviderTestCommand tests a provider connection.
func newProviderTestCommand(deps Dependencies) *cobra.Command {

	var providerName string

	cmd := &cobra.Command{
		Use:   "test",
		Short: "Test a provider connection",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			fmt.Printf("Testing connection to %s...\n", providerName)
			if err := services.Provider.TestProvider(context.Background(), providerName); err != nil {
				fmt.Printf("Connection failed: %v\n", err)
				return err
			}
			fmt.Println("Connection successful.")
			return nil
		},
	}
	cmd.Flags().StringVar(&providerName, "name", "", "Provider name to test")
	_ = cmd.MarkFlagRequired("name")
	return cmd
}

// newProviderAddCommand configures a provider using supplied credentials.
func newProviderAddCommand(deps Dependencies) *cobra.Command {

	var name string
	var displayName string
	var providerType string
	var baseURL string
	var defaultModel string
	var credentials []string

	cmd := &cobra.Command{
		Use:   "add",
		Short: "Configure credentials for a provider",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			credentialMap, err := parseKeyValuePairs(credentials)
			if err != nil {
				return err
			}

			_, err = services.Provider.AddProvider(context.Background(), aiinterfaces.AddProviderRequest{
				Name:         name,
				DisplayName:  displayName,
				Type:         providerType,
				BaseURL:      baseURL,
				DefaultModel: defaultModel,
				Credentials:  credentialMap,
			})
			if err != nil {
				return err
			}

			fmt.Printf("Provider %s configured.\n", name)
			return nil
		},
	}

	cmd.Flags().StringVar(&name, "name", "", "Provider name")
	_ = cmd.MarkFlagRequired("name")
	cmd.Flags().StringVar(&displayName, "display-name", "", "Display name (optional)")
	cmd.Flags().StringVar(&providerType, "type", "", "Provider type (optional)")
	cmd.Flags().StringVar(&baseURL, "base-url", "", "Provider base URL (optional)")
	cmd.Flags().StringVar(&defaultModel, "default-model", "", "Default model (optional)")
	cmd.Flags().StringArrayVar(&credentials, "credential", nil, "Provider credential as key=value (repeat flag)")

	return cmd
}

// newProviderRemoveCommand disconnects a configured provider.
func newProviderRemoveCommand(deps Dependencies) *cobra.Command {

	var name string

	cmd := &cobra.Command{
		Use:   "remove",
		Short: "Disconnect a provider",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}
			if err := services.Provider.RemoveProvider(context.Background(), name); err != nil {
				return err
			}

			fmt.Printf("Provider %s disconnected.\n", name)
			return nil
		},
	}

	cmd.Flags().StringVar(&name, "name", "", "Provider name")
	_ = cmd.MarkFlagRequired("name")
	return cmd
}

// newProviderCredentialsCommand updates provider credentials.
func newProviderCredentialsCommand(deps Dependencies) *cobra.Command {

	var name string
	var credentials []string

	cmd := &cobra.Command{
		Use:   "credentials",
		Short: "Update provider credentials",
		Args:  cobra.NoArgs,
		RunE: func(cmd *cobra.Command, _ []string) error {
			services, err := loadBackend(deps)
			if err != nil {
				return err
			}

			credentialMap, err := parseKeyValuePairs(credentials)
			if err != nil {
				return err
			}
			if len(credentialMap) == 0 {
				return fmt.Errorf("at least one --credential key=value is required")
			}

			if err := services.Provider.UpdateProviderCredentials(context.Background(), aiinterfaces.UpdateProviderCredentialsRequest{
				ProviderName: name,
				Credentials:  credentialMap,
			}); err != nil {
				return err
			}

			fmt.Printf("Credentials updated for provider %s.\n", name)
			return nil
		},
	}

	cmd.Flags().StringVar(&name, "name", "", "Provider name")
	_ = cmd.MarkFlagRequired("name")
	cmd.Flags().StringArrayVar(&credentials, "credential", nil, "Provider credential as key=value (repeat flag)")
	return cmd
}

// parseKeyValuePairs parses repeated key=value CLI flags into a map.
func parseKeyValuePairs(entries []string) (map[string]string, error) {

	if len(entries) == 0 {
		return nil, nil
	}

	parsed := make(map[string]string, len(entries))
	for _, entry := range entries {
		key, value, ok := strings.Cut(entry, "=")
		if !ok {
			return nil, fmt.Errorf("invalid key=value entry: %s", entry)
		}
		trimmedKey := strings.TrimSpace(key)
		trimmedValue := strings.TrimSpace(value)
		if trimmedKey == "" || trimmedValue == "" {
			return nil, fmt.Errorf("invalid key=value entry: %s", entry)
		}
		parsed[trimmedKey] = trimmedValue
	}
	return parsed, nil
}

```


--| internal/ui/adapters/cli/ai/root_command.go

```go
// root_command.go constructs the AI CLI adapter command tree.
// internal/ui/adapters/cli/ai/root_command.go
package ai

import "github.com/spf13/cobra"

// NewCommand builds the AI CLI adapter command and all AI CLI subcommands.
func NewCommand(deps Dependencies) *cobra.Command {

	dependencyErr := deps.validate()
	if dependencyErr != nil {
		return &cobra.Command{
			Use:          "ai",
			SilenceUsage: true,
			RunE: func(cmd *cobra.Command, _ []string) error {
				return dependencyErr
			},
		}
	}

	cmd := &cobra.Command{
		Use:          "ai",
		Short:        "Run AI workflows",
		SilenceUsage: true,
	}

	cmd.AddCommand(newProviderCommand(deps))
	cmd.AddCommand(newModelCommand(deps))
	cmd.AddCommand(newImageCommand(deps))
	cmd.AddCommand(newChatCommand(deps))

	return cmd
}

```


--| internal/ui/adapters/cli/dependencies.go

```go
// dependencies.go defines dependency contracts consumed by CLI command adapters.
// internal/ui/adapters/cli/dependencies.go
package cli

import (
	"fmt"

	commonadapter "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/common"
)

// Dependencies groups construction functions required by the CLI adapter.
type Dependencies struct {
	*commonadapter.Dependencies
}

// validate returns an error when required CLI adapter dependencies are missing.
func (d Dependencies) validate() error {

	if d.Dependencies == nil {
		return fmt.Errorf("cli adapter: common dependencies required")
	}
	if err := d.Dependencies.ValidateCore(); err != nil {
		return fmt.Errorf("cli adapter: %w", err)
	}
	return nil
}

```


--| internal/ui/adapters/cli/root_command.go

```go
// root_command.go constructs the CLI adapter command tree.
// internal/ui/adapters/cli/root_command.go
package cli

import (
	aicli "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/cli/ai"
	"github.com/spf13/cobra"
)

// NewCommand builds the CLI adapter command and all CLI subcommands.
func NewCommand(deps Dependencies) *cobra.Command {

	dependencyErr := deps.validate()
	if dependencyErr != nil {
		return &cobra.Command{
			Use:          "cli",
			SilenceUsage: true,
			RunE: func(cmd *cobra.Command, _ []string) error {
				return dependencyErr
			},
		}
	}

	cmd := &cobra.Command{
		Use:          "cli",
		Short:        "Run CLI workflows",
		SilenceUsage: true,
	}

	cmd.AddCommand(aicli.NewCommand(aicli.Dependencies{
		Dependencies: deps.Dependencies,
	}))
	cmd.AddCommand(newTestCommand(deps.BaseLogger))

	return cmd
}

```


--| internal/ui/adapters/common/dependencies.go

```go
// dependencies.go defines shared dependency contracts for UI adapters.
// internal/ui/adapters/common/dependencies.go
package common

import (
	"database/sql"
	"fmt"

	config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	"github.com/rs/zerolog"
)

// Dependencies groups construction functions shared by all UI adapters.
type Dependencies struct {
	AppName            string
	KeyringServiceName string
	DefaultLogLevel    string
	BaseLogger         zerolog.Logger
	DB                 *sql.DB
	Config             config.AppConfig
}

// ValidateCore validates shared dependency fields required by all adapters.
func (d Dependencies) ValidateCore() error {

	if d.AppName == "" {
		return fmt.Errorf("app name required")
	}
	if d.KeyringServiceName == "" {
		return fmt.Errorf("keyring service name required")
	}
	if d.DefaultLogLevel == "" {
		return fmt.Errorf("default log level required")
	}
	return nil
}

// ValidateResolved validates runtime dependencies resolved before command execution.
func (d Dependencies) ValidateResolved() error {

	if d.DB == nil {
		return fmt.Errorf("database required")
	}
	return nil
}

```


--| internal/ui/adapters/wails/app_setup.go

```go
// app_setup.go builds Wails bridge dependencies from feature services.
// internal/ui/adapters/wails/app_setup.go
package wails

import (
	"database/sql"

	config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	corelogger "github.com/MadeByDoug/wls-chatbot/internal/core/logger"
	"github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/adapters/chatrepo"
	chatai "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/app/chat"
	chatusecase "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/app/chat"
	imageai "github.com/MadeByDoug/wls-chatbot/internal/features/ai/image"
	modelai "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model"
	providersapi "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers"
	settingsmodule "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers"
	providercache "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/cache"
	"github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/adapters/secretstore"
	providerusecase "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/provider"
	wailslogger "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/wails/logger"
	"github.com/rs/zerolog"
)

// setupApp wires shared feature services and Wails bridge adapters.
func setupApp(log zerolog.Logger, cfg config.AppConfig, db *sql.DB, appName string, keyringServiceName string) (*Bridge, *wailslogger.Logger, error) {

	coreLogger := corelogger.NewAdapter(log)
	secrets := securestore.NewKeyringStore(keyringServiceName)

	cache, cacheErr := providercache.NewSQLiteStore(db)
	if cacheErr != nil {
		return nil, nil, cacheErr
	}

	configStore, configStoreErr := config.NewSQLiteStore(db)
	if configStoreErr != nil {
		return nil, nil, configStoreErr
	}

	providerService, registry, err := settingsmodule.BuildProviderService(cfg, cache, secrets, configStore, coreLogger)
	if err != nil {
		return nil, nil, err
	}

	chatRepo, repoErr := chatrepo.NewRepository(db)
	if repoErr != nil {
		return nil, nil, repoErr
	}
	chatService := chatusecase.NewService(chatRepo)

	emitter := &Emitter{}
	providerOrchestrator := providerusecase.NewOrchestrator(providerService, secrets, emitter)
	providerAPI := providersapi.NewProviderService(providerOrchestrator)
	modelAPI := modelai.NewModelService(nil, db, appName)
	imageAPI := imageai.NewImageService(providerOrchestrator)
	chatAPI := chatai.NewChatService()
	bridgeService := New(
		chatusecase.NewOrchestrator(chatService, registry, secrets, emitter),
		providerOrchestrator,
		emitter,
		providerAPI,
		modelAPI,
		imageAPI,
		chatAPI,
	)
	logBridge := wailslogger.NewLogBridge(log)

	return bridgeService, logBridge, nil
}

```


--| internal/ui/adapters/wails/backend_api.go

```go
// backend_api.go exposes backend parity endpoints to the frontend bridge.
// internal/ui/adapters/wails/backend_api.go
package wails

import (
	"fmt"

	imageinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/image/ports"
	modelinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model/interfaces"
)

// GenerateImage generates an image using the shared backend interface.
func (b *Bridge) GenerateImage(request imageinterfaces.GenerateImageRequest) (imageinterfaces.ImageBinaryResult, error) {

	if b.imageAPI == nil {
		return imageinterfaces.ImageBinaryResult{}, fmt.Errorf("backend interface not configured")
	}
	return b.imageAPI.GenerateImage(b.ctxOrBackground(), request)
}

// EditImage edits an image using the shared backend interface.
func (b *Bridge) EditImage(request imageinterfaces.EditImageRequest) (imageinterfaces.ImageBinaryResult, error) {

	if b.imageAPI == nil {
		return imageinterfaces.ImageBinaryResult{}, fmt.Errorf("backend interface not configured")
	}
	return b.imageAPI.EditImage(b.ctxOrBackground(), request)
}

// ListModels lists model catalog entries using the shared backend interface.
func (b *Bridge) ListModels(source string) ([]modelinterfaces.ModelSummary, error) {

	if b.modelAPI == nil {
		return nil, fmt.Errorf("backend interface not configured")
	}
	return b.modelAPI.ListModels(b.ctxOrBackground(), modelinterfaces.ModelListFilter{
		Source: source,
	})
}

// QueryModels lists model catalog entries using advanced capability filters.
func (b *Bridge) QueryModels(filter modelinterfaces.ModelListFilter) ([]modelinterfaces.ModelSummary, error) {

	if b.modelAPI == nil {
		return nil, fmt.Errorf("backend interface not configured")
	}
	return b.modelAPI.ListModels(b.ctxOrBackground(), filter)
}

// ImportModels imports custom models from a local file path.
func (b *Bridge) ImportModels(filePath string) error {

	if b.modelAPI == nil {
		return fmt.Errorf("backend interface not configured")
	}
	return b.modelAPI.ImportModels(b.ctxOrBackground(), modelinterfaces.ImportModelsRequest{
		FilePath: filePath,
	})
}

// SyncModels imports custom models from the default app data path.
func (b *Bridge) SyncModels() (modelinterfaces.SyncModelsResult, error) {

	if b.modelAPI == nil {
		return modelinterfaces.SyncModelsResult{}, fmt.Errorf("backend interface not configured")
	}
	return b.modelAPI.SyncModels(b.ctxOrBackground())
}

```


--| internal/ui/adapters/wails/bridge.go

```go
// provide Wails bindings for frontend-backend communication.
// internal/ui/adapters/wails/bridge.go
package wails

import (
	"context"
	"sync"

	"github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/app/chat"
	chatinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/ports"
	imageinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/image/ports"
	modelinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/model/interfaces"
	providerinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces"
	"github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/provider"
)

// Bridge is the main Wails binding struct that exposes backend functionality to the frontend.
type Bridge struct {
	chat        *chat.Orchestrator
	providers   *provider.Orchestrator
	emitter     *Emitter
	providerAPI providerinterfaces.ProviderInterface
	modelAPI    modelinterfaces.ProviderModelInterface
	imageAPI    imageinterfaces.ImageInterface
	chatAPI     chatinterfaces.ChatInterface

	mu     sync.RWMutex
	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup
}

var lifecycleUnavailableCtx = canceledContext()

// New creates a new Bridge instance.
func New(
	chatPolicy *chat.Orchestrator,
	providerPolicy *provider.Orchestrator,
	emitter *Emitter,
	providerAPI providerinterfaces.ProviderInterface,
	modelAPI modelinterfaces.ProviderModelInterface,
	imageAPI imageinterfaces.ImageInterface,
	chatAPI chatinterfaces.ChatInterface,
) *Bridge {

	return &Bridge{
		chat:        chatPolicy,
		providers:   providerPolicy,
		emitter:     emitter,
		providerAPI: providerAPI,
		modelAPI:    modelAPI,
		imageAPI:    imageAPI,
		chatAPI:     chatAPI,
	}
}

// Startup is called by Wails when the application starts.
func (b *Bridge) Startup(ctx context.Context) {

	if ctx == nil {
		ctx = context.Background()
	}

	b.mu.RLock()
	previousCancel := b.cancel
	b.mu.RUnlock()
	if previousCancel != nil {
		previousCancel()
		b.wg.Wait()
	}

	appCtx, cancel := context.WithCancel(ctx)
	b.mu.Lock()
	b.ctx = appCtx
	b.cancel = cancel
	b.mu.Unlock()

	if b.emitter != nil {
		b.emitter.SetContext(appCtx)
	}
}

// Shutdown is called by Wails when the application shuts down.
func (b *Bridge) Shutdown(context.Context) {

	if b.emitter != nil {
		b.emitter.ClearContext()
	}

	b.mu.Lock()
	cancel := b.cancel
	b.cancel = nil
	b.ctx = nil
	b.mu.Unlock()

	if cancel != nil {
		cancel()
	}
	b.wg.Wait()
}

// ctxOrBackground returns the app context or a canceled context when lifecycle context is unavailable.
func (b *Bridge) ctxOrBackground() context.Context {

	b.mu.RLock()
	ctx := b.ctx
	b.mu.RUnlock()
	if ctx != nil {
		return ctx
	}
	return lifecycleUnavailableCtx
}

// canceledContext returns an already-canceled context for calls made outside app lifecycle.
func canceledContext() context.Context {

	ctx, cancel := context.WithCancel(context.Background())
	cancel()
	return ctx
}

```


--| internal/ui/adapters/wails/chat_api.go

```go
// expose chat endpoints to the frontend via the bridge.
// internal/ui/adapters/wails/chat_api.go
package wails

import (
	"fmt"

	"github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/app/chat"
)

// CreateConversation creates a new conversation with the given settings.
func (b *Bridge) CreateConversation(providerName, model string) (*chat.Conversation, error) {

	if b.chat == nil {
		return nil, fmt.Errorf("chat orchestrator not configured")
	}
	return b.chat.CreateConversation(providerName, model)
}

// SetActiveConversation sets the active conversation by ID.
func (b *Bridge) SetActiveConversation(id string) {

	b.chat.SetActiveConversation(id)
}

// GetActiveConversation returns the currently active conversation.
func (b *Bridge) GetActiveConversation() *chat.Conversation {

	return b.chat.GetActiveConversation()
}

// GetConversation returns a conversation by ID.
func (b *Bridge) GetConversation(id string) *chat.Conversation {

	return b.chat.GetConversation(id)
}

// ListConversations returns summaries of all conversations.
func (b *Bridge) ListConversations() []chat.ConversationSummary {

	return b.chat.ListConversations()
}

// ListDeletedConversations returns summaries of archived conversations.
func (b *Bridge) ListDeletedConversations() []chat.ConversationSummary {

	return b.chat.ListDeletedConversations()
}

// UpdateConversationModel updates the model for a conversation.
func (b *Bridge) UpdateConversationModel(conversationID, model string) bool {

	return b.chat.UpdateConversationModel(conversationID, model)
}

// UpdateConversationProvider updates the provider for a conversation.
func (b *Bridge) UpdateConversationProvider(conversationID, provider string) bool {

	return b.chat.UpdateConversationProvider(conversationID, provider)
}

// DeleteConversation moves a conversation to the recycle bin.
func (b *Bridge) DeleteConversation(id string) bool {

	return b.chat.DeleteConversation(id)
}

// RestoreConversation restores a recycled conversation.
func (b *Bridge) RestoreConversation(id string) bool {

	return b.chat.RestoreConversation(id)
}

// PurgeConversation permanently deletes a conversation.
func (b *Bridge) PurgeConversation(id string) bool {

	return b.chat.PurgeConversation(id)
}

```


--| internal/ui/adapters/wails/emitter.go

```go
// emit backend events through the Wails runtime.
// internal/ui/adapters/wails/emitter.go
package wails

import (
	"context"
	"sync"

	coreevents "github.com/MadeByDoug/wls-chatbot/internal/core/events"
	"github.com/wailsapp/wails/v2/pkg/runtime"
)

// Emitter sends backend events to the Wails frontend.
type Emitter struct {
	mu  sync.RWMutex
	ctx context.Context
}

var _ coreevents.Bus = (*Emitter)(nil)

// SetContext sets the Wails context used for event emission.
func (e *Emitter) SetContext(ctx context.Context) {

	e.mu.Lock()
	e.ctx = ctx
	e.mu.Unlock()
}

// ClearContext clears the Wails context.
func (e *Emitter) ClearContext() {

	e.mu.Lock()
	e.ctx = nil
	e.mu.Unlock()
}

// Emit sends a signal payload to the frontend.
func (e *Emitter) Emit(signal coreevents.Name, payload interface{}) {

	ctx := e.context()
	if ctx == nil {
		return
	}
	if payload == nil {
		runtime.EventsEmit(ctx, string(signal))
		return
	}
	runtime.EventsEmit(ctx, string(signal), payload)
}

// context returns the stored Wails context.
func (e *Emitter) context() context.Context {

	e.mu.RLock()
	ctx := e.ctx
	e.mu.RUnlock()
	return ctx
}

```


--| internal/ui/adapters/wails/logger/log_bridge.go

```go
// bridge frontend log entries into zerolog.
// internal/core/adapters/logger/log_bridge.go
package logger

import (
	"github.com/rs/zerolog"
)

// LogEntry is a strictly typed log structure for the frontend bridge.
type LogEntry struct {
	Level   string            `json:"level"`
	Message string            `json:"message"`
	Fields  map[string]string `json:"fields"`
}

// Logger acts as a bridge for frontend logging.
type Logger struct {
	logger zerolog.Logger
}

// NewLogBridge creates a new Logger bridge.
func NewLogBridge(l zerolog.Logger) *Logger {

	return &Logger{
		logger: l,
	}
}

// Log logs an entry from the frontend.
func (b *Logger) Log(entry LogEntry) {

	// Create a sub-logger event based on the level
	var event *zerolog.Event
	severity := entry.Level
	switch entry.Level {
	case "trace":
		event = b.logger.Trace()
	case "debug":
		event = b.logger.Debug()
	case "info":
		event = b.logger.Info()
	case "warn":
		event = b.logger.Warn()
	case "error":
		event = b.logger.Error()
	case "fatal":
		event = b.logger.Error()
	case "panic":
		event = b.logger.Error()
	default:
		event = b.logger.Info()
		severity = "info"
	}

	// Attach fields
	for k, v := range entry.Fields {
		event.Str(k, v)
	}
	if entry.Level == "fatal" || entry.Level == "panic" {
		event.Str("frontend_level", entry.Level)
		event.Str("severity", entry.Level)
	}
	event.Str("frontend_severity", severity)

	// Log with message
	event.Msg(entry.Message)
}

```


--| internal/ui/adapters/wails/logger/wails_logger.go

```go
// wails_logger.go adapts zerolog to the Wails logger interface.
// internal/core/adapters/logger/wails_logger.go
package logger

import (
	"strings"

	"github.com/rs/zerolog"
)

// WailsLogger routes Wails internal logs through zerolog.
type WailsLogger struct {
	logger zerolog.Logger
}

// NewWailsLogger creates a logger adapter for Wails internals.
func NewWailsLogger(l zerolog.Logger) *WailsLogger {

	return &WailsLogger{logger: l}
}

// Print logs a plain Wails message.
func (l *WailsLogger) Print(message string) {

	l.log("print", message)
}

// Trace logs a Wails trace message.
func (l *WailsLogger) Trace(message string) {

	l.log("trace", message)
}

// Debug logs a Wails debug message.
func (l *WailsLogger) Debug(message string) {

	l.log("debug", message)
}

// Info logs a Wails info message.
func (l *WailsLogger) Info(message string) {

	l.log("info", message)
}

// Warning logs a Wails warning message.
func (l *WailsLogger) Warning(message string) {

	l.log("warning", message)
}

// Error logs a Wails error message.
func (l *WailsLogger) Error(message string) {

	l.log("error", message)
}

// Fatal logs a Wails fatal message.
func (l *WailsLogger) Fatal(message string) {

	l.log("fatal", message)
}

// log emits the message at the selected level unless filtered.
func (l *WailsLogger) log(level, message string) {

	if l == nil {
		return
	}

	msg := strings.TrimSpace(message)
	if msg == "" {
		return
	}

	scopedLogger := l.logger.With().
		Str("source", "wails").
		Str("wails_level", level).
		Logger()

	event := scopedLogger.Info()

	switch level {
	case "trace":
		event = scopedLogger.Trace()
	case "debug":
		event = scopedLogger.Debug()
	case "warning":
		event = scopedLogger.Warn()
	case "error", "fatal":
		event = scopedLogger.Error()
	}

	event.Msg(msg)
}


```


--| internal/ui/adapters/wails/provider_api.go

```go
// expose provider endpoints to the frontend via the bridge.
// internal/ui/adapters/wails/provider_api.go
package wails

import (
	"fmt"

	aiinterfaces "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/interfaces"
	provider "github.com/MadeByDoug/wls-chatbot/internal/features/ai/providers/provider"
)

// GetProviders returns all available providers with their status.
func (b *Bridge) GetProviders() []provider.Info {

	if b.providerAPI != nil {
		infos, err := b.providerAPI.GetProviders(b.ctxOrBackground())
		if err == nil {
			return mapBackendProviderInfos(infos)
		}
	}
	if b.providers == nil {
		return nil
	}
	return b.providers.GetProviders()
}

// ConnectProvider connects and configures a provider with the given credentials.
func (b *Bridge) ConnectProvider(name string, credentials provider.ProviderCredentials) (provider.Info, error) {

	return b.providers.ConnectProvider(b.ctxOrBackground(), name, credentials)
}

// ConfigureProvider updates a provider's credentials without full connection flow.
func (b *Bridge) ConfigureProvider(name string, credentials provider.ProviderCredentials) error {

	return b.providers.ConfigureProvider(name, credentials)
}

// DisconnectProvider removes a provider's credentials and resets its state.
func (b *Bridge) DisconnectProvider(name string) error {

	return b.providers.DisconnectProvider(name)
}

// SetActiveProvider sets the active provider by name.
func (b *Bridge) SetActiveProvider(name string) bool {

	return b.providers.SetActiveProvider(name)
}

// TestProvider tests the connection to a provider.
func (b *Bridge) TestProvider(name string) error {

	if b.providerAPI != nil {
		return b.providerAPI.TestProvider(b.ctxOrBackground(), name)
	}
	if b.providers == nil {
		return fmt.Errorf("provider orchestrator not configured")
	}
	return b.providers.TestProvider(b.ctxOrBackground(), name)
}

// RefreshProviderResources fetches the latest resources from a provider.
func (b *Bridge) RefreshProviderResources(name string) error {

	return b.providers.RefreshProviderResources(b.ctxOrBackground(), name)
}

// GetActiveProvider returns the currently active provider, if any.
func (b *Bridge) GetActiveProvider() *provider.Info {

	return b.providers.GetActiveProvider()
}

// mapBackendProviderInfos converts backend DTOs into provider use case DTOs for Wails bindings.
func mapBackendProviderInfos(infos []aiinterfaces.ProviderInfo) []provider.Info {

	if len(infos) == 0 {
		return nil
	}

	mapped := make([]provider.Info, 0, len(infos))
	for _, info := range infos {
		var status *provider.Status
		if info.Status != nil {
			status = &provider.Status{
				OK:        info.Status.OK,
				Message:   info.Status.Message,
				CheckedAt: info.Status.CheckedAt,
			}
		}

		mapped = append(mapped, provider.Info{
			Name:             info.Name,
			DisplayName:      info.DisplayName,
			CredentialFields: mapBackendCredentialFields(info.CredentialFields),
			CredentialValues: copyProviderValues(info.CredentialValues),
			Models:           mapBackendProviderModels(info.Models),
			Resources:        mapBackendProviderModels(info.Resources),
			IsConnected:      info.IsConnected,
			IsActive:         info.IsActive,
			Status:           status,
		})
	}

	return mapped
}

// mapBackendCredentialFields converts backend credential field DTOs into provider DTOs.
func mapBackendCredentialFields(fields []aiinterfaces.ProviderCredentialField) []provider.CredentialField {

	if len(fields) == 0 {
		return nil
	}

	mapped := make([]provider.CredentialField, 0, len(fields))
	for _, field := range fields {
		mapped = append(mapped, provider.CredentialField{
			Name:        field.Name,
			Label:       field.Label,
			Required:    field.Required,
			Secret:      field.Secret,
			Placeholder: field.Placeholder,
			Help:        field.Help,
		})
	}
	return mapped
}

// mapBackendProviderModels converts backend model DTOs into provider DTOs.
func mapBackendProviderModels(models []aiinterfaces.ProviderModel) []provider.Model {

	if len(models) == 0 {
		return nil
	}

	mapped := make([]provider.Model, 0, len(models))
	for _, model := range models {
		mapped = append(mapped, provider.Model{
			ID:                model.ID,
			Name:              model.Name,
			ContextWindow:     model.ContextWindow,
			SupportsStreaming: model.SupportsStreaming,
			SupportsTools:     model.SupportsTools,
			SupportsVision:    model.SupportsVision,
		})
	}
	return mapped
}

// copyProviderValues duplicates provider credential values.
func copyProviderValues(values map[string]string) map[string]string {

	if len(values) == 0 {
		return nil
	}

	duplicated := make(map[string]string, len(values))
	for key, value := range values {
		duplicated[key] = value
	}
	return duplicated
}

```


--| internal/ui/adapters/wails/root_command.go

```go
// root_command.go constructs the Wails UI adapter command.
// internal/ui/adapters/wails/root_command.go
package wails

import (
	"fmt"
	"io/fs"

	commonadapter "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/common"
	"github.com/spf13/cobra"
)

// Dependencies groups construction functions required by the Wails adapter command.
type Dependencies struct {
	*commonadapter.Dependencies
	Assets fs.FS
}

// NewCommand builds the Wails adapter command.
func NewCommand(deps Dependencies) *cobra.Command {

	dependencyErr := deps.validate()
	if dependencyErr != nil {
		return &cobra.Command{
			Use:          "ui",
			SilenceUsage: true,
			RunE: func(cmd *cobra.Command, _ []string) error {
				return dependencyErr
			},
		}
	}

	cmd := &cobra.Command{
		Use:          "ui",
		Aliases:      []string{"wails"},
		Short:        "Launch the Wails UI",
		SilenceUsage: true,
		RunE: func(cmd *cobra.Command, _ []string) error {
			if err := deps.Dependencies.ValidateResolved(); err != nil {
				return fmt.Errorf("wails adapter: %w", err)
			}
			deps.BaseLogger.Info().Msg("Starting Wails Lit Starter ChatBot UI...")
			if err := runUI(deps.BaseLogger, deps.Config, deps.DB, deps.Assets, deps.AppName, deps.KeyringServiceName); err != nil {
				return fmt.Errorf("run UI: %w", err)
			}
			return nil
		},
	}

	return cmd
}

// validate returns an error when required Wails adapter dependencies are missing.
func (d Dependencies) validate() error {

	if d.Dependencies == nil {
		return fmt.Errorf("wails adapter: common dependencies required")
	}
	if err := d.Dependencies.ValidateCore(); err != nil {
		return fmt.Errorf("wails adapter: %w", err)
	}
	if d.Assets == nil {
		return fmt.Errorf("wails adapter: assets FS required")
	}
	return nil
}

```


--| internal/ui/adapters/wails/runtime.go

```go
// runtime.go launches the Wails application with bridge bindings.
// internal/ui/adapters/wails/runtime.go
package wails

import (
	"fmt"
	"io/fs"

	wailslogger "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/wails/logger"
	"github.com/rs/zerolog"
	wailsruntime "github.com/wailsapp/wails/v2"
	"github.com/wailsapp/wails/v2/pkg/options"
	"github.com/wailsapp/wails/v2/pkg/options/assetserver"
)

// Run launches the Wails UI with configured lifecycle hooks and bindings.
func Run(log zerolog.Logger, assets fs.FS, bridgeService *Bridge, logBridge *wailslogger.Logger) error {

	if bridgeService == nil {
		return fmt.Errorf("wails bridge not configured")
	}
	if logBridge == nil {
		return fmt.Errorf("wails log bridge not configured")
	}

	return wailsruntime.Run(&options.App{
		Title:  "Wails Lit Starter ChatBot",
		Width:  1024,
		Height: 768,
		Logger: wailslogger.NewWailsLogger(log),
		AssetServer: &assetserver.Options{
			Assets: assets,
		},
		BackgroundColour: &options.RGBA{R: 27, G: 38, B: 54, A: 255},
		OnStartup:        bridgeService.Startup,
		OnShutdown:       bridgeService.Shutdown,
		Bind: []interface{}{
			bridgeService,
			logBridge,
		},
	})
}

```


--| internal/ui/adapters/wails/stream.go

```go
// expose chat streaming endpoints to the frontend via the bridge.
// internal/ui/adapters/wails/stream.go
package wails

import (
	"github.com/MadeByDoug/wls-chatbot/internal/features/ai/chat/app/chat"
)

// SendMessage sends a user message and initiates a streaming response.
func (b *Bridge) SendMessage(conversationID, content string) (*chat.Message, error) {

	return b.chat.SendMessage(b.ctxOrBackground(), conversationID, content)
}

// StopStream cancels the currently running stream.
func (b *Bridge) StopStream() {

	b.chat.StopStream()
}

```


--| internal/ui/adapters/wails/ui_runner.go

```go
// ui_runner.go runs the Wails UI flow from adapter-owned setup.
// internal/ui/adapters/wails/ui_runner.go
package wails

import (
	"database/sql"
	"io/fs"

	config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	"github.com/rs/zerolog"
)

// runUI launches Wails after resolving bridge dependencies from shared setup.
func runUI(log zerolog.Logger, cfg config.AppConfig, db *sql.DB, assets fs.FS, appName string, keyringServiceName string) error {

	bridgeService, logBridge, err := setupApp(log, cfg, db, appName, keyringServiceName)
	if err != nil {
		if bridgeService == nil || logBridge == nil {
			return err
		}
		log.Warn().Err(err).Msg("Failed to initialize app services; continuing with defaults")
	}

	return Run(log, assets, bridgeService, logBridge)
}

```


--| main.go

```go
// main.go composes shared dependencies and delegates to UI adapters.
// main.go
package main

import (
	"database/sql"
	"embed"
	"os"
	"path/filepath"
	"strings"

	config "github.com/MadeByDoug/wls-chatbot/internal/core/config"
	"github.com/MadeByDoug/wls-chatbot/internal/core/datastore"
	"github.com/MadeByDoug/wls-chatbot/internal/core/logger"
	"github.com/MadeByDoug/wls-chatbot/internal/platform"
	cliadapter "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/cli"
	commonadapter "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/common"
	wailsadapter "github.com/MadeByDoug/wls-chatbot/internal/ui/adapters/wails"
	"github.com/spf13/cobra"
)

//go:embed all:frontend/dist
var assets embed.FS

const AppName = "wls-chatbot"
const KeyringServiceName = "github.com/MadeByDoug/wls-chatbot"
const DefaultLogLevel = "info"

// main initializes shared dependencies and explicitly mounts UI adapters.
func main() {

	commonDependencies := &commonadapter.Dependencies{
		AppName:            AppName,
		KeyringServiceName: KeyringServiceName,
		DefaultLogLevel:    DefaultLogLevel,
	}
	var dbPath string
	var logLevel string

	root := &cobra.Command{
		Use:          AppName,
		Short:        "Wails Lit Starter ChatBot",
		SilenceUsage: true,
		PersistentPreRunE: func(cmd *cobra.Command, _ []string) error {
			if cmd.Name() == AppName || cmd.Name() == "help" {
				return nil
			}
			resolvedLevel := strings.TrimSpace(logLevel)
			if resolvedLevel == "" {
				resolvedLevel = commonDependencies.DefaultLogLevel
			}
			commonDependencies.BaseLogger = logger.New(resolvedLevel)
			db, cfg, err := loadCommandEnvironment(dbPath)
			if err != nil {
				return err
			}
			commonDependencies.DB = db
			commonDependencies.Config = cfg
			return nil
		},
		RunE: func(cmd *cobra.Command, _ []string) error {
			return cmd.Help()
		},
	}
	root.PersistentFlags().StringVar(&dbPath, "db-path", "", "Path to the SQLite database file")
	root.PersistentFlags().StringVar(&logLevel, "log-level", commonDependencies.DefaultLogLevel, "Log level (debug, info, warn, error)")

	root.AddCommand(cliadapter.NewCommand(cliadapter.Dependencies{
		Dependencies: commonDependencies,
	}))

	root.AddCommand(wailsadapter.NewCommand(wailsadapter.Dependencies{
		Dependencies: commonDependencies,
		Assets:       assets,
	}))

	err := root.Execute()
	if commonDependencies.DB != nil {
		_ = commonDependencies.DB.Close()
	}
	if err != nil {
		os.Exit(1)
	}
}

// loadCommandEnvironment opens shared command dependencies from CLI flags.
func loadCommandEnvironment(dbPath string) (*sql.DB, config.AppConfig, error) {

	databasePath, err := resolveDatabasePath(dbPath)
	if err != nil {
		return nil, config.AppConfig{}, err
	}

	db, err := datastore.OpenSQLite(databasePath)
	if err != nil {
		return nil, config.AppConfig{}, err
	}

	store, err := config.NewSQLiteStore(db)
	if err != nil {
		_ = db.Close()
		return nil, config.AppConfig{}, err
	}

	cfg, err := config.LoadConfig(store)
	if err != nil {
		_ = db.Close()
		return nil, config.AppConfig{}, err
	}

	return db, cfg, nil
}

// resolveDatabasePath resolves the SQLite database path to use.
func resolveDatabasePath(override string) (string, error) {

	if strings.TrimSpace(override) != "" {
		return override, nil
	}

	appDataDir, err := platform.ResolveAppDataDir(AppName)
	if err != nil {
		return "", err
	}

	return filepath.Join(appDataDir, "appdata.db"), nil
}

```


--| pkg/models/catalog.go

```go
// catalog.go loads and validates the canonical model catalog.
// pkg/models/catalog.go
package models

import (
	_ "embed"
	"fmt"
	"strings"

	"gopkg.in/yaml.v3"
)

//go:embed models.yaml
var embeddedCatalogYAML []byte

// Catalog represents the root structure of the canonical models catalog.
type Catalog struct {
	Providers []Provider `yaml:"providers"`
	Families  []Family   `yaml:"families"`
	Models    []Model    `yaml:"models"`
}

// Provider represents provider metadata used to bootstrap runtime configuration.
type Provider struct {
	ID          string `yaml:"id"`
	Name        string `yaml:"name"`
	Type        string `yaml:"type"`
	DisplayName string `yaml:"display_name"`
	BaseURL     string `yaml:"base_url"`
}

// Family represents a model family with shared provider and capability metadata.
type Family struct {
	ID           string       `yaml:"id"`
	Provider     string       `yaml:"provider"`
	Modalities   Modalities   `yaml:"modalities"`
	Capabilities Capabilities `yaml:"capabilities"`
	SystemTags   []string     `yaml:"system_tags"`
}

// Model represents a concrete model entry bound to a family.
type Model struct {
	ID         string `yaml:"id"`
	Family     string `yaml:"family"`
	IsSnapshot bool   `yaml:"is_snapshot"`
	LinkAlias  string `yaml:"link_alias,omitempty"`
}

// Modalities describes model input and output modality support.
type Modalities struct {
	Input  []string `yaml:"input"`
	Output []string `yaml:"output"`
}

// Capabilities describes capability flags shared by a model family.
type Capabilities struct {
	Streaming        bool `yaml:"streaming"`
	ToolCalling      bool `yaml:"tool_calling"`
	StructuredOutput bool `yaml:"structured_output"`
	Vision           bool `yaml:"vision"`
}

// EmbeddedYAML returns a copy of the embedded canonical catalog bytes.
func EmbeddedYAML() []byte {

	copyBytes := make([]byte, len(embeddedCatalogYAML))
	copy(copyBytes, embeddedCatalogYAML)
	return copyBytes
}

// LoadEmbedded parses and validates the embedded canonical catalog.
func LoadEmbedded() (*Catalog, error) {

	return Parse(embeddedCatalogYAML)
}

// Parse decodes and validates canonical catalog content.
func Parse(data []byte) (*Catalog, error) {

	var catalog Catalog
	if err := yaml.Unmarshal(data, &catalog); err != nil {
		return nil, fmt.Errorf("unmarshal models catalog: %w", err)
	}
	if err := validateCatalog(&catalog); err != nil {
		return nil, err
	}
	return &catalog, nil
}

// validateCatalog enforces structural consistency rules for canonical catalog data.
func validateCatalog(catalog *Catalog) error {

	if catalog == nil {
		return fmt.Errorf("models catalog: catalog required")
	}

	providerByID := make(map[string]Provider, len(catalog.Providers))
	providerNameSeen := make(map[string]struct{}, len(catalog.Providers))
	for _, provider := range catalog.Providers {
		providerID := strings.TrimSpace(provider.ID)
		if providerID == "" {
			return fmt.Errorf("models catalog: provider id required")
		}
		if _, exists := providerByID[providerID]; exists {
			return fmt.Errorf("models catalog: duplicate provider id %q", providerID)
		}
		if strings.TrimSpace(provider.Name) == "" {
			return fmt.Errorf("models catalog: provider %q missing name", providerID)
		}
		if strings.TrimSpace(provider.Type) == "" {
			return fmt.Errorf("models catalog: provider %q missing type", providerID)
		}
		if strings.TrimSpace(provider.DisplayName) == "" {
			return fmt.Errorf("models catalog: provider %q missing display_name", providerID)
		}

		providerName := strings.TrimSpace(provider.Name)
		if _, exists := providerNameSeen[providerName]; exists {
			return fmt.Errorf("models catalog: duplicate provider name %q", providerName)
		}
		providerNameSeen[providerName] = struct{}{}
		providerByID[providerID] = provider
	}

	familyByID := make(map[string]struct{}, len(catalog.Families))
	for _, family := range catalog.Families {
		familyID := strings.TrimSpace(family.ID)
		if familyID == "" {
			return fmt.Errorf("models catalog: family id required")
		}
		if _, exists := familyByID[familyID]; exists {
			return fmt.Errorf("models catalog: duplicate family id %q", familyID)
		}
		providerID := strings.TrimSpace(family.Provider)
		if providerID == "" {
			return fmt.Errorf("models catalog: family %q missing provider", familyID)
		}
		if _, exists := providerByID[providerID]; !exists {
			return fmt.Errorf("models catalog: family %q references unknown provider %q", familyID, providerID)
		}
		familyByID[familyID] = struct{}{}
	}

	modelByID := make(map[string]struct{}, len(catalog.Models))
	for _, model := range catalog.Models {
		modelID := strings.TrimSpace(model.ID)
		if modelID == "" {
			return fmt.Errorf("models catalog: model id required")
		}
		if _, exists := modelByID[modelID]; exists {
			return fmt.Errorf("models catalog: duplicate model id %q", modelID)
		}
		modelByID[modelID] = struct{}{}

		familyID := strings.TrimSpace(model.Family)
		if familyID == "" {
			return fmt.Errorf("models catalog: model %q missing family", modelID)
		}
		if _, exists := familyByID[familyID]; !exists {
			return fmt.Errorf("models catalog: model %q references unknown family %q", modelID, familyID)
		}
	}

	return nil
}

```


--| pkg/models/models.yaml

```yaml
providers:
  - id: openai
    name: openai
    type: openai
    display_name: OpenAI
    base_url: https://api.openai.com/v1

  - id: google
    name: gemini
    type: gemini
    display_name: Google Gemini
    base_url: https://generativelanguage.googleapis.com/v1beta

  - id: grok
    name: grok
    type: grok
    display_name: Grok (xAI)
    base_url: https://api.x.ai/v1

families:

  # OpenAI Model Families
  - id: gpt-4o
    provider: openai
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - multimodal_in
  
  - id: gpt-4o-mini
    provider: openai
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - fast
      - cost_efficient
      - multimodal_in
  
  - id: o1
    provider: openai
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - reasoning
      - multimodal_in
  
  - id: o1-mini
    provider: openai
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: false
    system_tags:
      - reasoning
      - fast
      - cost_efficient
  
  - id: dall-e-3
    provider: openai
    modalities:
      input:
        - text
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: false
    system_tags:
      - image_gen
  
  # Google Model Families
  - id: gemini-2.0-flash
    provider: google
    modalities:
      input:
        - text
        - image
        - video
        - audio
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - fast
      - multimodal_in
  
  - id: gemini-1.5-pro
    provider: google
    modalities:
      input:
        - text
        - image
        - video
        - audio
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - multimodal_in
  
  - id: imagen-4.0
    provider: google
    modalities:
      input:
        - text
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: false
    system_tags:
      - image_gen

  # Grok Model Families
  - id: grok-4-1-fast-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - reasoning
      - fast
      - multimodal_in
  
  - id: grok-4-1-fast-non-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: true
    system_tags:
      - non_reasoning
      - fast
      - multimodal_in
  
  - id: grok-code-fast-1
    provider: grok
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: false
    system_tags:
      - coding
      - fast
  
  - id: grok-4-fast-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - reasoning
      - fast
      - multimodal_in
  
  - id: grok-4-fast-non-reasoning
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: true
    system_tags:
      - non_reasoning
      - fast
      - multimodal_in
  
  - id: grok-4-0709
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: true
    system_tags:
      - general
      - multimodal_in
  
  - id: grok-3-mini
    provider: grok
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: true
      vision: false
    system_tags:
      - general
      - fast
      - cost_efficient
  
  - id: grok-3
    provider: grok
    modalities:
      input:
        - text
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: false
    system_tags:
      - general
  
  - id: grok-2-vision-1212
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - text
    capabilities:
      streaming: true
      tool_calling: true
      structured_output: false
      vision: true
    system_tags:
      - general
      - multimodal_in
      - legacy
  
  - id: grok-imagine-image-pro
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: true
    system_tags:
      - image_gen
      - multimodal_in
  
  - id: grok-imagine-image
    provider: grok
    modalities:
      input:
        - text
        - image
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: true
    system_tags:
      - image_gen
      - multimodal_in
      - cost_efficient
  
  - id: grok-2-image-1212
    provider: grok
    modalities:
      input:
        - text
      output:
        - image
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: false
    system_tags:
      - image_gen
      - legacy
  
  - id: grok-imagine-video
    provider: grok
    modalities:
      input:
        - text
        - image
        - video
      output:
        - video
    capabilities:
      streaming: false
      tool_calling: false
      structured_output: false
      vision: true
    system_tags:
      - video_gen
      - multimodal_in


models:

  # OpenAI Models
  - id: gpt-4o
    family: gpt-4o
    is_snapshot: false
  
  - id: gpt-4o-2024-11-20
    family: gpt-4o
    is_snapshot: true
  
  - id: gpt-4o-mini
    family: gpt-4o-mini
    is_snapshot: false
  
  - id: gpt-4o-mini-2024-07-18
    family: gpt-4o-mini
    is_snapshot: true
  
  - id: o1
    family: o1
    is_snapshot: false
  
  - id: o1-2024-12-17
    family: o1
    is_snapshot: true
  
  - id: o1-mini
    family: o1-mini
    is_snapshot: false
  
  - id: o1-mini-2024-09-12
    family: o1-mini
    is_snapshot: true
  
  - id: dall-e-3
    family: dall-e-3
    is_snapshot: false
  
  # Google Models
  - id: gemini-2.0-flash-exp
    family: gemini-2.0-flash
    is_snapshot: false
  
  - id: gemini-1.5-pro-latest
    family: gemini-1.5-pro
    is_snapshot: false
  
  - id: imagen-4.0-generate-001
    family: imagen-4.0
    is_snapshot: true
  
  - id: imagen-4.0-fast-generate-001
    family: imagen-4.0
    is_snapshot: true
  
  - id: imagen-4.0-ultra-generate-001
    family: imagen-4.0
    is_snapshot: true

  # Grok Models
  - id: grok-4-1-fast-reasoning
    family: grok-4-1-fast-reasoning
    is_snapshot: false
  
  - id: grok-4-1-fast-non-reasoning
    family: grok-4-1-fast-non-reasoning
    is_snapshot: false
  
  - id: grok-code-fast-1
    family: grok-code-fast-1
    is_snapshot: false
  
  - id: grok-4-fast-reasoning
    family: grok-4-fast-reasoning
    is_snapshot: false

```


--| pkg/models/modeltest/capabilities.go

```go
// capabilities.go implements capability-specific test functions.
package modeltest

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// Capability identifies a testable capability.
type Capability string

const (
	CapabilityChat           Capability = "chat"
	CapabilityImageGen       Capability = "image_gen"
	CapabilityImageEdit      Capability = "image_edit"
	CapabilityTestConnection Capability = "test_connection"
)

// AllCapabilities returns all available test capabilities.
func AllCapabilities() []Capability {
	return []Capability{
		CapabilityChat,
		CapabilityImageGen,
		CapabilityImageEdit,
		CapabilityTestConnection,
	}
}

// TestResult contains the outcome of a capability test.
type TestResult struct {
	Provider   string      `json:"provider"`
	Capability Capability  `json:"capability"`
	Model      string      `json:"model"`
	Success    bool        `json:"success"`
	Error      string      `json:"error,omitempty"`
	Recording  *Recording  `json:"recording,omitempty"`
}

// CapabilityTester tests a specific capability.
type CapabilityTester interface {
	Test(ctx context.Context, client *Client, model string) TestResult
	Capability() Capability
}

// ChatTester tests chat completion capability.
type ChatTester struct{}

func (t *ChatTester) Capability() Capability { return CapabilityChat }

func (t *ChatTester) Test(ctx context.Context, client *Client, model string) TestResult {
	result := TestResult{
		Provider:   client.Config().ProviderName,
		Capability: CapabilityChat,
		Model:      model,
	}

	req := t.buildRequest(client.Config().ProviderType, model)
	path := t.endpoint(client.Config().ProviderType, model)

	resp, err := client.Do(ctx, http.MethodPost, path, req)
	if err != nil {
		result.Error = fmt.Sprintf("request failed: %v", err)
		return result
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	if resp.StatusCode >= 400 {
		result.Error = fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(body))
		return result
	}

	result.Success = true
	return result
}

func (t *ChatTester) endpoint(providerType ProviderType, model string) string {
	switch providerType {
	case ProviderTypeOpenAI:
		return "/v1/chat/completions"
	case ProviderTypeGemini:
		return fmt.Sprintf("/v1beta/models/%s:generateContent", model)
	case ProviderTypeAnthropic:
		return "/v1/messages"
	default:
		return "/v1/chat/completions"
	}
}

func (t *ChatTester) buildRequest(providerType ProviderType, model string) interface{} {
	switch providerType {
	case ProviderTypeGemini:
		return map[string]interface{}{
			"contents": []map[string]interface{}{
				{
					"parts": []map[string]string{
						{"text": "Say 'test successful' and nothing else."},
					},
				},
			},
		}
	case ProviderTypeAnthropic:
		return map[string]interface{}{
			"model":      model,
			"max_tokens": 10,
			"messages": []map[string]string{
				{"role": "user", "content": "Say 'test successful' and nothing else."},
			},
		}
	default: // OpenAI-compatible
		return ChatRequest{
			Model: model,
			Messages: []ChatMessage{
				{Role: "user", Content: "Say 'test successful' and nothing else."},
			},
			MaxTokens: 10,
		}
	}
}

// ImageGenTester tests image generation capability.
type ImageGenTester struct{}

func (t *ImageGenTester) Capability() Capability { return CapabilityImageGen }

func (t *ImageGenTester) Test(ctx context.Context, client *Client, model string) TestResult {
	result := TestResult{
		Provider:   client.Config().ProviderName,
		Capability: CapabilityImageGen,
		Model:      model,
	}

	req := t.buildRequest(client.Config().ProviderType, model)
	path := t.endpoint(client.Config().ProviderType, model)

	resp, err := client.Do(ctx, http.MethodPost, path, req)
	if err != nil {
		result.Error = fmt.Sprintf("request failed: %v", err)
		return result
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)

	if resp.StatusCode >= 400 {
		result.Error = fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(body))
		return result
	}

	result.Success = true
	return result
}

func (t *ImageGenTester) endpoint(providerType ProviderType, model string) string {
	switch providerType {
	case ProviderTypeGemini:
		return fmt.Sprintf("/v1beta/models/%s:predict", model)
	default:
		return "/v1/images/generations"
	}
}

func (t *ImageGenTester) buildRequest(providerType ProviderType, model string) interface{} {
	switch providerType {
	case ProviderTypeGemini:
		return map[string]interface{}{
			"instances": []map[string]string{
				{"prompt": "A simple red square on white background"},
			},
			"parameters": map[string]interface{}{
				"sampleCount": 1,
			},
		}
	default:
		return ImageGenRequest{
			Model:          model,
			Prompt:         "A simple red square on white background",
			N:              1,
			Size:           "256x256",
			ResponseFormat: "b64_json",
		}
	}
}

// TestConnectionTester tests provider connectivity.
type TestConnectionTester struct{}

func (t *TestConnectionTester) Capability() Capability { return CapabilityTestConnection }

func (t *TestConnectionTester) Test(ctx context.Context, client *Client, model string) TestResult {
	result := TestResult{
		Provider:   client.Config().ProviderName,
		Capability: CapabilityTestConnection,
		Model:      model,
	}

	path := t.endpoint(client.Config().ProviderType)
	resp, err := client.Do(ctx, http.MethodGet, path, nil)
	if err != nil {
		result.Error = fmt.Sprintf("request failed: %v", err)
		return result
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		result.Error = fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(body))
		return result
	}

	result.Success = true
	return result
}

func (t *TestConnectionTester) endpoint(providerType ProviderType) string {
	switch providerType {
	case ProviderTypeGemini:
		return "/v1beta/models"
	case ProviderTypeAnthropic:
		return "/v1/messages" // Anthropic doesn't have a list models endpoint
	default:
		return "/v1/models"
	}
}

// GetTester returns the appropriate tester for a capability.
func GetTester(cap Capability) CapabilityTester {
	switch cap {
	case CapabilityChat:
		return &ChatTester{}
	case CapabilityImageGen:
		return &ImageGenTester{}
	case CapabilityTestConnection:
		return &TestConnectionTester{}
	default:
		return nil
	}
}

// ParseResponse attempts to parse a response body as JSON.
func ParseResponse(body []byte) (map[string]interface{}, error) {
	var result map[string]interface{}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}
	return result, nil
}

```


--| pkg/models/modeltest/catalog.go

```go
// catalog.go derives model test plans from the canonical model catalog.
// pkg/models/modeltest/catalog.go
package modeltest

import (
	"fmt"
	"strings"

	modelcatalog "github.com/MadeByDoug/wls-chatbot/pkg/models"
)

// LoadEmbeddedCatalogPlan loads the canonical model catalog and derives a test plan.
func LoadEmbeddedCatalogPlan() (*TestPlan, error) {

	catalog, err := modelcatalog.LoadEmbedded()
	if err != nil {
		return nil, err
	}
	return BuildPlanFromCatalog(catalog)
}

// BuildPlanFromCatalog derives a test plan from canonical catalog data.
func BuildPlanFromCatalog(catalog *modelcatalog.Catalog) (*TestPlan, error) {

	if catalog == nil {
		return nil, fmt.Errorf("modeltest catalog plan: catalog required")
	}

	familyByID := make(map[string]modelcatalog.Family, len(catalog.Families))
	for _, family := range catalog.Families {
		familyByID[family.ID] = family
	}

	providerByName := make(map[string]*ProviderConfig)
	providerOrder := make([]string, 0)

	for _, model := range catalog.Models {
		family, exists := familyByID[model.Family]
		if !exists {
			return nil, fmt.Errorf("modeltest catalog plan: unknown family %q for model %q", model.Family, model.ID)
		}

		providerName := normalizeProviderName(family.Provider)
		providerType, baseURL, err := providerConfigForName(providerName)
		if err != nil {
			return nil, fmt.Errorf("modeltest catalog plan: model %q: %w", model.ID, err)
		}

		provider := providerByName[providerName]
		if provider == nil {
			provider = &ProviderConfig{
				Name:    providerName,
				Type:    providerType,
				BaseURL: baseURL,
			}
			providerByName[providerName] = provider
			providerOrder = append(providerOrder, providerName)
		}

		provider.Models = append(provider.Models, ModelConfig{
			ID:           model.ID,
			Capabilities: deriveModelCapabilities(family),
		})
	}

	plan := &TestPlan{Providers: make([]ProviderConfig, 0, len(providerOrder))}
	for _, providerName := range providerOrder {
		plan.Providers = append(plan.Providers, *providerByName[providerName])
	}
	return plan, nil
}

// normalizeProviderName maps catalog provider aliases into modeltest provider names.
func normalizeProviderName(value string) string {

	name := strings.TrimSpace(strings.ToLower(value))
	switch name {
	case "google":
		return "gemini"
	case "xai":
		return "grok"
	default:
		return name
	}
}

// providerConfigForName resolves modeltest provider config fields from provider name.
func providerConfigForName(name string) (ProviderType, string, error) {

	switch name {
	case "openai":
		return ProviderTypeOpenAI, "https://api.openai.com", nil
	case "grok":
		return ProviderTypeOpenAI, "https://api.x.ai", nil
	case "openrouter":
		return ProviderTypeOpenAI, "https://openrouter.ai/api", nil
	case "gemini":
		return ProviderTypeGemini, "https://generativelanguage.googleapis.com", nil
	case "anthropic":
		return ProviderTypeAnthropic, "https://api.anthropic.com", nil
	default:
		return "", "", fmt.Errorf("unsupported provider %q", name)
	}
}

// deriveModelCapabilities derives modeltest capabilities from canonical family metadata.
func deriveModelCapabilities(family modelcatalog.Family) []Capability {

	capabilities := make([]Capability, 0, 4)

	if hasValue(family.Modalities.Output, "text") {
		capabilities = append(capabilities, CapabilityChat)
	}
	if hasValue(family.Modalities.Output, "image") || hasValue(family.SystemTags, "image_gen") {
		capabilities = append(capabilities, CapabilityImageGen)
	}
	if hasValue(family.SystemTags, "image_edit") || hasValue(family.SystemTags, "image_editing") {
		capabilities = append(capabilities, CapabilityImageEdit)
	}

	capabilities = append(capabilities, CapabilityTestConnection)
	return dedupeCapabilities(capabilities)
}

// hasValue reports whether values contain target after case-insensitive normalization.
func hasValue(values []string, target string) bool {

	normalizedTarget := strings.TrimSpace(strings.ToLower(target))
	for _, value := range values {
		if strings.TrimSpace(strings.ToLower(value)) == normalizedTarget {
			return true
		}
	}
	return false
}

// dedupeCapabilities removes duplicate capability values while preserving order.
func dedupeCapabilities(values []Capability) []Capability {

	seen := make(map[Capability]struct{}, len(values))
	deduped := make([]Capability, 0, len(values))
	for _, value := range values {
		if _, exists := seen[value]; exists {
			continue
		}
		seen[value] = struct{}{}
		deduped = append(deduped, value)
	}
	return deduped
}

```


--| pkg/models/modeltest/client.go

```go
// Package modeltest provides infrastructure for testing LLM provider capabilities
// and capturing request/response pairs as golden files for mock-based regression testing.
//
// This package is self-contained with no dependencies on internal packages,
// allowing it to be used independently or distributed as a standalone binary.
package modeltest

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
)

// ProviderType identifies the API format used by a provider.
type ProviderType string

const (
	ProviderTypeOpenAI    ProviderType = "openai"
	ProviderTypeGemini    ProviderType = "gemini"
	ProviderTypeAnthropic ProviderType = "anthropic"
)

// ClientConfig configures a provider HTTP client.
type ClientConfig struct {
	ProviderName string
	ProviderType ProviderType
	BaseURL      string
	APIKey       string
	Headers      map[string]string
}

// Client is a provider-agnostic HTTP client for LLM APIs.
type Client struct {
	config    ClientConfig
	transport http.RoundTripper
}

// NewClient creates a new provider client.
func NewClient(config ClientConfig) *Client {
	return &Client{
		config:    config,
		transport: http.DefaultTransport,
	}
}

// SetTransport overrides the HTTP transport (for recording/mocking).
func (c *Client) SetTransport(t http.RoundTripper) {
	c.transport = t
}

// Transport returns the current transport.
func (c *Client) Transport() http.RoundTripper {
	return c.transport
}

// Config returns the client configuration.
func (c *Client) Config() ClientConfig {
	return c.config
}

// Do executes an HTTP request with provider-specific authentication.
func (c *Client) Do(ctx context.Context, method, path string, body interface{}) (*http.Response, error) {
	var bodyReader io.Reader
	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("marshal request body: %w", err)
		}
		bodyReader = bytes.NewReader(jsonBody)
	}

	url := strings.TrimSuffix(c.config.BaseURL, "/") + "/" + strings.TrimPrefix(path, "/")
	req, err := http.NewRequestWithContext(ctx, method, url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}

	// Set content type for JSON requests
	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}

	// Apply provider-specific authentication
	c.applyAuth(req)

	// Apply custom headers
	for k, v := range c.config.Headers {
		req.Header.Set(k, v)
	}

	httpClient := &http.Client{Transport: c.transport}
	return httpClient.Do(req)
}

// applyAuth adds provider-specific authentication headers.
func (c *Client) applyAuth(req *http.Request) {
	switch c.config.ProviderType {
	case ProviderTypeOpenAI:
		req.Header.Set("Authorization", "Bearer "+c.config.APIKey)
	case ProviderTypeGemini:
		// Gemini uses query parameter for API key
		q := req.URL.Query()
		q.Set("key", c.config.APIKey)
		req.URL.RawQuery = q.Encode()
	case ProviderTypeAnthropic:
		req.Header.Set("x-api-key", c.config.APIKey)
		req.Header.Set("anthropic-version", "2023-06-01")
	}
}

// ChatRequest represents a chat completion request.
type ChatRequest struct {
	Model       string        `json:"model"`
	Messages    []ChatMessage `json:"messages"`
	MaxTokens   int           `json:"max_tokens,omitempty"`
	Temperature float64       `json:"temperature,omitempty"`
	Stream      bool          `json:"stream,omitempty"`
}

// ChatMessage represents a single message in a chat.
type ChatMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// ImageGenRequest represents an image generation request.
type ImageGenRequest struct {
	Model          string `json:"model,omitempty"`
	Prompt         string `json:"prompt"`
	N              int    `json:"n,omitempty"`
	Size           string `json:"size,omitempty"`
	Quality        string `json:"quality,omitempty"`
	ResponseFormat string `json:"response_format,omitempty"`
}

```


--| pkg/models/modeltest/golden.go

```go
// golden.go provides golden file management for captured request/response pairs.
package modeltest

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// GoldenFileVersion is the schema version for golden files.
const GoldenFileVersion = "1.0"

// GoldenMetadata contains metadata about a golden file.
type GoldenMetadata struct {
	Provider   string    `json:"provider"`
	Capability string    `json:"capability"`
	Model      string    `json:"model"`
	Timestamp  time.Time `json:"timestamp"`
	Version    string    `json:"version"`
}

// GoldenFile represents a complete golden file with metadata and recording.
type GoldenFile struct {
	Metadata GoldenMetadata   `json:"metadata"`
	Request  RecordedRequest  `json:"request"`
	Response RecordedResponse `json:"response"`
}

// NewGoldenFile creates a golden file from a recording.
func NewGoldenFile(provider, capability, model string, rec Recording) *GoldenFile {
	return &GoldenFile{
		Metadata: GoldenMetadata{
			Provider:   provider,
			Capability: capability,
			Model:      model,
			Timestamp:  rec.Timestamp,
			Version:    GoldenFileVersion,
		},
		Request:  rec.Request,
		Response: rec.Response,
	}
}

// Filename generates the standard filename for this golden file.
func (g *GoldenFile) Filename() string {
	// Sanitize model name for filesystem
	model := strings.ReplaceAll(g.Metadata.Model, "/", "_")
	model = strings.ReplaceAll(model, ":", "_")
	
	date := g.Metadata.Timestamp.Format("20060102")
	return fmt.Sprintf("%s_%s_%s.json", g.Metadata.Capability, model, date)
}

// Save writes the golden file to the specified directory.
func (g *GoldenFile) Save(baseDir string) error {
	dir := filepath.Join(baseDir, g.Metadata.Provider)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("create directory: %w", err)
	}

	path := filepath.Join(dir, g.Filename())
	data, err := json.MarshalIndent(g, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal golden file: %w", err)
	}

	if err := os.WriteFile(path, data, 0644); err != nil {
		return fmt.Errorf("write golden file: %w", err)
	}

	return nil
}

// LoadGoldenFile reads a golden file from disk.
func LoadGoldenFile(path string) (*GoldenFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read golden file: %w", err)
	}

	var g GoldenFile
	if err := json.Unmarshal(data, &g); err != nil {
		return nil, fmt.Errorf("unmarshal golden file: %w", err)
	}

	return &g, nil
}

// LoadGoldenFiles loads all golden files from a directory.
func LoadGoldenFiles(baseDir string) ([]*GoldenFile, error) {
	var files []*GoldenFile

	err := filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() || !strings.HasSuffix(path, ".json") {
			return nil
		}

		g, err := LoadGoldenFile(path)
		if err != nil {
			return fmt.Errorf("load %s: %w", path, err)
		}
		files = append(files, g)
		return nil
	})

	if err != nil {
		return nil, err
	}

	return files, nil
}

// GoldenIndex provides fast lookup of golden files by provider/capability/model.
type GoldenIndex struct {
	files map[string]*GoldenFile // key: provider/capability/model
}

// NewGoldenIndex creates an index from loaded golden files.
func NewGoldenIndex(files []*GoldenFile) *GoldenIndex {
	idx := &GoldenIndex{
		files: make(map[string]*GoldenFile),
	}
	for _, f := range files {
		key := f.Metadata.Provider + "/" + f.Metadata.Capability + "/" + f.Metadata.Model
		idx.files[key] = f
	}
	return idx
}

// Lookup finds a golden file by provider, capability, and model.
func (idx *GoldenIndex) Lookup(provider, capability, model string) *GoldenFile {
	key := provider + "/" + capability + "/" + model
	return idx.files[key]
}

```


--| pkg/models/modeltest/mock.go

```go
// mock.go implements HTTP transport that replays golden file responses.
package modeltest

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"strings"
)

// MockTransport replays responses from golden files.
type MockTransport struct {
	index    *GoldenIndex
	provider string
	model    string
}

// NewMockTransport creates a transport that serves responses from golden files.
func NewMockTransport(index *GoldenIndex, provider, model string) *MockTransport {
	return &MockTransport{
		index:    index,
		provider: provider,
		model:    model,
	}
}

// RoundTrip implements http.RoundTripper by matching requests to golden files.
func (t *MockTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	capability := t.inferCapability(req)
	if capability == "" {
		return nil, fmt.Errorf("could not infer capability from request: %s %s", req.Method, req.URL.Path)
	}

	golden := t.index.Lookup(t.provider, capability, t.model)
	if golden == nil {
		return nil, fmt.Errorf("no golden file for %s/%s/%s", t.provider, capability, t.model)
	}

	// Build response from golden file
	resp := &http.Response{
		Status:     fmt.Sprintf("%d %s", golden.Response.Status, http.StatusText(golden.Response.Status)),
		StatusCode: golden.Response.Status,
		Header:     make(http.Header),
		Body:       io.NopCloser(bytes.NewReader(golden.Response.Body)),
		Request:    req,
	}

	for k, v := range golden.Response.Headers {
		resp.Header.Set(k, v)
	}

	return resp, nil
}

// inferCapability determines the capability from the request URL.
func (t *MockTransport) inferCapability(req *http.Request) string {
	path := req.URL.Path

	// OpenAI-style endpoints
	if strings.Contains(path, "/chat/completions") {
		return "chat"
	}
	if strings.Contains(path, "/images/generations") {
		return "image_gen"
	}
	if strings.Contains(path, "/images/edits") {
		return "image_edit"
	}
	if strings.Contains(path, "/models") {
		return "test_connection"
	}

	// Gemini-style endpoints
	if strings.Contains(path, ":generateContent") {
		return "chat"
	}
	if strings.Contains(path, "imagen") || strings.Contains(path, ":predict") {
		return "image_gen"
	}

	// Anthropic-style endpoints
	if strings.Contains(path, "/messages") {
		return "chat"
	}

	return ""
}

// CapabilityMatcher allows custom capability matching rules.
type CapabilityMatcher interface {
	Match(req *http.Request) string
}

// RequestMatcher compares incoming requests to golden file requests.
type RequestMatcher struct {
	IgnoreHeaders []string // Headers to ignore when matching
	IgnoreFields  []string // JSON fields to ignore in body
}

// DefaultRequestMatcher returns a matcher with sensible defaults.
func DefaultRequestMatcher() *RequestMatcher {
	return &RequestMatcher{
		IgnoreHeaders: []string{"Authorization", "X-Api-Key", "Date", "User-Agent"},
		IgnoreFields:  []string{"user", "stream"},
	}
}

// Matches checks if an incoming request matches a golden file request.
func (m *RequestMatcher) Matches(req *http.Request, golden RecordedRequest) bool {
	// Method must match
	if req.Method != golden.Method {
		return false
	}

	// Path must match (ignoring query params for now)
	reqPath := req.URL.Path
	goldenPath := strings.Split(golden.URL, "?")[0]
	if !strings.HasSuffix(goldenPath, reqPath) && !strings.HasSuffix(reqPath, goldenPath) {
		return false
	}

	return true
}

```


--| pkg/models/modeltest/recorder.go

```go
// recorder.go implements HTTP round-trip recording for golden file capture.
package modeltest

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"time"
)

// RecordedRequest contains a captured HTTP request.
type RecordedRequest struct {
	Method  string            `json:"method"`
	URL     string            `json:"url"`
	Headers map[string]string `json:"headers"`
	Body    json.RawMessage   `json:"body,omitempty"`
}

// RecordedResponse contains a captured HTTP response.
type RecordedResponse struct {
	Status  int               `json:"status"`
	Headers map[string]string `json:"headers"`
	Body    json.RawMessage   `json:"body,omitempty"`
}

// Recording represents a single captured request/response pair.
type Recording struct {
	Timestamp time.Time        `json:"timestamp"`
	Request   RecordedRequest  `json:"request"`
	Response  RecordedResponse `json:"response"`
	Duration  time.Duration    `json:"duration_ms"`
	Error     string           `json:"error,omitempty"`
}

// RecordingTransport wraps an http.RoundTripper to capture request/response pairs.
type RecordingTransport struct {
	underlying http.RoundTripper
	recordings []Recording
	mu         sync.Mutex

	// Patterns to sanitize in headers and bodies
	sensitivePatterns []*regexp.Regexp
}

// NewRecordingTransport creates a transport that records HTTP exchanges.
func NewRecordingTransport(underlying http.RoundTripper) *RecordingTransport {
	if underlying == nil {
		underlying = http.DefaultTransport
	}
	return &RecordingTransport{
		underlying: underlying,
		sensitivePatterns: []*regexp.Regexp{
			regexp.MustCompile(`(?i)(api[_-]?key|authorization|x-api-key|bearer)\s*[:=]\s*["']?([^"'\s,}]+)`),
			regexp.MustCompile(`(?i)key=([^&\s]+)`),
		},
	}
}

// RoundTrip implements http.RoundTripper.
func (t *RecordingTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	start := time.Now()
	rec := Recording{
		Timestamp: start,
		Request:   t.captureRequest(req),
	}

	resp, err := t.underlying.RoundTrip(req)
	rec.Duration = time.Since(start)

	if err != nil {
		rec.Error = err.Error()
	} else {
		rec.Response = t.captureResponse(resp)
	}

	t.mu.Lock()
	t.recordings = append(t.recordings, rec)
	t.mu.Unlock()

	return resp, err
}

// Recordings returns all captured recordings.
func (t *RecordingTransport) Recordings() []Recording {
	t.mu.Lock()
	defer t.mu.Unlock()
	result := make([]Recording, len(t.recordings))
	copy(result, t.recordings)
	return result
}

// Clear removes all recordings.
func (t *RecordingTransport) Clear() {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.recordings = nil
}

// captureRequest extracts request data for recording.
func (t *RecordingTransport) captureRequest(req *http.Request) RecordedRequest {
	rec := RecordedRequest{
		Method:  req.Method,
		URL:     t.sanitize(req.URL.String()),
		Headers: make(map[string]string),
	}

	// Capture and sanitize headers
	for k, v := range req.Header {
		if len(v) > 0 {
			rec.Headers[k] = t.sanitize(v[0])
		}
	}

	// Capture body if present
	if req.Body != nil && req.Body != http.NoBody {
		bodyBytes, err := io.ReadAll(req.Body)
		if err == nil {
			req.Body = io.NopCloser(bytes.NewReader(bodyBytes)) // Reset body
			sanitized := t.sanitize(string(bodyBytes))
			rec.Body = json.RawMessage(sanitized)
		}
	}

	return rec
}

// captureResponse extracts response data for recording.
func (t *RecordingTransport) captureResponse(resp *http.Response) RecordedResponse {
	rec := RecordedResponse{
		Status:  resp.StatusCode,
		Headers: make(map[string]string),
	}

	for k, v := range resp.Header {
		if len(v) > 0 {
			rec.Headers[k] = v[0]
		}
	}

	// Capture body
	if resp.Body != nil {
		bodyBytes, err := io.ReadAll(resp.Body)
		if err == nil {
			resp.Body = io.NopCloser(bytes.NewReader(bodyBytes)) // Reset body
			rec.Body = json.RawMessage(bodyBytes)
		}
	}

	return rec
}

// sanitize removes sensitive data from a string.
func (t *RecordingTransport) sanitize(s string) string {
	result := s
	for _, pattern := range t.sensitivePatterns {
		result = pattern.ReplaceAllStringFunc(result, func(match string) string {
			// Extract the prefix and replace the sensitive value
			parts := strings.SplitN(match, "=", 2)
			if len(parts) == 2 {
				return parts[0] + "=REDACTED"
			}
			parts = strings.SplitN(match, ":", 2)
			if len(parts) == 2 {
				return parts[0] + ": REDACTED"
			}
			return "REDACTED"
		})
	}
	return result
}

```


--| pkg/models/modeltest/runner.go

```go
// runner.go orchestrates test execution across providers and capabilities.
// pkg/models/modeltest/runner.go
package modeltest

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"sync"
	"time"

	"gopkg.in/yaml.v3"
)

// RunnerConfig configures the test runner.
type RunnerConfig struct {
	OutputDir    string       // Directory for golden files
	Mode         string       // "live" or "mock"
	Providers    []string     // Providers to test (empty = all)
	Capabilities []Capability // Capabilities to test (empty = all)
	Parallel     int          // Max parallel tests (0 = sequential)
	Timeout      time.Duration
}

// DefaultRunnerConfig returns sensible defaults.
func DefaultRunnerConfig() RunnerConfig {
	return RunnerConfig{
		OutputDir: "testdata/golden",
		Mode:      "mock",
		Parallel:  1,
		Timeout:   30 * time.Second,
	}
}

// ProviderConfig describes a provider for testing.
type ProviderConfig struct {
	Name    string       `yaml:"name"`
	Type    ProviderType `yaml:"type"`
	BaseURL string       `yaml:"base_url"`
	APIKey  string       `yaml:"-"` // From environment
	Models  []ModelConfig `yaml:"models"`
}

// ModelConfig describes a model for testing.
type ModelConfig struct {
	ID           string       `yaml:"id"`
	Capabilities []Capability `yaml:"capabilities"`
}

// TestPlan contains all tests to run.
type TestPlan struct {
	Providers []ProviderConfig
}

// Runner executes tests according to a plan.
type Runner struct {
	config RunnerConfig
	plan   *TestPlan
	index  *GoldenIndex
}

// NewRunner creates a test runner.
func NewRunner(config RunnerConfig) *Runner {
	return &Runner{
		config: config,
	}
}

// LoadPlan loads the test plan from a YAML file.
func (r *Runner) LoadPlan(path string) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("read plan file: %w", err)
	}

	var plan TestPlan
	if err := yaml.Unmarshal(data, &plan); err != nil {
		return fmt.Errorf("parse plan: %w", err)
	}

	// Load API keys from environment
	for i := range plan.Providers {
		envVar := fmt.Sprintf("%s_API_KEY", toEnvName(plan.Providers[i].Name))
		plan.Providers[i].APIKey = os.Getenv(envVar)
	}

	r.plan = &plan
	return nil
}

// LoadEmbeddedCatalogPlan derives and loads a test plan from the canonical model catalog.
func (r *Runner) LoadEmbeddedCatalogPlan() error {

	plan, err := LoadEmbeddedCatalogPlan()
	if err != nil {
		return err
	}
	r.plan = plan
	return nil
}

// LoadGoldenFiles loads golden files for mock mode.
func (r *Runner) LoadGoldenFiles() error {
	files, err := LoadGoldenFiles(r.config.OutputDir)
	if err != nil {
		if os.IsNotExist(err) {
			r.index = NewGoldenIndex(nil)
			return nil
		}
		return err
	}
	r.index = NewGoldenIndex(files)
	return nil
}

// Run executes all tests in the plan.
func (r *Runner) Run(ctx context.Context) ([]TestResult, error) {
	if r.plan == nil {
		return nil, fmt.Errorf("no test plan loaded")
	}

	if r.config.Mode == "mock" {
		if err := r.LoadGoldenFiles(); err != nil {
			return nil, fmt.Errorf("load golden files: %w", err)
		}
	}

	var results []TestResult
	var mu sync.Mutex

	// Create work items
	type workItem struct {
		provider ProviderConfig
		model    ModelConfig
		cap      Capability
	}
	var work []workItem

	for _, prov := range r.plan.Providers {
		if !r.shouldTestProvider(prov.Name) {
			continue
		}
		for _, model := range prov.Models {
			for _, cap := range model.Capabilities {
				if !r.shouldTestCapability(cap) {
					continue
				}
				work = append(work, workItem{prov, model, cap})
			}
		}
	}

	// Execute tests
	workers := r.config.Parallel
	if workers <= 0 {
		workers = 1
	}

	workCh := make(chan workItem, len(work))
	for _, w := range work {
		workCh <- w
	}
	close(workCh)

	var wg sync.WaitGroup
	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for w := range workCh {
				result := r.runTest(ctx, w.provider, w.model, w.cap)
				mu.Lock()
				results = append(results, result)
				mu.Unlock()
			}
		}()
	}
	wg.Wait()

	return results, nil
}

// runTest executes a single test.
func (r *Runner) runTest(ctx context.Context, prov ProviderConfig, model ModelConfig, cap Capability) TestResult {
	ctx, cancel := context.WithTimeout(ctx, r.config.Timeout)
	defer cancel()

	client := NewClient(ClientConfig{
		ProviderName: prov.Name,
		ProviderType: prov.Type,
		BaseURL:      prov.BaseURL,
		APIKey:       prov.APIKey,
	})

	var transport http.RoundTripper
	if r.config.Mode == "live" {
		recorder := NewRecordingTransport(nil)
		transport = recorder
		client.SetTransport(transport)

		tester := GetTester(cap)
		if tester == nil {
			return TestResult{
				Provider:   prov.Name,
				Capability: cap,
				Model:      model.ID,
				Error:      "unknown capability",
			}
		}

		result := tester.Test(ctx, client, model.ID)

		// Save recording as golden file
		if result.Success && len(recorder.Recordings()) > 0 {
			golden := NewGoldenFile(prov.Name, string(cap), model.ID, recorder.Recordings()[0])
			if err := golden.Save(r.config.OutputDir); err != nil {
				result.Error = fmt.Sprintf("save golden file: %v", err)
			}
		}

		return result
	}

	// Mock mode
	mockTransport := NewMockTransport(r.index, prov.Name, model.ID)
	client.SetTransport(mockTransport)

	tester := GetTester(cap)
	if tester == nil {
		return TestResult{
			Provider:   prov.Name,
			Capability: cap,
			Model:      model.ID,
			Error:      "unknown capability",
		}
	}

	return tester.Test(ctx, client, model.ID)
}

// shouldTestProvider checks if a provider should be tested.
func (r *Runner) shouldTestProvider(name string) bool {
	if len(r.config.Providers) == 0 {
		return true
	}
	for _, p := range r.config.Providers {
		if p == name {
			return true
		}
	}
	return false
}

// shouldTestCapability checks if a capability should be tested.
func (r *Runner) shouldTestCapability(cap Capability) bool {
	if len(r.config.Capabilities) == 0 {
		return true
	}
	for _, c := range r.config.Capabilities {
		if c == cap {
			return true
		}
	}
	return false
}

// toEnvName converts a provider name to environment variable format.
func toEnvName(name string) string {
	result := ""
	for _, c := range name {
		if c >= 'a' && c <= 'z' {
			result += string(c - 32) // uppercase
		} else if c >= 'A' && c <= 'Z' {
			result += string(c)
		} else if c >= '0' && c <= '9' {
			result += string(c)
		} else {
			result += "_"
		}
	}
	return result
}

// Report contains aggregated test results.
type Report struct {
	Timestamp  time.Time    `json:"timestamp"`
	TotalTests int          `json:"total_tests"`
	Passed     int          `json:"passed"`
	Failed     int          `json:"failed"`
	Results    []TestResult `json:"results"`
}

// GenerateReport creates a summary report from test results.
func GenerateReport(results []TestResult) Report {
	report := Report{
		Timestamp:  time.Now(),
		TotalTests: len(results),
		Results:    results,
	}
	for _, r := range results {
		if r.Success {
			report.Passed++
		} else {
			report.Failed++
		}
	}
	return report
}

```


--| pkg/zerologtest/assertions.go

```go
// assertions.go provides matcher utilities and test diagnostics for captured entries.
// pkg/zerologtest/assertions.go
package zerologtest

import (
	"fmt"
	"strings"
	"testing"
)

// AssertionOption configures assertion diagnostics behavior.
type AssertionOption func(config *assertionConfig)

// assertionConfig defines assertion rendering defaults.
type assertionConfig struct {
	lastNEntries int
	focusFields  []string
}

var defaultFocusFields = []string{
	FieldEventCode,
	FieldLevel,
	FieldComponent,
	FieldOp,
	FieldStatus,
	FieldMessage,
}

// WithLastNEntries limits diagnostic output to the last N entries.
func WithLastNEntries(lastNEntries int) AssertionOption {

	return func(config *assertionConfig) {
		if lastNEntries > 0 {
			config.lastNEntries = lastNEntries
		}
	}
}

// WithFocusFields appends additional fields to diagnostic output.
func WithFocusFields(fields ...string) AssertionOption {

	return func(config *assertionConfig) {
		for _, field := range fields {
			if strings.TrimSpace(field) != "" {
				config.focusFields = append(config.focusFields, field)
			}
		}
	}
}

// Contains returns whether any entry matches the predicate.
func Contains(entries []Entry, predicate Predicate) bool {

	if predicate == nil {
		return false
	}

	for _, entry := range entries {
		if predicate.Match(entry) {
			return true
		}
	}
	return false
}

// InOrder returns whether predicates match in the same order as entries.
func InOrder(entries []Entry, predicates ...Predicate) bool {

	normalizedPredicates := normalizePredicates(predicates)
	if len(normalizedPredicates) == 0 {
		return true
	}

	predicateIndex := 0
	for _, entry := range entries {
		if normalizedPredicates[predicateIndex].Match(entry) {
			predicateIndex++
			if predicateIndex == len(normalizedPredicates) {
				return true
			}
		}
	}

	return false
}

// AssertContains fails the test when no entry matches.
func AssertContains(t testing.TB, entries []Entry, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	if Contains(entries, predicate) {
		return
	}

	config := buildAssertionConfig(options...)
	t.Fatalf(
		"expected at least one entry matching %s, but none matched.\nRecent entries:\n%s",
		describePredicate(predicate),
		renderEntries(lastNEntries(entries, config.lastNEntries), config.focusFields),
	)
}

// AssertNotContains fails the test when any entry matches.
func AssertNotContains(t testing.TB, entries []Entry, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	if !Contains(entries, predicate) {
		return
	}

	config := buildAssertionConfig(options...)
	matchingEntries := filterEntries(entries, predicate)
	t.Fatalf(
		"expected no entries matching %s, but found %d matching entries.\nMatching entries:\n%s",
		describePredicate(predicate),
		len(matchingEntries),
		renderEntries(lastNEntries(matchingEntries, config.lastNEntries), config.focusFields),
	)
}

// AssertInOrder fails the test when predicates do not match in order.
func AssertInOrder(t testing.TB, entries []Entry, predicates []Predicate, options ...AssertionOption) {

	t.Helper()

	if InOrder(entries, predicates...) {
		return
	}

	config := buildAssertionConfig(options...)
	t.Fatalf(
		"expected entries to match predicates in order (%s), but order check failed.\nRecent entries:\n%s",
		joinPredicateDescriptions(normalizePredicates(predicates)),
		renderEntries(lastNEntries(entries, config.lastNEntries), config.focusFields),
	)
}

// AssertRecorderContains fails when recorder entries do not contain a match.
func AssertRecorderContains(t testing.TB, recorder *Recorder, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	entries := recorder.Entries()
	AssertContains(t, entries, predicate, options...)
}

// AssertRecorderNotContains fails when recorder entries contain a match.
func AssertRecorderNotContains(t testing.TB, recorder *Recorder, predicate Predicate, options ...AssertionOption) {

	t.Helper()

	entries := recorder.Entries()
	AssertNotContains(t, entries, predicate, options...)
}

// AssertRecorderInOrder fails when recorder entries do not match predicate order.
func AssertRecorderInOrder(t testing.TB, recorder *Recorder, predicates []Predicate, options ...AssertionOption) {

	t.Helper()

	entries := recorder.Entries()
	AssertInOrder(t, entries, predicates, options...)
}

// buildAssertionConfig constructs diagnostics defaults.
func buildAssertionConfig(options ...AssertionOption) assertionConfig {

	config := assertionConfig{
		lastNEntries: 10,
		focusFields:  append([]string{}, defaultFocusFields...),
	}
	for _, option := range options {
		if option != nil {
			option(&config)
		}
	}
	config.focusFields = dedupe(config.focusFields)
	return config
}

// renderEntries renders entries with selected fields for failure diagnostics.
func renderEntries(entries []Entry, focusFields []string) string {

	if len(entries) == 0 {
		return "<no entries captured>"
	}

	var builder strings.Builder
	for index, entry := range entries {
		if index > 0 {
			builder.WriteByte('\n')
		}
		builder.WriteString(fmt.Sprintf("[%d]", index))
		for _, field := range focusFields {
			value, ok := entry.Field(field)
			if !ok {
				continue
			}
			builder.WriteString(fmt.Sprintf(" %s=%q", field, fmt.Sprint(value)))
		}
	}
	return builder.String()
}

// filterEntries returns entries that match a predicate.
func filterEntries(entries []Entry, predicate Predicate) []Entry {

	if predicate == nil {
		return nil
	}

	filtered := make([]Entry, 0, len(entries))
	for _, entry := range entries {
		if predicate.Match(entry) {
			filtered = append(filtered, copyEntry(entry))
		}
	}
	return filtered
}

// lastNEntries returns the last N entries from a slice.
func lastNEntries(entries []Entry, lastNEntries int) []Entry {

	if lastNEntries <= 0 || len(entries) <= lastNEntries {
		copied := make([]Entry, len(entries))
		for index, entry := range entries {
			copied[index] = copyEntry(entry)
		}
		return copied
	}

	start := len(entries) - lastNEntries
	copied := make([]Entry, len(entries[start:]))
	for index, entry := range entries[start:] {
		copied[index] = copyEntry(entry)
	}
	return copied
}

// dedupe removes duplicated field names while preserving order.
func dedupe(items []string) []string {

	seen := map[string]struct{}{}
	deduplicated := make([]string, 0, len(items))
	for _, item := range items {
		if _, exists := seen[item]; exists {
			continue
		}
		seen[item] = struct{}{}
		deduplicated = append(deduplicated, item)
	}
	return deduplicated
}

```


--| pkg/zerologtest/doc.go

```go
// Package zerologtest captures and asserts structured zerolog events in tests.
// pkg/zerologtest/doc.go
package zerologtest

```


--| pkg/zerologtest/entry.go

```go
// entry.go models a single structured log entry for test assertions.
// pkg/zerologtest/entry.go
package zerologtest

// Contract field names for structured log assertions.
const (
	FieldTime      = "time"
	FieldCaller    = "caller"
	FieldLevel     = "level"
	FieldMessage   = "message"
	FieldEventCode = "event_code"
	FieldComponent = "component"
	FieldOp        = "op"
	FieldStatus    = "status"
	FieldErrKind   = "err_kind"
)

// EventCodeDecodeFailed flags invalid JSON writes to the recorder.
const EventCodeDecodeFailed = "LOG_DECODE_FAILED"

// PresenceOnlyValue marks fields that were intentionally normalized to presence-only.
const PresenceOnlyValue = "<present>"

// Entry stores one captured structured log event.
type Entry struct {
	Fields map[string]any
}

// Field returns the value for a field key.
func (entry Entry) Field(key string) (any, bool) {

	value, ok := entry.Fields[key]
	return value, ok
}

// StringField returns a string field value when present.
func (entry Entry) StringField(key string) (string, bool) {

	value, ok := entry.Field(key)
	if !ok {
		return "", false
	}
	str, ok := value.(string)
	if !ok {
		return "", false
	}
	return str, true
}

// EventCode returns the contracted event code.
func (entry Entry) EventCode() string {

	value, _ := entry.StringField(FieldEventCode)
	return value
}

// Level returns the zerolog level field.
func (entry Entry) Level() string {

	value, _ := entry.StringField(FieldLevel)
	return value
}

// Message returns the log message field.
func (entry Entry) Message() string {

	value, _ := entry.StringField(FieldMessage)
	return value
}

// copyEntry clones an entry to keep snapshots immutable.
func copyEntry(entry Entry) Entry {

	return Entry{Fields: copyFields(entry.Fields)}
}

// copyFields clones field maps to avoid shared mutable references.
func copyFields(fields map[string]any) map[string]any {

	if len(fields) == 0 {
		return map[string]any{}
	}

	cloned := make(map[string]any, len(fields))
	for key, value := range fields {
		cloned[key] = value
	}
	return cloned
}

```


--| pkg/zerologtest/logger.go

```go
// logger.go builds zerolog test loggers with contract-friendly defaults.
// pkg/zerologtest/logger.go
package zerologtest

import (
	"io"

	"github.com/rs/zerolog"
)

// NewLogger creates a zerolog logger with timestamp and caller fields.
func NewLogger(writer io.Writer) zerolog.Logger {

	return zerolog.New(writer).Level(zerolog.TraceLevel).With().Timestamp().Caller().Logger()
}

```


--| pkg/zerologtest/predicate.go

```go
// predicate.go defines reusable log predicates and combinators.
// pkg/zerologtest/predicate.go
package zerologtest

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"
	"strings"
)

// Predicate matches a captured log entry.
type Predicate interface {
	// Match returns whether an entry satisfies this predicate.
	Match(entry Entry) bool
	// String describes the predicate for diagnostics.
	String() string
}

// predicateFunc adapts a function into a named Predicate.
type predicateFunc struct {
	description string
	match       func(entry Entry) bool
}

// Match runs the underlying predicate function.
func (predicate predicateFunc) Match(entry Entry) bool {

	if predicate.match == nil {
		return false
	}
	return predicate.match(entry)
}

// String returns a stable predicate description.
func (predicate predicateFunc) String() string {

	return predicate.description
}

// Match defines a custom predicate with a stable description.
func Match(description string, match func(entry Entry) bool) Predicate {

	desc := strings.TrimSpace(description)
	if desc == "" {
		desc = "custom predicate"
	}
	return predicateFunc{
		description: desc,
		match:       match,
	}
}

// HasEventCode matches entries with the provided event code.
func HasEventCode(eventCode string) Predicate {

	return Match(fmt.Sprintf("event_code == %q", eventCode), func(entry Entry) bool {
		return FieldEq(FieldEventCode, eventCode).Match(entry)
	})
}

// HasLevel matches entries with the provided level.
func HasLevel(level string) Predicate {

	return Match(fmt.Sprintf("level == %q", level), func(entry Entry) bool {
		return FieldEq(FieldLevel, level).Match(entry)
	})
}

// HasField matches entries that contain the field key.
func HasField(key string) Predicate {

	return Match(fmt.Sprintf("has field %q", key), func(entry Entry) bool {
		_, ok := entry.Field(key)
		return ok
	})
}

// FieldEq matches entries where the field value equals expected.
func FieldEq(key string, expected any) Predicate {

	return Match(fmt.Sprintf("%s == %v", key, expected), func(entry Entry) bool {
		value, ok := entry.Field(key)
		if !ok {
			return false
		}
		return valuesEqual(value, expected)
	})
}

// FieldContains matches entries where a string field includes a substring.
func FieldContains(key string, substring string) Predicate {

	return Match(fmt.Sprintf("%s contains %q", key, substring), func(entry Entry) bool {
		value, ok := entry.Field(key)
		if !ok {
			return false
		}

		switch typed := value.(type) {
		case string:
			return strings.Contains(typed, substring)
		case []string:
			for _, item := range typed {
				if strings.Contains(item, substring) {
					return true
				}
			}
		case []any:
			for _, item := range typed {
				text, ok := item.(string)
				if ok && strings.Contains(text, substring) {
					return true
				}
			}
		}

		return false
	})
}

// And matches when all predicates are true.
func And(predicates ...Predicate) Predicate {

	normalized := normalizePredicates(predicates)
	return Match("and("+joinPredicateDescriptions(normalized)+")", func(entry Entry) bool {
		for _, predicate := range normalized {
			if !predicate.Match(entry) {
				return false
			}
		}
		return true
	})
}

// Or matches when at least one predicate is true.
func Or(predicates ...Predicate) Predicate {

	normalized := normalizePredicates(predicates)
	return Match("or("+joinPredicateDescriptions(normalized)+")", func(entry Entry) bool {
		for _, predicate := range normalized {
			if predicate.Match(entry) {
				return true
			}
		}
		return false
	})
}

// Not negates a predicate.
func Not(predicate Predicate) Predicate {

	description := "not(<nil>)"
	if predicate != nil {
		description = "not(" + predicate.String() + ")"
	}
	return Match(description, func(entry Entry) bool {
		if predicate == nil {
			return true
		}
		return !predicate.Match(entry)
	})
}

// describePredicate returns a stable fallback-safe predicate description.
func describePredicate(predicate Predicate) string {

	if predicate == nil {
		return "<nil predicate>"
	}
	description := strings.TrimSpace(predicate.String())
	if description == "" {
		return "<unnamed predicate>"
	}
	return description
}

// normalizePredicates filters nil predicates for combinator safety.
func normalizePredicates(predicates []Predicate) []Predicate {

	normalized := make([]Predicate, 0, len(predicates))
	for _, predicate := range predicates {
		if predicate != nil {
			normalized = append(normalized, predicate)
		}
	}
	return normalized
}

// joinPredicateDescriptions concatenates predicate descriptions.
func joinPredicateDescriptions(predicates []Predicate) string {

	if len(predicates) == 0 {
		return ""
	}

	descriptions := make([]string, 0, len(predicates))
	for _, predicate := range predicates {
		descriptions = append(descriptions, describePredicate(predicate))
	}
	return strings.Join(descriptions, ", ")
}

// valuesEqual compares JSON-decoded values and expected values with numeric tolerance.
func valuesEqual(actual any, expected any) bool {

	if reflect.DeepEqual(actual, expected) {
		return true
	}

	actualNumber, actualIsNumber := asFloat64(actual)
	expectedNumber, expectedIsNumber := asFloat64(expected)
	if actualIsNumber && expectedIsNumber {
		return actualNumber == expectedNumber
	}

	return false
}

// asFloat64 converts common numeric JSON value types for robust equality checks.
func asFloat64(value any) (float64, bool) {

	switch typed := value.(type) {
	case float64:
		return typed, true
	case float32:
		return float64(typed), true
	case int:
		return float64(typed), true
	case int8:
		return float64(typed), true
	case int16:
		return float64(typed), true
	case int32:
		return float64(typed), true
	case int64:
		return float64(typed), true
	case uint:
		return float64(typed), true
	case uint8:
		return float64(typed), true
	case uint16:
		return float64(typed), true
	case uint32:
		return float64(typed), true
	case uint64:
		return float64(typed), true
	case json.Number:
		parsed, err := typed.Float64()
		if err != nil {
			return 0, false
		}
		return parsed, true
	case string:
		parsed, err := strconv.ParseFloat(typed, 64)
		if err != nil {
			return 0, false
		}
		return parsed, true
	default:
		return 0, false
	}
}

```


--| pkg/zerologtest/recorder.go

```go
// recorder.go captures zerolog JSON output into concurrency-safe test entries.
// pkg/zerologtest/recorder.go
package zerologtest

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"sync"
)

// Transform scrubs or normalizes decoded entry fields before storage.
type Transform func(fields map[string]any) map[string]any

// Option configures Recorder behavior.
type Option func(recorder *Recorder)

// Recorder captures newline-delimited JSON log entries from zerolog.
type Recorder struct {
	mu                 sync.RWMutex
	pending            []byte
	entries            []Entry
	ignoreFields       map[string]struct{}
	presenceOnlyFields map[string]struct{}
	transform          Transform
	notifyCh           chan struct{}
}

// NewRecorder creates a new structured log recorder.
func NewRecorder(options ...Option) *Recorder {

	recorder := &Recorder{
		ignoreFields:       map[string]struct{}{},
		presenceOnlyFields: map[string]struct{}{},
		notifyCh:           make(chan struct{}, 1),
	}

	for _, option := range options {
		if option != nil {
			option(recorder)
		}
	}

	return recorder
}

// WithIgnoredFields removes configured fields before entries are stored.
func WithIgnoredFields(fields ...string) Option {

	return func(recorder *Recorder) {
		for _, field := range fields {
			if field != "" {
				recorder.ignoreFields[field] = struct{}{}
			}
		}
	}
}

// WithPresenceOnlyFields replaces configured field values with PresenceOnlyValue.
func WithPresenceOnlyFields(fields ...string) Option {

	return func(recorder *Recorder) {
		for _, field := range fields {
			if field != "" {
				recorder.presenceOnlyFields[field] = struct{}{}
			}
		}
	}
}

// WithTransform applies a normalization transform before entry storage.
func WithTransform(transform Transform) Option {

	return func(recorder *Recorder) {
		recorder.transform = transform
	}
}

// Write buffers log bytes and records complete newline-delimited JSON entries.
func (recorder *Recorder) Write(payload []byte) (int, error) {

	if recorder == nil {
		return 0, errors.New("recorder is nil")
	}

	recorder.mu.Lock()
	defer recorder.mu.Unlock()

	recorder.pending = append(recorder.pending, payload...)

	for {
		newlineIndex := bytes.IndexByte(recorder.pending, '\n')
		if newlineIndex < 0 {
			break
		}

		line := make([]byte, newlineIndex)
		copy(line, recorder.pending[:newlineIndex])
		recorder.pending = recorder.pending[newlineIndex+1:]
		recorder.captureLine(line)
	}

	return len(payload), nil
}

// Entries returns a snapshot copy of captured entries.
func (recorder *Recorder) Entries() []Entry {

	if recorder == nil {
		return nil
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	copied := make([]Entry, len(recorder.entries))
	for index, entry := range recorder.entries {
		copied[index] = copyEntry(entry)
	}
	return copied
}

// Last returns the most recent captured entry.
func (recorder *Recorder) Last() (Entry, bool) {

	if recorder == nil {
		return Entry{}, false
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	if len(recorder.entries) == 0 {
		return Entry{}, false
	}
	return copyEntry(recorder.entries[len(recorder.entries)-1]), true
}

// Filter returns entries that match the predicate.
func (recorder *Recorder) Filter(predicate Predicate) []Entry {

	if recorder == nil || predicate == nil {
		return nil
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	filtered := make([]Entry, 0, len(recorder.entries))
	for _, entry := range recorder.entries {
		if predicate.Match(entry) {
			filtered = append(filtered, copyEntry(entry))
		}
	}
	return filtered
}

// Contains returns whether at least one entry matches.
func (recorder *Recorder) Contains(predicate Predicate) bool {

	if recorder == nil || predicate == nil {
		return false
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	for _, entry := range recorder.entries {
		if predicate.Match(entry) {
			return true
		}
	}
	return false
}

// WaitFor blocks until an entry matches or context cancellation occurs.
func (recorder *Recorder) WaitFor(ctx context.Context, predicate Predicate) (Entry, error) {

	if recorder == nil {
		return Entry{}, errors.New("recorder is nil")
	}
	if predicate == nil {
		return Entry{}, errors.New("predicate is nil")
	}

	for {
		if entry, ok := recorder.firstMatch(predicate); ok {
			return entry, nil
		}

		select {
		case <-ctx.Done():
			return Entry{}, ctx.Err()
		case <-recorder.notifyCh:
		}
	}
}

// firstMatch returns the first matching entry snapshot.
func (recorder *Recorder) firstMatch(predicate Predicate) (Entry, bool) {

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	for _, entry := range recorder.entries {
		if predicate.Match(entry) {
			return copyEntry(entry), true
		}
	}
	return Entry{}, false
}

// captureLine decodes and stores one complete log line.
func (recorder *Recorder) captureLine(line []byte) {

	trimmed := strings.TrimSpace(strings.TrimSuffix(string(line), "\r"))
	if trimmed == "" {
		return
	}

	entryFields := map[string]any{}
	if err := json.Unmarshal([]byte(trimmed), &entryFields); err != nil {
		entryFields = map[string]any{
			FieldLevel:     "error",
			FieldEventCode: EventCodeDecodeFailed,
			FieldComponent: "zerologtest.recorder",
			FieldOp:        "decode",
			FieldStatus:    "failed",
			FieldErrKind:   "json_decode",
			FieldMessage:   "failed to decode log line",
			"decode_error": err.Error(),
			"raw_line":     trimmed,
		}
	}

	normalized := recorder.normalizeFields(entryFields)
	recorder.entries = append(recorder.entries, Entry{Fields: normalized})
	recorder.signalWaiters()
}

// normalizeFields applies transform, ignore, and presence-only behavior.
func (recorder *Recorder) normalizeFields(fields map[string]any) map[string]any {

	normalized := copyFields(fields)
	if recorder.transform != nil {
		transformed := recorder.transform(copyFields(normalized))
		if transformed != nil {
			normalized = transformed
		}
	}

	if normalized == nil {
		normalized = map[string]any{}
	}

	for ignoredField := range recorder.ignoreFields {
		delete(normalized, ignoredField)
	}
	for presenceOnlyField := range recorder.presenceOnlyFields {
		if _, ok := normalized[presenceOnlyField]; ok {
			normalized[presenceOnlyField] = PresenceOnlyValue
		}
	}

	return normalized
}

// signalWaiters notifies async waiters that new entries were captured.
func (recorder *Recorder) signalWaiters() {

	select {
	case recorder.notifyCh <- struct{}{}:
	default:
	}
}

// String returns a concise snapshot count for quick diagnostics.
func (recorder *Recorder) String() string {

	if recorder == nil {
		return "Recorder(<nil>)"
	}

	recorder.mu.RLock()
	defer recorder.mu.RUnlock()

	return fmt.Sprintf("Recorder(entries=%d)", len(recorder.entries))
}

```


--| wails.json

```json
{
  "$schema": "https://wails.io/schemas/config.v2.json",
  "name": "wls-chatbot",
  "outputfilename": "wls-chatbot",
  "frontend:install": "npm install",
  "frontend:build": "npm run build",
  "frontend:dev:watcher": "npm run dev",
  "frontend:dev:serverUrl": "auto"
}

```

